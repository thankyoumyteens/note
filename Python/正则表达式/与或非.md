# 匹配不包含某些字符串

匹配不包含`hede`的字符串
```
^((?!hede).)*$
```

# 与

- 直接连续写出相继出现的元素就可以, 比如`cat`和`c[au]t`

# 或

- 用字符组来表达单个字符或的关系, 比如匹配cat或者cut, 正则表达式写做`c[au]t`
- 用多选分支来表达多个字符或的关系, 比如匹配c开头t结尾的单词chart, conduct和court, 正则表达式为`c(u|har|onduc|our)t`
- 多选分支使用的括号会捕获文本的, 在左扩号之后加上字符`?:`关闭捕获文本, 正则表达式为`c(?:u|har|onduc|our)t`

# 非

- 中间的字符不能是a或u, 则表达式为`c[^au]t`
- 如果还想要匹配chart, conduct和court, 就可以用否定顺序环视`(?!…)`来解决, 它表示在这个位置向右, 不容许出现子表达式能够匹配的文本, 我们把子表达式规定为`[au]t\b`, 最后的`\b`保证t是单词的结尾字母, 所以表达式就变成了`c(?![au]t\b)\w+t`

如果整个匹配文本中都不能出现字符串cat, 要怎么办呢？许多人的思路就是借鉴处理或关系的思路：既然字符组对应单个字符的情况, 多选分支对应多个字符的情况, 那么在否定时也是这样可惜, 正则表达式并没有提供与多选分支对应的否定结构

解决的办法还是得依靠否定顺序环视——整个匹配文本中都不能出现字符串cat, 换句话说, 就是在文本中的任意位置, 向右, 都不能出现该字符串因此, 我们用两个锚点`^`和`$`, 分别匹配整个字符串的开头和结尾位置, 再用否定顺序环视`(?!cat)`表达不能出现字符串cat

即便知道了原理, 也不见得能写对正则表达式, 比如`^(?!cat).+$`就是不正确的, 因为它只限定了在文本的开头（也就是`^`）右边不能出现cat, 而我们真正要做的是, 在文本的每一个位置右边, 都不能出现cat, 所以应该改成`^((?!cat).)+$`；但这还说不上完美, 根据前面提到的关于括号捕获的知识, 因为此处并不需要括号捕获的文本, 所以最好使用非捕获型括号`(?:…)`, 最终我们得到的表达式就是`^(?:(?!cat).)+$`

