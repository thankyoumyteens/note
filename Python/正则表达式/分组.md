# 分组

## group

除了简单地判断是否匹配之外, 正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组。比如：`^(\d{3})-(\d{3,8})$`分别定义了两个组, 可以直接从匹配的字符串中提取出区号和本地号码

```
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(m.group(0))
print(m.group(1))
print(m.group(2))

# 010-12345
# 010
# 12345
```
如果正则表达式中定义了组, 就可以在Match对象上用group()方法提取出子串来。

注意到`group(0)`永远是原始字符串, `group(1)`, `group(2)`表示第1, 2个子串。

## groups

```
t = '19:05:30'
m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(m.groups())

#输出：
# ('19', '05', '30')
```

## 指定group的名字

和其他的RE表达式一样, 但是匹配的子串可以通过group的名字name来获取。即`result.group('name')`。组名必须是合法的python标识符, 每一个组名在RE表达式中有且只能被定义一次。这样特殊的组仍然被定义了序号, 就像没有命名的组一样(可以通过\number的形式进行访问)。在正则表达式中使用组名`(?P<name>['"]).*`

```
sentence = 'cats are fast'
regex = re.compile('(?P<animal>\w+) (?P<verb>\w+) (?P<adjective>\w+)')
matched = re.search(regex, sentence)
print(matched.groupdict())

# {'adjective': 'fast', 'verb': 'are', 'animal': 'cats'}
```

## 贪心匹配

```
print(re.match(r'^(\d+)(0*)$', '102300').groups())
# ('102300', '')
print(re.match(r'^(\d+?)(0*)$', '102300').groups())
# ('1023', '00')
```
由于`\d+`采用贪婪匹配, 直接把后面的0全部匹配了, 结果0*只能匹配空字符串, 加个`?`就可以让`\d+`采用非贪婪匹配；

## 编译

如果一个正则表达式要重复使用几千次, 出于效率的考虑, 我们可以预编译该正则表达式

```
# 编译
tele = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
print(tele.match('010-12345').groups())
# ('010', '12345')
print(tele.match('010-8086').groups())
# ('010', '8086')
```
