# 两大类索引

## 聚簇索引

- 如果表设置了主键，则主键就是聚簇索引
- 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引
- 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引

InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。

由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。

### 存储结构
id 是主键，所以是聚簇索引，其叶子节点存储的是对应行记录的数据
```
                    [1-4]
                  /       \
        [1-2]                 [3-4]
      /       \             /       \
    1          2          3          4
    |          |          |          |
{1,张三,30} {2,李四,20} {3,王五,40} {4,刘八,10}   
```

### 查找过程
如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。
如：`select * from user where id = 1;`

## 普通索引

普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。

InnoDB的普通索引叶子节点存储的是主键（聚簇索引）的值，而MyISAM的普通索引存储的是记录指针。

### 存储结构
age 是普通索引（二级索引），非聚簇索引，其叶子节点存储的是聚簇索引的的值
```
                   [10-40]
                  /       \
       [10-20]               [30-40]
      /       \             /       \
    10         20         30         40
    |          |          |          |
   {4}        {2}        {1}        {3}
```

### 查找过程
如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 
如：`select * from user where age = 30;`

# 回表查询

先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。

# 索引覆盖

只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。

# 实现覆盖索引

## 情况1
```sql
select id,age from user where age = 10;
```
因为age是普通索引，select又使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引

# 情况2
```sql
select id,age,name from user where age = 10;
```
age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值

# 情况3
将被查询的字段，建立到联合索引里去
```sql
drop index idx_age on user;
create index idx_age_name on user(`age`,`name`);
```
```sql
select id,age,name from user where age = 10;
```
此时字段age和name是组合索引idx_age_name，查询的字段id、age、name的值刚刚都在索引树上，只需扫描一次组合索引B+树即可，这就是实现了索引覆盖
