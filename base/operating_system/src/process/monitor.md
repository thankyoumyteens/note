# 管程

Monitor 直译过来就是 "监视器", 操作系统领域一般都翻译成 "管程"。所谓管程, 指的是管理共享变量以及对共享变量的操作过程, 让他们支持并发。

管程是为了解决信号量在临界区的 PV 操作上的配对的麻烦, 把配对的 PV 操作集中在一起, 生成的一种并发编程方法。其中使用了条件变量这种同步机制。

条件变量: 每个条件变量表示一种等待原因, 对应一个等待队列, 每个条件变量有一个 Wait 操作和 Signal 操作。

Wait() 操作: 将自己阻塞在等待队列中。

Signal() 操作: 将等待队列中的一个线程唤醒。

## 用管程解决生产者消费者问题

1. **定义管程**: 
   创建一个管程, 它将包含共享缓冲区、一个表示缓冲区中空闲位置的数量的变量（例如 `empty`）, 以及一个表示缓冲区中产品数量的变量（例如 `full`）。

2. **初始化条件变量**: 
   在管程中定义两个条件变量, `notFull` 和 `notEmpty`。`notFull` 用于同步生产者, 当缓冲区未满时唤醒生产者；`notEmpty` 用于同步消费者, 当缓冲区不为空时唤醒消费者。

3. **生产者逻辑**: 

   - 生产者在生产一个产品后, 尝试进入管程。
   - 在管程内, 生产者首先检查缓冲区是否已满（`empty == 0`）, 如果满了, 生产者在 `notFull` 条件变量上等待。
   - 如果缓冲区未满, 生产者将产品放入缓冲区, 减少 `empty` 的计数, 增加 `full` 的计数。
   - 生产者离开管程前, 通过 `notEmpty` 条件变量唤醒一个等待的消费者。

4. **消费者逻辑**: 

   - 消费者在尝试消费产品时, 首先进入管程。
   - 在管程内, 消费者检查缓冲区是否为空（`full == 0`）, 如果为空, 消费者在 `notEmpty` 条件变量上等待。
   - 如果缓冲区不为空, 消费者从缓冲区取出产品, 减少 `full` 的计数, 增加 `empty` 的计数。
   - 消费者离开管程前, 通过 `notFull` 条件变量唤醒一个等待的生产者。

5. **避免竞态条件**: 
   通过在管程的互斥锁保护下访问共享资源, 确保在任何时刻只有一个生产者或消费者能够修改缓冲区的状态。

以下是使用管程解决生产者-消费者问题的一个伪代码示例: 

```c
monitor Buffer {
    int empty;    // 缓冲区空闲位置的数量
    int full;     // 缓冲区中产品的数量
    // 条件变量
    condition notFull;
    condition notEmpty;

    void produce() {
        enterBuffer();
        empty--;
        full++;
        if (empty == 0) {
            wait(notFull);
        }
        signal(notEmpty);
        leaveBuffer();
    }

    void consume() {
        enterBuffer();
        full--;
        empty++;
        if (full == 0) {
            wait(notEmpty);
        }
        signal(notFull);
        leaveBuffer();
    }

    void enterBuffer() {
        // 进入管程的代码, 获取互斥锁
    }

    void leaveBuffer() {
        // 离开管程的代码, 释放互斥锁
    }
}
```

`enterBuffer` 和 `leaveBuffer` 两个方法将确保互斥访问共享资源。
