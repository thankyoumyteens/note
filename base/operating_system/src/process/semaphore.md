# 信号量机制

信号量机制是一种用于进程或线程同步和互斥的高级方法。它是由荷兰计算机科学家 Edsger Dijkstra 在 1965 年提出的。整型信号量是一个整数变量, 可以用来控制对共享资源的访问。

整型信号量有两种主要类型:

1. **二元信号量(Binary Semaphore)**: 二元信号量只有两种状态, 0 和 1。它通常用于互斥, 即一次只允许一个进程或线程访问共享资源。二元信号量也被称为互斥锁(mutex)。当一个进程想要进入临界区时, 它会尝试将信号量从 1 减到 0。如果信号量的值已经是 0, 那么进程必须等待。当进程离开临界区时, 它会将信号量的值从 0 增加到 1, 释放资源

2. **计数信号量(Counting Semaphore)**: 计数信号量可以有大于 1 的值, 表示可用资源的数量。它允许多个进程或线程同时访问共享资源, 但不超过信号量指定的数量。例如, 如果有 5 个可用的资源, 计数信号量的初始值将被设置为 5。进程在访问资源前会尝试将信号量减 1, 如果信号量的值在减 1 后仍然非负, 则进程可以继续执行。否则, 进程必须等待。当进程完成资源的使用并离开时, 它会将信号量增加 1

用户进程可以通过使用操作系统提供的一对原语(P, V)来对信号量进行操作, 从而很方便的实现了进程互斥、进程同步。信号量的主要操作包括:

- **P 操作(Proberen, 尝试)**: 也称为 wait 或 down 操作。如果信号量的值大于 0, P 操作将信号量的值减 1, 表示资源被占用。如果信号量的值为 0, 进程必须等待, 直到信号量的值变得大于 0
- **V 操作(Verhogen, 增加)**: 也称为 signal 或 up 操作。V 操作将信号量的值加 1, 表示资源已释放

原语(Primitive Operation)指的是一组不可分割的操作, 它们在执行过程中不会被其他操作(如中断或上下文切换)打断。原语是并发编程和操作系统中确保数据一致性和系统稳定性的关键概念, 通常用于实现同步机制, 如互斥锁、信号量和其他并发控制结构。

在操作系统中, 原语可以通过多种方式实现, 包括:

1. **硬件支持**: 一些处理器提供了原子指令, 如比较并交换(Compare-And-Swap, CAS)或测试并设置(Test-And-Set, TAS), 这些指令可以直接用于实现原语
2. **系统调用**: 操作系统可以提供系统调用级别的原语, 如锁、信号量和其他同步原语, 这些原语通过内核模式执行, 确保了它们的原子性
3. **库函数**: 并发编程库, 如 POSIX 线程库(pthreads), 提供了一系列的原语和同步机制, 如互斥锁、条件变量等, 这些库函数封装了底层的原子操作

```c
// 信号量
int semaphore = 1;

void P(semaphore s) {
    // 申请资源
    while (s <= 0) {
        // 忙等待
    }
    // 使用资源
    semaphore -= 1;
}

void V(semaphore s) {
    // 释放资源
    semaphore += 1;
}
```

## 记录型信号量

整型信号量的缺陷是存在忙等待问题, 因此人们又提出了记录型信号量, 即用记录型数据结构表示的信号量。

- **P 操作的变化**: 如果信号量的值为 0, 进程会进入阻塞态
- **V 操作的变化**: 释放资源后, 如果有其他进程正在等待这个信号量, 唤醒其中一个进程

```c
// 信号量
typedef struct  {
    // 资源数量
    int value;
    // 等待队列
    struct process *queue;
} semaphore;

void P(semaphore s) {
    // 申请资源
    s.value--;
    if (s.value < 0) {
        // 将此进程加入队列,
        // 使进程从运行态进入阻塞态
        block(s.queue);
    }
}

void V(semaphore s) {
    s.value++;
    // value <= 0表示依然有进程在等待该资源
    if (s.value <= 0) {
        // 从队列中取出一个进程
        // 使进程从阻塞态变为就绪态
        wakeup(s.queue);
    }
}
```
