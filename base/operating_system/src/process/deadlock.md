# 死锁

死锁（Deadlock）指的是两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。在这种僵局中，每个进程都持有一定的资源并等待其他进程释放它们所需的资源，若无外力作用，这些进程都将无法继续向前推进。

## 死锁产生的必要条件

死锁具有以下四个基本特征，通常被称为死锁的四个必要条件：

1. **互斥条件**（Mutual Exclusion）：进程对所分配到的资源进行排他性使用，即在一段时间内某资源只能被一个进程占用
2. **占有和等待条件**（Hold and Wait）：进程至少持有一个资源，并且在等待获取其他进程持有的资源
3. **不可剥夺条件**（No Preemption）：已经分配给一个进程的资源，在未使用完之前，不能被强行剥夺，只能由该进程自己释放
4. **循环等待条件**（Circular Wait）：存在一种进程资源的循环等待关系，即进程间形成一种头尾相接的循环链，每个资源至少被链条上的下一个进程所等待

## 死锁的预防

通过破坏死锁的四个必要条件之一来预防死锁的发生。

### 破坏互斥条件

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。

缺点: 并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。

### 破坏占有和等待条件

可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

缺点: 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。

### 不可剥夺条件

1. 方案 1: 当某个进程请求新的资源得不到满足时，它必须立即释放持有的所有资源，待以后需要时再重新申请。也就是说，即使某些已有的资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件
2. 方案 2: 当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级

缺点:

1. 实现起来比较复杂
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如 CPU
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量
4. 若采用方案 1，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重 新申请。如果一直发生这样的情况，就会导致进程饥饿

### 破坏循环等待条件

可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

缺点:

1. 不方便增加新的设备，因为可能需要重新分配所有的编号
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
3. 必须按规定次序申请资源，用户编程麻烦
