# 连续分配管理方式

## 单一连续分配

在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。

内存中只能有一道用户程序，用户程序独占整个用户区空间。

优点: 实现简单, 无外部碎片, 可以采用覆盖技术扩充内存, 不一定需要采取内存保护。

缺点: 只能用于单用户单任务的操作系统中, 有内部碎片, 存储器利用率极低。

## 固定分区分配

20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最简单的一种可运行多道程序的内存管理方式。

固定分区分配分为两种:

- 分区大小相等: 缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如:钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序)
- 分区大小不等: 增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区, 适量中等分区, 少量大分区)

操作系统需要建立一个分区说明表，来实现各个分区的分配与回收。每一条记录对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小, 起始地址, 状态(是否已分配)。

优点: 实现简单，无外部碎片。

缺点: 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。会产生内部碎片，内存利用率低。

## 动态分区分配

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

系统可以使用两种数据结构记录内存的使用情况:

- 空闲分区表: 每个空闲分区对应一个表项。表项中包含分区号, 分区大小, 分区起始地址等信息
- 空闲分区链表: 每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

动态分区分配没有内部碎片，但是有外部碎片。

- 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上, 这些部分就是内部碎片
- 外部碎片，是指内存中的某些空闲分区由于太小而无法利用。即使内存中空闲空间的总和可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些碎片不能满足进程的需求。可以通过紧凑(拼凑，Compaction)技术来解决外部碎片, 类似于标记-压缩算法

动态分区分配算法:
