# 分页存储管理

将内存空间分为一个个大小相等的分区(比如:每个分区 4KB)，每个分区就是一个“页框”或“内存块”。每个页框有一个编号，即“页框号”，页框号从 0 开始。

将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从 0 开始。

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。

## 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。

1. 一个进程对应一张页表
2. 进程的每个页面对应一个页表项
3. 每个页表项由“页号”和“块号”组成
4. 页表记录进程页面和实际存放的内存块之间的映射关系
5. 每个页表项的长度是相同的

![](../img/p1.jpg)

注意：页表记录的只是内存块号，而不是内存块的起地址。i 号内存块的起始地址为： `i * 内存块大小`。

## 每个页表项占多少字节

假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节?

块号至少占用的字节:

1. 内存块大小=页面大小=4KB= 2^12 B
2. 4GB 的内存总共会被分为 2^32 / 2^12 = 2^20 个内存块
3. 内存块号的范围应该是 0 ~ 2^20 -1
4. 内存块号至少要用 20 bit 来表示, 即至少要用 3B 来表示块号(3\*8=24bit)

页表项连续存放，因此页号可以是隐含的，不占存储空间(类比数组的索引)

## 如何实现地址的转换

逻辑地址转换到物理地址:

1. 确定逻辑地址对应的页号: `页号 = 逻辑地址 / 页面长度` (取除法的整数部分)
2. 确定逻辑地址对应的页内偏移量: `页内偏移量 = 逻辑地址 % 页面长度` (取除法的余数部分)
3. 确定页号对应的块号: 查询页表
4. 计算物理地址: `物理地址 = 块号 * 页面长度 + 页内偏移量`

例: 在某计算机系统中，页面大小是 50B。某进程逻辑地址空间大小为 200B，则逻辑地址 110 对应 的页号、页内偏移量是多少?

1. 页号 = 110 / 50 = 2
2. 页内偏移量 = 110 % 50 = 10

在计算机内部，地址是用二进制表示的，如果页面大小是 2 的整数幂，则计算机硬件可以很快速的把逻辑地址拆分出页号和页内偏移量。

逻辑地址的结构:

```
[  页号  |  页内偏移量  ]
```

如果每个页面大小为 2^K 字节，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。并且只需把页表中记录的块号拼接上页内偏移量就能得到对应的物理地址。

例如: 页面大小为 4KB = 2^12 字节 = 4096 字节, 则逻辑地址 4097 的页号和页内偏移量:

1. 4097 用二进制表示 `00000000000000000001 000000000001`
2. 页内偏移量是后 12 位: `000000000001`, 等于 `4097 / 4096 = 1`
3. 页号是其余部分: `00000000000000000001`, 等于 `4097 % 4096 = 1`
4. 假设页号 1 在页表中对应的块号是 9(二进制 1001), 则物理地址为: `1001 000000000001`

## 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址和页表长度。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系 统内核会把它们放到页表寄存器中。

逻辑地址到物理地址的变换过程如下:

1. 从 PC 寄存器中取出逻辑地址
2. 从逻辑地址中拆分出页号和页内偏移量
3. 检查页号的合法性: 如果大于等于页表长度, 会抛出越界中断
4. 根据起始地址找到页表
5. 找出页号在页表中对应的内存块号
6. 根据内存块号和页内偏移量拼接出物理地址

## 快表

快表，又称联想寄存器(translation lookaside buffer, TLB)，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表称为慢表。

引入快表后，地址的变换过程:

1. 从 PC 寄存器中取出逻辑地址
2. 从逻辑地址中拆分出页号和页内偏移量
3. 检查页号的合法性: 如果大于等于页表长度, 会抛出越界中断
4. 在快表中查询页号
   - 如果快表中存在页号
     1. 找出页号在快表中对应的内存块号
     2. 根据内存块号和页内偏移量拼接出物理地址
   - 如果快表中不存在页号
     1. 根据起始地址找到页表
     2. 找出页号在页表中对应的内存块号
     3. 把这条记录复制到快表中, 如果快表满了, 需要淘汰掉快表中的一部分页表项
     4. 根据内存块号和页内偏移量拼接出物理地址

例: 访问一次快表耗时 1 微秒，访问一次内存耗时 100 微秒。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？

```js
// (访问快表 + 访问目标物理地址) * 90% + (访问快表 + 访问慢表 + 访问目标物理地址) * 10%
(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 = 111 微秒
```

有的系统支持快表和慢表同时查找，如果是这样, 访问一个逻辑地址的平均耗时是多少？

```js
// (访问快表 + 访问目标物理地址) * 90% + (访问慢表 + 访问目标物理地址) * 10%
(1 + 100) * 0.9 + (100 + 100) * 0.1 = 110.9 微秒
```

## 局部性原理

时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再
次被访问(因为程序中存在大量的循环)。

空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放
的)。

由于局部性原理，可能连续很多次查到的都是同一个页表项, 所以快表可以大幅提高系统运行效率。

## 单级页表存在的问题

所有的页表项都必须连续存放(这样才能用偏移量找到某一个页表项), 因此当页表很大时，需要占用很多空间。而根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了, 因此没有必要让整个页表都常驻内存。

## 两级页表

把页表进行分组, 使每组的大小和一个内存块的大小相等, 比如页面大小为 4KB, 每个页表项占 4B, 那么以 1024 个页表项为一组, 那么一组正好可以放在一个内存块里。然后把各组离散地放入内存中, 为了知道这些分组的顺序和位置, 需要为这些分组再建立一个页表, 称为页目录表(或者外层页表/顶层页表)。

![](../img/p2.jpg)

## 两级页表的地址变换

1. 按照地址结构将逻辑地址拆分成三部分: 一级页号, 二级页号和页内偏移量
2. 从 PCB 中读出页目录表的地址，再根据一级页号查页目录表，找到块号, 计算出二级页表的物理地址(`块号 * 内存块大小`)
3. 根据二级页号查二级页表，找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址

## 多级页表

若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面。

例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用几级页表，页内偏移量为几位？

页面大小=4KB =2^12 字节，按字节编址，因此页内偏移量为 12 位

页号=40 - 12 = 28 位

页面大小=2^12 字节，页表项大小=4B，则每个页面可存放 2^12/ 4 = 2^10 个页表项

因此各级页表最多包含 2^10 个页表项，需要 10 位二进制位才能映射到 2^10 个页表项，因此每一级的页表对应页号应为 10 位。总共 28 位的页号至少要分为三级。
