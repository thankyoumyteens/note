# 基本分段存储管理

进程的地址空间按照不同的功能划分为若干个段, 每个段都有一个段名, 每段从 0 开始编址。内存空间以段为单位进行分配, 每个段在内存中占据连续空间, 但各段之间可以不相邻。由于段是按逻辑功能模块划分, 所以用户编程更方便, 程序的可读性更高。

分段系统的逻辑地址结构由段号(编译器会将段名转换为段号)和段内地址(段内偏移量)所组成。段号的位数决定了每个进程最多可以分几个段。段内地址位数决定了每个段的最大长度是多少。

逻辑地址的结构:

```
[  段号  |  段内偏移量  ]
```

如果段号占 16 位, 则每个进程最多有 2^16 = 64K 个段。如果段内地址占 16 位, 则每个段的最大长度是 2^16 = 64KB。

程序分多个段, 各段离散地装入内存, 为了保证程序能正常运行, 就必须能从物理内存中找到各个段的存放位置。为此, 需为每个进程建立一张段映射表, 简称段表。

![](../img/seg1.jpg)

每个段对应一个段表项, 其中记录了该段在内存中的起始位置(又称基址)和段的长度。

各个段表项的长度是相同的。例如: 某系统按字节寻址, 采用分段存储管理, 逻辑地址结构为(段号 16 位, 段内地址 16 位), 因此用 16 位 即可表示最大段长。物理内存大小为 4GB(可用 32 位表示整个物理内存地址空间)。因此, 可以让每个段表项占 16 + 32 = 48 位, 即 6 字节。由于段表项长度相同, 因此段号可以是隐含的, 不占存储空间。若段表存放的起始地址为 M, 则 K 号段对应的段表项存放的地址为 `M + K * 6`。

## 地址变换

逻辑地址转换到物理地址(进程获得 CPU 时间后, 它的段表起始地址和段表长度会从 PCB 中复制到段表寄存器中):

1. 根据逻辑地址得到段号和段内地址
2. 检查段号的合法性: 如果大于等于段表长度, 会抛出越界中断
3. 查询段表, 找到对应的段表项, 段表项的存放地址为 `段表起始地址 + 段号 * 段表项长度`
4. 检查段内地址是否超过段长, 如果大于等于段长, 会抛出越界中断
5. 物理地址为 `基址 + 段内地址`

与分页系统类似, 分段系统中也可以引入快表机构, 将近期访问过的段表项放到快表中, 这样可以少一次访问, 加快地址变换速度。

## 分段和分页管理的对比

- 页是信息的物理单位。分页的主要目的是为了实现离散分配, 提高内存利用率。分页仅仅是系统管理上的需要, 完全是系统行为, 对用户是不可见的
- 段是信息的逻辑单位。分段的主要目的是更好地满足用户编程需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的, 用户编程时需要显式地给出段名
- 页的大小固定且由系统决定。段的长度却不固定, 决定于用户编写的程序
- 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码, 这样的代码是可以共享的。可修改的代码是不能共享的(比如, 有一个代码段中有很多变量, 各进程并发地同时访问可能造成数据不一致)
