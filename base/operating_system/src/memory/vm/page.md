# 请求分页管理方式

请求分页存储管理与基本分页存储管理相比, 增加了:

- 请求调页功能: 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序
- 页面置换功能: 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

为了实现请求调页，操作系统需要知道每个页面是否已经调入内存, 如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现页面置换，操作系统需要通过某些指标来决定到底换出哪个页面。有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。

## 页表的变化

基本分页存储管理的页表称为基本页表, 请求分页存储管理的页表称为请求页表。

请求页表项增加了四个字段:

- 状态位: 是否已调入内存
- 访问字段(访问位): 可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考
- 修改位: 页面调入内存后是否被修改过
- 外存地址: 页面在外存中的存放位置

只有遇到写操作才需要更新修改位。并且只需修改快表中的修改位，等到要将快表项删除时才需要将修改位的数据写回内存中的慢表。这样可以减少访存次数。

## 缺页中断处理

在请求分页系统中，每当要访问的页面不在内存时(对应页表项的块号为空)，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。

此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲的内存块，则为进程分配一个空闲块，将所缺页面装入该块，并更新页表中相应页表项的块号。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 一条指令在执行期间，可能产生多次缺页中断。(如:将逻辑地址 A 中的数据复制到逻辑地址 B，而 A 和 B 属于不同的页面，则有可能产生两次中断)

换入/换出页面都需要启动慢速的 I/O 操作，如果换入/换出太频繁，会有很大的开销。页面调入内存后，需要修改慢表，同时也需要将这个页表项复制到快表中。

## 地址变换过程

逻辑地址到物理地址的变换过程如下:

1. 从 PC 寄存器中取出逻辑地址
2. 从逻辑地址中拆分出页号和页内偏移量
3. 检查页号的合法性: 如果大于等于页表长度, 会抛出越界中断
4. 在快表中查询页号
   - 如果快表中存在页号
     1. 找出页号在快表中对应的内存块号
     2. 快表中有的页面一定是在内存中的, 所以不用检查对应页面是否调入内存。若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面
     3. 根据内存块号和页内偏移量拼接出物理地址
   - 如果快表中不存在页号
     1. 根据起始地址找到页表
     2. 找出页号在页表中对应的内存块号
     3. 若对应页面未调入内存(块号为空)，则产生缺页中断。之后由操作系统的缺页中断处理程序进行处理
     4. 把这条记录复制到快表中, 如果快表满了, 需要淘汰掉快表中的一部分页表项
     5. 根据内存块号和页内偏移量拼接出物理地址
