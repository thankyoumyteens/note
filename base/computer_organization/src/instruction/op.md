# 操作码

## 定长操作码

定长操作码是指在指令集中，所有的操作码都具有相同的长度。

- 优点: 计算机的硬件设计简单, 指令译码和执行速度更快
- 缺点: 当指令数量增多、指令字单独为操作码划分出固定的多位后, 留给表示操作数的位数就会不够
- 适用环境: 字长较长的计算机, 比如 32 位或以上

## 变长操作码

变长操作码允许操作码具有不同的长度。

- 优点: 在比较短的指令字中, 既能表示出比较多的指令条数, 又能尽量满足操作数位数的要求
- 缺点: 计算机的硬件设计复杂, 指令译码和执行速度较慢
- 适用环境: 字长较短的计算机, 比如 16 位或以下

### 扩展操作码

假设一个 16 位的三地址指令的变长操作码为: 1111 XXXXXXXXXXXX。二地址指令的操作码为: 1111 0000XXXXXXXX。在这两条指令中, 短的操作码(三地址指令的)成了长的操作码(二地址指令)的一个前缀(1111), 这就会导致计算机无法区分两条指令。

解决方法:

1. 三地址指令操作码的取值范围(共 15 条): 从 0000 到 1110, 留下 1111 作为扩展窗口和后边的 4 位二进制一起组成一个 8 位的二地址指令操作码
2. 二地址指令操作码的取值范围(共 15 条): 从 1111 0000 到 1111 1110, 留下 1111 1111 作为扩展窗口和后边的 4 位二进制一起组成一个 12 位的一地址指令操作码
3. 一地址指令操作码的取值范围(共 15 条): 从 1111 1111 0000 到 1111 1111 1110, 留下 1111 1111 1111 作为扩展窗口和后边的 4 位二进制一起组成一个 16 位的零地址指令操作码
4. 零地址指令操作码的取值范围(共 16 条): 从 1111 1111 1111 0000 到 1111 1111 1111 1111, 它不用再保留扩展窗口

上例中的扩展窗口保留了 1 位, 但其实可以按实际情况保留多位。

### 例题

假设指令字长为 16 位, 操作数地址码 6 位, 指令有零地址、一地址和二地址 3 种格式。

1、地址码固定, 若零地址指令有 M 种, 一地址指令有 N 种, 则二地址指令最多有多少种?

对于二地址指令，有两个地址码各占用 6 位，共占用 6 + 6 = 12 位，剩余 16 − 12 = 4 位可以用来表示操作码。因此，二地址指令的操作码可以有 2<sup>4</sup> = 16 种不同的编码方式。

二地址指令最多 16 - M - N 种。

2、采用扩展操作码技术, 二地址指令最多有多少种?

二地址指令操作码的取值范围: 从 0000 到 1110。

所以最多 15 条。

3、采用扩展操作码技术, 若二地址指令有 P 条, 零地址指令有 Q 条, 则一地址指令最多有多少种?

设: 一地址指令最多有 R 种。

二地址指令的格式:

```
[操作码4位][地址码6位][地址码6位]
```

一地址指令的格式:

```
[操作码10位][地址码6位]
```

零地址指令的格式:

```
[操作码16位]
```

二地址指令最多 2<sup>4</sup> 条， 所以二地址指令的扩展窗口有 2<sup>4</sup> - P 个。

二地址指令的扩展窗口和后面的 6 位一起组成了一地址指令的操作码, 一地址指令的操作码范围有 (2<sup>4</sup> - P) × 2<sup>6</sup> 种, 一地址指令的扩展窗口有 (2<sup>4</sup> - P) × 2<sup>6</sup> - R 个。

同理, 零地址指令的操作码范围有 [(2<sup>4</sup> - P) × 2<sup>6</sup> - R] × 2<sup>6</sup> 种, 零地址指令不需要扩展窗口。又因为零地址指令有 Q 条, 所以 [(2<sup>4</sup> - P) × 2<sup>6</sup> - R] × 2<sup>6</sup> = Q。

解出 R = (2<sup>4</sup> - P) × 2<sup>6</sup> - Q × 2<sup>-6</sup>。
