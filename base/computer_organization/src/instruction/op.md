# 操作码

## 定长操作码

定长操作码是指在指令集中，所有的操作码都具有相同的长度。

- 优点: 计算机的硬件设计简单, 指令译码和执行速度更快
- 缺点: 当指令数量增多、指令字单独为操作码划分出固定的多位后, 留给表示操作数的位数就会不够
- 适用环境: 字长较长的计算机, 比如 32 位或以上

## 变长操作码

变长操作码允许操作码具有不同的长度。

- 优点: 在比较短的指令字中, 既能表示出比较多的指令条数, 又能尽量满足操作数位数的要求
- 缺点: 计算机的硬件设计复杂, 指令译码和执行速度较慢
- 适用环境: 字长较短的计算机, 比如 16 位或以下

### 扩展操作码

假设一个 16 位的三地址指令的变长操作码为: 1111 XXXXXXXXXXXX。二地址指令的操作码为: 1111 0000XXXXXXXX。在这两条指令中, 短的操作码(三地址指令的)成了长的操作码(二地址指令)的一个前缀(1111), 这就会导致计算机无法区分两条指令。

解决方法:

1. 三地址指令操作码的取值范围(共 15 条): 从 0000 到 1110, 留下 1111 作为扩展窗口和后边的 4 位二进制一起组成一个 8 位的二地址指令操作码
2. 二地址指令操作码的取值范围(共 15 条): 从 1111 0000 到 1111 1110, 留下 1111 1111 作为扩展窗口和后边的 4 位二进制一起组成一个 12 位的一地址指令操作码
3. 二地址指令操作码的取值范围(共 15 条): 从 1111 1111 0000 到 1111 1111 1110, 留下 1111 1111 1111 作为扩展窗口和后边的 4 位二进制一起组成一个 16 位的零地址指令操作码
4. 零地址指令操作码的取值范围(共 16 条): 从 1111 1111 1111 0000 到 1111 1111 1111 1111, 它不用再保留扩展窗口

上例中的扩展窗口保留了 1 位, 但其实可以按实际情况保留多位。
