# 乘法

## 原码乘法

设 \[A\]<sub>原</sub> = 0.1101, \[B\]<sub>原</sub> = 0.1011, 求 A × B:

```
  A × B
= A × 0.1011
= A × (0.1000 + 0.0000 + 0.0010 + 0.0001)
= A × 0.1000 + A × 0.0000 + A × 0.0010 + A × 0.0001
= 0.1(A + A × 0 + A × 0.01 + A × 0.001)
= 0.1(A + 0.1(A × 0 + A × 0.1 + A × 0.01))
= 0.1(A + 0.1(A × 0 + 0.1(A + A × 0.1)))
= 0.1(A + 0.1(A × 0 + 0.1(A + 0.1(A))))
```

乘 0.1 相当于右移 1 位, 所以乘法转换成了加法和移位, 并且中间结果只需要两个寄存器(ACC 和 MQ)就能保存, 步骤如下:

| B 由低到高 | 操作      | 结果(从 0 开始)          | 移出的值 |
| ---------- | --------- | ------------------------ | -------- |
| 1          | 加 1 × A  | 0 + 0.1101               | -        |
| -          | 右移 1 位 | 0.0110                   | 1        |
| 1          | 加 1 × A  | 0.0110 + 0.1101 = 1.0011 | 1        |
| -          | 右移 1 位 | 0.1001                   | 11       |
| 0          | 加 0 × A  | 0.1001 + 0 = 0.1001      | 1        |
| -          | 右移 1 位 | 0.0100                   | 111      |
| 1          | 加 1 × A  | 0.0100 + 0.1101 = 1.0001 | 111      |
| -          | 右移 1 位 | 0.1000                   | 1111     |

符号位单独处理: A 和 B 符号位进行异或操作得到 0。所以最终结果是 0.10001111。

### 计算机实现原码乘法的步骤

设 \[A\]<sub>原</sub> = 1.1110, \[B\]<sub>原</sub> = 1.1101, 求 A × B:

| 操作                                                 | ACC   | MQ   | X    |
| ---------------------------------------------------- | ----- | ---- | ---- |
| 判断符号位: 1 异或 1 为 0                            | -     | -    | -    |
| 把符号位 0 放入 ACC 的最高位, 其余 4 位初始化成 0    | 00000 | -    | -    |
| 把 A 的数值位放入 X                                  | 00000 | -    | 1110 |
| 把 B 的数值位放入 MQ                                 | 00000 | 1101 | 1110 |
| MQ 最右边的位是 1, 把 ACC 和 X 相加, 结果存到 ACC 中 | 01110 | 1101 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 00111 | 0110 | 1110 |
| MQ 最右边的位是 0, 不做操作                          | 00111 | 0110 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 00011 | 1011 | 1110 |
| MQ 最右边的位是 1, 把 ACC 和 X 相加, 结果存到 ACC 中 | 10001 | 1011 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 01000 | 1101 | 1110 |
| MQ 最右边的位是 1, 把 ACC 和 X 相加, 结果存到 ACC 中 | 10110 | 1101 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 01011 | 0110 | 1110 |
| 由于数值位是 4 位, 此时已经右移了 4 次, 运算结束     | 01011 | 0110 | 1110 |
| ACC 和 MQ 一起构成了运算结果: 0.10110110             | 01011 | 0110 | 1110 |

## 补码乘法

Booth 算法:

1. 数值位是 n 位的被乘数 A 和乘数 B 均以补码的形式参加运算, 运算结果是积的补码
2. 部分积和被乘数 A 采用双符号位, 乘数 B 采用单符号位
3. 初始部分积是 0, 开始前, 在乘数 B 的补码末尾添加一位附加位 B<sub>n+1</sub>, 初始值是 0
4. 根据 B<sub>n</sub> - B<sub>n+1</sub> 的值, 进行累加和右移操作, 右移时遵循补码移位规则:
   - B<sub>n</sub> - B<sub>n+1</sub> = 0: 直接右移
   - B<sub>n</sub> - B<sub>n+1</sub> = -1: 部分积加上 \[A\]<sub>补</sub> 后右移
   - B<sub>n</sub> - B<sub>n+1</sub> = 1: 部分积加上 \[-A\]<sub>补</sub> 后右移
5. 累加 n+1 次, 右移 n 次, 最后一次不右移

设 \[A\]<sub>补</sub> = 1.0101, \[B\]<sub>补</sub> = 1.0011, 求 \[A × B\]<sub>补</sub>:

| 操作                                                                                            | ACC    | MQ     | \[A\]<sub>补</sub> | \[-A\]<sub>补</sub> |
| ----------------------------------------------------------------------------------------------- | ------ | ------ | ------------------ | ------------------- |
| \[A\]<sub>补</sub> 采用双符号位                                                                 | -      | -      | 11.0101            | -                   |
| \[-A\]<sub>补</sub> 也采用双符号位                                                              | -      | -      | 11.0101            | 00.1011             |
| 初始部分积是 0, 也采用双符号位                                                                  | 000000 | -      | 11.0101            | 00.1011             |
| MQ 放入 B                                                                                       | 000000 | 10011  | 11.0101            | 00.1011             |
| 在乘数 B 的补码末尾添加一位附加位 0                                                             | 000000 | 100110 | 11.0101            | 00.1011             |
| MQ 的次低位减去最低位: 1 - 0 = 1, 所以 ACC 要加上 \[-A\]<sub>补</sub>: 000000 + 001011 = 001011 | 001011 | 100110 | 11.0101            | 00.1011             |
| 把 ACC 和 MQ 整体算数右移 1 位                                                                  | 000101 | 110011 | 11.0101            | 00.1011             |
| MQ 的次低位减去最低位: 1 - 1 = 0, 所以不做操作                                                  | 000101 | 110011 | 11.0101            | 00.1011             |
| 把 ACC 和 MQ 整体算数右移 1 位                                                                  | 000010 | 111001 | 11.0101            | 00.1011             |
| MQ 的次低位减去最低位: 0 - 1 = -1, 所以 ACC 要加上 \[A\]<sub>补</sub>: 000010 + 110101 = 110111 | 110111 | 111001 | 11.0101            | 00.1011             |
| 把 ACC 和 MQ 整体算数右移 1 位                                                                  | 111011 | 111100 | 11.0101            | 00.1011             |
| MQ 的次低位减去最低位: 0 - 0 = 0, 所以不做操作                                                  | 111011 | 111100 | 11.0101            | 00.1011             |
| 把 ACC 和 MQ 整体算数右移 1 位                                                                  | 111101 | 111110 | 11.0101            | 00.1011             |
| MQ 的次低位减去最低位: 1 - 0 = 1, 所以 ACC 要加上 \[-A\]<sub>补</sub>: 111101 + 001011 = 001000 | 001000 | 111110 | 11.0101            | 00.1011             |
| 已经进行了 4 次移位, 停止计算                                                                   | 001000 | 111110 | 11.0101            | 00.1011             |
| 把 MQ 后两位丢弃, 得到结果 00.10001111                                                          | 001000 | 1111   | 11.0101            | 00.1011             |
