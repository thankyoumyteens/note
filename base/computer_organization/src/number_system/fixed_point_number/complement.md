# 补码

真值是机器数所代表的实际的值, 机器数是真值在计算机中的表示。例如:

| 真值 | 真值 | 机器数 |
| ---- | ---- | ------ |
| +5   | +101 | 0101   |
| -5   | -101 | 1101   |

机器数的有符号数, 有原码、补码、反码、移码四种形式。

## 原码(Original Code)

计算机程序对正数和负数都要进行计算，所以需要一种表示方法来区分正数和负数。最显而易见的解决方案是增加一个独立的符号位，这种表示方法称为原码表示法。

原码是最直接的二进制表示方法。对于一个 n 位的整数：

- 如果数是正数，原码就是该数的二进制表示。比如 4 位系统中, +101 的原码是 0101, +0.101 的原码是 0.101
- 如果数是负数，原码就是在最高位(符号位)上设置为 1，其余位不变。比如 4 位系统中, -101 的原码是 1101, -0.101 的原码是 1.101

原码表示法有若干缺点:

1. 首先，符号位放在哪里不够明确(放右边还是放左边?)
2. 其次，对于符号和幅值表示的数进行计算需要额外的步骤来设置符号，因为计算结果不可能提前知道
3. 最后，一个单独的符号位意味着原码表示的数不但有正零(符号位为 0，其余位全为 0)而且还有负零(符号位为 1，其余位全为 0)，这将给粗心的程序员带来麻烦

这些缺点导致这种表示方法很快就被抛弃了。

## 反码(One's Complement)

- 如果数是正数，反码就是该数的二进制表示
- 如果数是负数，反码是符号位不变数值位取反

## 把减法转换成加法

以时钟为例, 如果要把 6:00 的时间调成 3:00, 有两种方法:

1. 逆时针旋转 3 小时: 6:00 - 3:00 = 3:00
2. 顺时针旋转 9 小时: 6:00 + 9:00 = 3:00

模:当我们说 `模 n` 时，我们指的是整数除以 n 后的余数。

在时钟的表盘上, 一共只有 12 个数字, 所以超出 12 的数字要对 12 取模: 6 + 9 = 15 mod 12 = 3。6 - 3 和 6 + 9 是等效的,而表盘上 -3 和 +9 的距离正好是 12, 如果要计算 6 - 3, 则可以用以下步骤:

1. 把 -3 对应的数字找到: 12 - |-3| = 9
2. 把算式中的 -3 替换成 9
3. 这样就减法转换成了加法: 6 + 9 = 15
4. 由于 15 超过了 12, 所以需要模 12
5. 15 mod 12 = 3

同理, 二进制数 0101 - 0001 的计算方法:

1. 由于是 4 位二进制数, 所以要对 2<sup>4</sup> = 16 = 10000 取模
2. 找到 -0001 对应的数, 那么 0001 对应的数为: 10000 - |-0001| = 1111
3. 把算式中的 -0001 替换成 +1111
4. 这样就减法转换成了加法: 0101 + 1111 = 10100
5. 由于 10100 超过了 10000, 所以需要模 10000
6. 10100 mod 10000 = 0100

把 1111 称为 -0001 的补码。

## 补码(Two's Complement)

补码主要用于表示带符号的整数。补码可以简化硬件设计，使得加法和减法可以使用相同的电路来实现，同时还可以避免正零和负零的区别。

- 正数的补码就是其本身的二进制表示。例如，+5 在 4 位系统中表示为 0101
- 负数的补码表示: 在 n 位系统中, 使用 2<sup>n</sup> 减去该负数的绝对值。例如, 在 4 位系统中, -5 的补码为 2<sup>4</sup> = 10000 - |-0101| = 1011

在补码中，零表示成符号位为 0，其余位全为 0。例如，8 位二进制数的零表示为 00000000。而 10000000 则表示最小的负数。由于负数没有负零, 所以在补码中, 负数比正数多了一个(-2<sup>n</sup> ~ 2<sup>n</sup> - 1)。

## 原码转补码

1. **确定位数**：首先确定要使用的二进制位数，例如 8 位或 16 位
2. **确定数的符号**：如果数是正数，那么其补码和原码相同。
3. **如果是负数**：
   - 将该原码符号位不变, 数值位取反(即每个比特位，0 变 1，1 变 0)
   - 将取反后的结果加 1

假设使用 8 位二进制数来表示一个整数：

1. **正数的转换**：
   - 例如，+5 的原码是 00000101
   - +5 的补码也是 00000101
2. **负数的转换**：
   - 例如，-5 的原码是 10000101
   - 符号位不变, 数值位取反得到: 11111010
   - 加 1 得到: 11111011
   - 因此，-5 的补码是 11111011

## 补码转原码

1. **确定位数**：同样需要确定位数
2. **确定数的符号**：如果最高位是 0，则该数是正数，直接读取即可
3. **如果是负数**：
   - 将该补码符号位不变, 数值位取反(即每个比特位，0 变 1，1 变 0)
   - 将取反后的结果加 1

假设使用 8 位二进制数来表示一个整数：

1. **正数的转换**：
   - 例如，00000101 的补码是其本身
   - 因此，00000101 的原码也是 00000101
2. **负数的转换**：
   - 例如，补码 11111011 表示的是 -5
   - 符号位不变, 数值位取反得到: 10000100
   - 加 1 得到: 10000101
