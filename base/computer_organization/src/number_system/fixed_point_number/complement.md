# 补码

真值是机器数所代表的实际的值, 机器数是真值在计算机中的表示。例如:

| 真值 | 真值 | 机器数 |
| ---- | ---- | ------ |
| +5   | +101 | 0101   |
| -5   | -101 | 1101   |

机器数的有符号数, 有原码、补码、反码、移码四种形式。

## 定点数

定点小数:

```
[符号][小数点][数值部分]
```

定点整数:

```
[符号][数值部分][小数点]
```

## 原码（Original Code）

原码是最直接的二进制表示方法。对于一个 n 位的整数：

- 如果数是正数，原码就是该数的二进制表示。比如 4 位系统中, +101 的原码是 0101, +0.101 的原码是 0.101
- 如果数是负数，原码就是在最高位（符号位）上设置为 1，其余位不变。比如 4 位系统中, -101 的原码是 1101, -0.101 的原码是 1.101

## 反码（One's Complement）

- 如果数是正数，反码就是该数的二进制表示
- 如果数是负数，反码是符号位不变数值位取反

## 把减法转换成加法

以时钟为例, 如果要把 6:00 的时间调成 3:00, 有两种方法:

1. 逆时针旋转 3 小时: 6:00 - 3:00 = 3:00
2. 顺时针旋转 9 小时: 6:00 + 9:00 = 3:00

模:当我们说 `模 n` 时，我们指的是整数除以 n 后的余数。

在时钟的表盘上, 一共只有 12 个数字, 所以超出 12 的数字要对 12 取模: 6 + 9 = 15 mod 12 = 3。6 - 3 和 6 + 9 是等效的,而表盘上 -3 和 +9 的距离正好是 12, 如果要计算 6 - 3, 则可以用以下步骤:

1. 把 -3 对应的数字找到: 12 - |-3| = 9
2. 把算式中的 -3 替换成 9
3. 这样就减法转换成了加法: 6 + 9 = 15
4. 由于 15 超过了 12, 所以需要模 12
5. 15 mod 12 = 3

同理, 二进制数 0101 - 0001 的计算方法:

1. 由于是 4 位二进制数, 所以要对 2<sup>4</sup> = 16 = 10000 取模
2. 找到 -0001 对应的数, 那么 0001 对应的数为: 10000 - |-0001| = 1111
3. 把算式中的 -0001 替换成 +1111
4. 这样就减法转换成了加法: 0101 + 1111 = 10100
5. 由于 10100 超过了 10000, 所以需要模 10000
6. 10100 mod 10000 = 0100

把 1111 称为 -0001 的补码。

## 补码（Two's Complement）

补码主要用于表示带符号的整数。补码可以简化硬件设计，使得加法和减法可以使用相同的电路来实现，同时还可以避免正零和负零的区别。

- 正数的补码就是其本身的二进制表示。例如，+5 在 4 位系统中表示为 0101
- 负数的补码表示: 在 n 位系统中, 使用 2<sup>n</sup> 减去该负数的绝对值。例如, 在 4 位系统中, -5 的补码为 2<sup>4</sup> = 10000 - |-0101| = 1011

## 原码转补码

1. **确定位数**：首先确定要使用的二进制位数，例如 8 位或 16 位
2. **确定数的符号**：如果数是正数，那么其补码和原码相同。
3. **如果是负数**：
   - 将该原码符号位不变, 数值位取反（即每个比特位，0 变 1，1 变 0）
   - 将取反后的结果加 1

假设使用 8 位二进制数来表示一个整数：

1. **正数的转换**：
   - 例如，+5 的原码是 00000101
   - +5 的补码也是 00000101
2. **负数的转换**：
   - 例如，-5 的原码是 10000101
   - 符号位不变, 数值位取反得到: 11111010
   - 加 1 得到: 11111011
   - 因此，-5 的补码是 11111011

## 补码转原码

1. **确定位数**：同样需要确定位数
2. **确定数的符号**：如果最高位是 0，则该数是正数，直接读取即可
3. **如果是负数**：
   - 将该补码符号位不变, 数值位取反（即每个比特位，0 变 1，1 变 0）
   - 将取反后的结果加 1

假设使用 8 位二进制数来表示一个整数：

1. **正数的转换**：
   - 例如，00000101 的补码是其本身
   - 因此，00000101 的原码也是 00000101
2. **负数的转换**：
   - 例如，补码 11111011 表示的是 -5
   - 符号位不变, 数值位取反得到: 10000100
   - 加 1 得到: 10000101

## 一个数的补码转换为其相反数的补码

对这个数取反加一

## 补码的加减

- 真值相加的补码等于真值的补码相加: \[A + B\]<sub>补</sub> = \[A\]<sub>补</sub> + \[B\]<sub>补</sub>。对于整数, 结果要对 2<sup>n+1</sup>取模。对于小数, 结果要对 2 取模。由于在计算机中, 机器字长为 n 位, 超出 n 位的部分会被丢弃, 所以相当于自动作了取模操作
- 真值相减的补码等于真值的补码加上真值负数的补码: \[A - B\]<sub>补</sub> = \[A\]<sub>补</sub> + \[-B\]<sub>补</sub>。对于整数, 结果要对 2<sup>n+1</sup>取模。对于小数, 结果要对 2 取模。由于在计算机中, 机器字长为 n 位, 超出 n 位的部分会被丢弃, 所以相当于自动作了取模操作

在补码的加减中, 符号位也直接参与了计算, 没有作特殊处理。

例题 1: 计算 0.1011 - 0.0101:

1. 算出 0.1011 和 -0.0101 两个数的补码: 0.1011 和 1.1011
2. 直接相加得到结果: 0.1011 + 1.1011 = 0.0110
3. 0.0110 也是补码

例题 2: 机器字长为 8 位, 计算 1111 - 11000:

1. 算出 1111 和 -11000 两个数的补码: 00001111 和 11101000
2. 直接相加得到结果: 00001111 + 11101000 = 11110111
3. 11110111 也是补码, 它的原码是 10001001
