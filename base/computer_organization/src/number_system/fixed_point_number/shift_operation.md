# 移位运算

对于补码:

1. **左移运算（Left Shift, <<）**：
   - 左移运算将所有的位向左移动指定的位数，低位端空出的位置通常用 0 来填充
   - 左移运算相当于乘以 2 的幂次方。例如，将一个数左移 n 位，就等于该数乘以 2<sup>n</sup>
   - 例如，`0010`（2 的二进制表示）左移 1 位变为`0100`（4 的二进制表示）
2. **逻辑右移运算（Logical Right Shift, >>）**：
   - 逻辑右移运算将所有的位向右移动指定的位数，高位端空出的位置通常用 0 来填充
   - 逻辑右移相当于除以 2 的幂次方。例如，将一个数右移 n 位，就等于该数除以 2<sup>n</sup>（向下取整）
   - 例如，`0100`（4 的二进制表示）逻辑右移 1 位变为`0010`（2 的二进制表示）
3. **算术右移运算（Arithmetic Right Shift, >>）**：
   - 算术右移与逻辑右移类似，但它保留了符号位（最高位）。对于正数，高位填充 0；对于负数，高位填充 1
   - 算术右移同样相当于除以 2 的幂次方
   - 例如，`1110`（-2 的二进制表示，假设为 4 位补码）算术右移 1 位变为`1111`（-1 的二进制表示）

对于反码, 无论左移还是右移, 空出的位置都用 1 来填充。

## 原码乘法

设 \[A\]<sub>原</sub> = 0.1101, \[B\]<sub>原</sub> = 0.1011, 求 A × B:

```
  A × B
= A × 0.1011
= A × (0.1000 + 0.0000 + 0.0010 + 0.0001)
= A × 0.1000 + A × 0.0000 + A × 0.0010 + A × 0.0001
= 0.1(A + A × 0 + A × 0.01 + A × 0.001)
= 0.1(A + 0.1(A × 0 + A × 0.1 + A × 0.01))
= 0.1(A + 0.1(A × 0 + 0.1(A + A × 0.1)))
= 0.1(A + 0.1(A × 0 + 0.1(A + 0.1(A))))
```

乘 0.1 相当于右移 1 位, 所以乘法转换成了加法和移位, 并且中间结果只需要两个寄存器(ACC 和 MQ)就能保存, 步骤如下:

| B 由低到高 | 操作      | 结果(从 0 开始)          | 移出的值 |
| ---------- | --------- | ------------------------ | -------- |
| 1          | 加 1 × A  | 0 + 0.1101               | -        |
| -          | 右移 1 位 | 0.0110                   | 1        |
| 1          | 加 1 × A  | 0.0110 + 0.1101 = 1.0011 | 1        |
| -          | 右移 1 位 | 0.1001                   | 11       |
| 0          | 加 0 × A  | 0.1001 + 0 = 0.1001      | 1        |
| -          | 右移 1 位 | 0.0100                   | 111      |
| 1          | 加 1 × A  | 0.0100 + 0.1101 = 1.0001 | 111      |
| -          | 右移 1 位 | 0.1000                   | 1111     |

符号位单独处理: A 和 B 符号位进行异或操作得到 0。所以最终结果是 0.10001111。

### 计算机实现原码乘法的步骤

设 \[A\]<sub>原</sub> = 1.1110, \[B\]<sub>原</sub> = 1.1101, 求 A × B:

| 操作                                                 | ACC   | MQ   | X    |
| ---------------------------------------------------- | ----- | ---- | ---- |
| 判断符号位: 1 异或 1 为 0                            | -     | -    | -    |
| 把符号位 0 放入 ACC 的最高位, 其余 4 位初始化成 0    | 00000 | -    | -    |
| 把 A 的数值位放入 X                                  | 00000 | -    | 1110 |
| 把 B 的数值位放入 MQ                                 | 00000 | 1101 | 1110 |
| MQ 最右边的位是 1, 把 ACC 和 X 相加, 结果存到 ACC 中 | 01110 | 1101 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 00111 | 0110 | 1110 |
| MQ 最右边的位是 0, 不做操作                          | 00111 | 0110 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 00011 | 1011 | 1110 |
| MQ 最右边的位是 1, 把 ACC 和 X 相加, 结果存到 ACC 中 | 10001 | 1011 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 01000 | 1101 | 1110 |
| MQ 最右边的位是 1, 把 ACC 和 X 相加, 结果存到 ACC 中 | 10110 | 1101 | 1110 |
| 把 ACC 和 MQ 整体右移 1 位                           | 01011 | 0110 | 1110 |
| 由于数值位是 4 位, 此时已经右移了 4 次, 运算结束     | 01011 | 0110 | 1110 |
| ACC 和 MQ 一起构成了运算结果: 0.10110110             | 01011 | 0110 | 1110 |

## 补码乘法
