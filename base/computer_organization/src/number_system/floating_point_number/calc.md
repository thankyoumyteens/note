# 浮点数加减

已知十进制数 X=-5/256, Y=59/1024, 按机器补码的浮点运算规则计算 X-Y, 结果用二进制表示。浮点数格式: 阶符取 2 位, 阶码取 3 位, 数符取 2 位, 尾数取 9 位。

### 1. 转成二进制形式

5 转成二进制是 101, 1/256 转成 2 的 n 次方是 2<sup>-8</sup>

X = -101 × 2<sup>-8</sup> = -0.101 × 2<sup>-5</sup>

X = -0.101 × 2<sup>-101</sup>

59 转成二进制是 111011, 1/1024 转成 2 的 n 次方是 2<sup>-10</sup>

Y = +111011 × 2<sup>-10</sup> = +0.111011 × 2<sup>-4</sup>

Y = +0.111011 × 2<sup>-100</sup>

### 2. 把尾数和阶码转成补码形式

以 X 为例:

- -0.101 转成补码是 1.011, 数符取 2 位, 尾数取 9 位 得到 11.011000000
- -101 转成补码是 1011, 阶符取 2 位, 阶码取 3 位 得到 11011

最终结果:

| 值  | 阶码  | 尾数         |
| --- | ----- | ------------ |
| X   | 11011 | 11.011000000 |
| Y   | 11100 | 00.111011000 |

### 3. 对阶

小阶向大阶看齐

1. 判断谁的阶更小: 把两个数的阶码相减 -> 11011 - 11100 = 11011 + 00100 = 11111, 换成十进制是 -1(符号位是两位), 说明 X 的阶数比 Y 小 1
2. 把 X 的尾数右移 1 位, 阶码加 1: 阶码 -> 11100, 尾数 -> 11.101100000
3. 尾数相减: 11.011000000 - 00.111011000 = 11.011000000 + 11.000101000 = 110.110001000, 超长了, 舍去最高位得到 10.110001000

最终结果:

| 值  | 阶码  | 尾数         |
| --- | ----- | ------------ |
| X-Y | 11100 | 10.110001000 |

### 4. 规格化

由于得到的结果符号位不同, 说明发生了溢出, 需要规格化, 把 10.110001000 算数右移一位得到 11.011000100。因为尾数右移了一位, 所以阶码需要加一: 11101

最终结果:

| 值  | 阶码  | 尾数         |
| --- | ----- | ------------ |
| X-Y | 11101 | 11.011000100 |

### 5. 舍入

规格化时, 尾数最低位丢掉的是 0, 所以不需要舍入。

### 6. 阶码溢出判断

规格化后, 阶码是 11101, 最高两位是符号位, 相同说明没有溢出。

## 舍入的方法

0 舍 1 入法: 类似于十进制数运算中的四舍五入，即在尾数右移时；被移去的最高数值位为 0，则舍去；被移去的最高数值位为 1， 则在尾数的末位加 1。这样做可能会使尾数又溢出，此时需再做一次右规。

恒置 1 法: 尾数右移时，不论丢掉的最高数值位是 1 还是 0, 都使右移后的尾数末位恒置 1。这种方法同样有使尾数变大和变小的两种可能。

## 0 舍 1 入法

1. 假设加/减后的结果为 11100 10.110001011
2. 符号位不同, 需要规格化(右规), 尾数算数右移一位 11.011000101, 阶码加一 11101
3. 尾数被移出去的是 1, 根据 0 舍 1 入, 以把尾数加一 11.011000101 + 1 = 11.011000110
4. 判断尾数的符号位, 相同则结束, 不相同则继续右规

## 恒置 1 法

1. 假设规格化后的结果是 11101 11.011000101
2. 恒置 1 法直接把尾数最后一位设为 1: 11.011000101
