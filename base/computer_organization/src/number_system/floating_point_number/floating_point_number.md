# 浮点数

浮点数的表示: N = M × r<sup>E</sup>, 比如: 1.23 × 10<sup>3</sup>

- r 是基数
- E 是阶码, 反映浮点数的范围和小数点的实际位置
- M 是尾数, 反映浮点数的精度

浮点数在计算机中的表示:

```
[阶码的符号部分][阶码的数值部分][尾数的符号部分][尾数的数值部分]
```

## 规格化浮点数

规格化浮点数: 尾数最高数值位是有效值的浮点数。

- \[+0.101101\]<sub>补</sub> = 0.101101
- \[-0.101101\]<sub>补</sub> = 1.010011

规格化后浮点数的表示形式：

- 原码: X.1XXX...
- 补码:
  - 正数: 0.1XXX...
  - 负数: 1.0XXX...

## 浮点数加减

步骤:

1. 对阶
2. 尾数求和
3. 结果规格化
   - 左规: 当尾数出现 00.0XXX... 或 11.1XXX... 时, 需要把尾数左移 1 位, 阶码减 1
   - 右规: 当尾数出现 10.XXX... 或 01.XXX... 时, 需要把尾数右移 1 位, 阶码加 1
4. 舍入
   - 0 舍 1 入法: 移出的是 1 则要把尾数加 1, 移出的是 0 则直接舍弃。0 舍 1 入法后可能会需要右规
   - 恒置 1 法: 把尾数最后一位设为 1
5. 溢出判断: 对于浮点数, 尾数溢出可以通过左规和右规处理, 阶码溢出才是真正的溢出。阶码的符号位是 01 表示上溢, 10 表示下溢

设计器字长是 16 位, 其中阶码 6 位, 尾数 10 位, 阶码和尾数都采取双符号位。计算 \[A - B\]<sub>补</sub>, 其中 A=125, B=-18.125

先把 A 和 B 化成二进制, 并规格化成浮点数:

- A = 0.11111010 × 2<sup>0111</sup>
- B = -0.10010001 × 2<sup>0101</sup>

由于 A 和 B 的阶码不同, 所以需要对阶:

1. 把阶码用补码表示:
   - \[A<sub>阶</sub>\]<sub>补</sub> = 000111
   - \[B<sub>阶</sub>\]<sub>补</sub> = 000101
2. 用大的阶码减去小的阶码: \[A<sub>阶</sub>\]<sub>补</sub> - \[B<sub>阶</sub>\]<sub>补</sub> = \[A<sub>阶</sub>\]<sub>补</sub> + \[-B<sub>阶</sub>\]<sub>补</sub> = 000111 + 111011 = 000010 = 2
3. 所以需要把 B 的补码做如下调整: 尾数算数右移 2 位, 阶码换成 000111

A 和 B 的补码表示:

- \[A\]<sub>补</sub> = 00 0111 00 11111010。前两位是阶码的符号部分, 随后四位是阶码的数值部分, 然后的两位是尾数的符号部分, 剩下的是尾数的数值部分
- \[B\]<sub>补</sub> = 00 0101 11 01101111。B 的补码需要按上面调整, 最终结果是: 00 0111 11 11011011
- 由于要计算减法, 所以要算出 \[-B\]<sub>补</sub> = 00 0111 00 00100101

开始计算:

1. 尾数求和: 把 \[A\]<sub>补</sub> 和 \[-B\]<sub>补</sub> 的尾数相加: 00 11111010 + 00 00100101 = 01 00011111
2. 结果规格化: 结果进位到了符号位, 再需要右移 1 位(右规): 01 00011111 -> 00 10001111。然后把把阶码加 1: 00 0111 + 1 = 00 1000
3. 舍入: 如果使用 0 舍 1 入法, 移出的是 1 就要把尾数加 1: 00 10001111 + 1 = 00 10010000
4. 如果尾数加 1 后符号位还有溢出, 就需要继续重复 2 和 3 的步骤
5. 最终结果: 00 1000 00 10010000
