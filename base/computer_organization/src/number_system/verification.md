# 校验码

原理: 增加冗余码。

## 奇偶校验码

增加 1 位冗余码。

奇校验码: 整个数据中 1 的个数是奇数。比如: 原始数据是 `1011`, 需要增加 1 位校验码凑成奇数个 1, 所以增加 `0` 变成 `10110`, 接收端收到的数据是 `11110`, 其中 1 的个数为偶数, 说明数据出错了。

偶校验码: 整个数据中 1 的个数是偶数。比如: 原始数据是 `1011`, 需要增加 1 位校验码凑成偶数个 1, 所以增加 `1` 变成 `10111`, 接收端收到的数据是 `11111`, 其中 1 的个数为奇数, 说明数据出错了。

问题: 原始数据是 `1011`, 如果奇校验时, 收到的数据是 `11111`, 虽然数据出错了, 但 1 的个数为奇数, 无法判断出错。

缺点:

1. **只能检测奇数个位错误**：奇偶校验只能检测到奇数个位发生翻转的情况。如果数据中有偶数个位同时出错, 那么这种类型的校验将无法检测到错误
2. **不能纠正错误**：奇偶校验仅能用来检测错误的存在, 但不能指出具体哪个位出错了, 也不能自行修正这些错误

## 海明码

它能检测并更正一个比特的错误。若有两个比特出错, 则只能检测, 不能更正。

设: 数据有 m 位, 校验码有 p 位, 则校验码一共有 2<sup>p</sup> 种取值。

如果想通过校验码指出任何一位上发生的错误, 那么必须满足: 2<sup>p</sup> - 1 ≥ m + p。减 1 是去掉正确的情况。

比如: 原始数据是 `1010`, 则 m 是 4, 所以 p 最小是 3, m + p = 7。校验码要放在 2<sup>n</sup> 的位置上, n ≤ 7。

| 1             | 2             | 3   | 4             | 5   | 6   | 7   |
| ------------- | ------------- | --- | ------------- | --- | --- | --- |
| p<sub>1</sub> | p<sub>2</sub> | 1   | p<sub>3</sub> | 0   | 1   | 0   |

接下来要给 p<sub>1</sub>、 p<sub>2</sub>、p<sub>3</sub> 分组, 首先列出上面的索引 1~7 的二进制数

| 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- |
| 001 | 010 | 011 | 100 | 101 | 110 | 111 |

- p<sub>1</sub> 的索引 1 的二进制是 `001`, 二进制中 1 在最后一位, 所以二进制中最后一位是 1 的其它索引 3、5、7 就和它一组
- p<sub>2</sub> 的索引 2 的二进制是 `010`, 二进制中 1 在第二位, 所以二进制中第二位是 1 的其它索引 3、6、7 就和它一组
- p<sub>3</sub> 的索引 4 的二进制是 `100`, 二进制中 1 在第一位, 所以二进制中第一位是 1 的其它索引 5、6、7 就和它一组

把索引替换为具体的值:

- p<sub>1</sub> 1 0 0
- p<sub>2</sub> 1 1 0
- p<sub>3</sub> 0 1 0

用奇偶校验的方法求出 p<sub>1</sub>、 p<sub>2</sub>、p<sub>3</sub> 的值, 以奇校验为例, 即每一组都要有奇数个 1:

- p<sub>1</sub> = 0
- p<sub>2</sub> = 1
- p<sub>3</sub> = 0

则奇校验规则下的海明码为: `0110010`

| 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- |
| 0   | 1   | 1   | 0   | 0   | 1   | 0   |

### 接收端验证

假设接收端接收到的是: `0110110`, 首先按上面的方法分组(索引 1、2、4 的位置是 p<sub>1</sub>、 p<sub>2</sub>、p<sub>3</sub>):

- 0 1 1 0
- 1 1 1 0
- 0 1 1 0

在每组前面加上纠错位:

- e<sub>1</sub> 0 1 1 0
- e<sub>2</sub> 1 1 1 0
- e<sub>3</sub> 0 1 1 0

用奇偶校验的方法求出 e<sub>1</sub>、 e<sub>2</sub>、e<sub>3</sub> 的值, 因为发送端是奇校验, 所以接收端也要用奇校验, 即每一组都要有奇数个 1:

- e<sub>1</sub> = 1
- e<sub>2</sub> = 0
- e<sub>3</sub> = 1

把它们倒序排列:

| e<sub>3</sub> | e<sub>2</sub> | e<sub>1</sub> |
| ------------- | ------------- | ------------- |
| 1             | 0             | 1             |

`101` 的十进制是 5, 表示第 5 位出错了。把第 5 位取反就得到了正确的数据。

### 码距

码距, 也称为海明距离(Hamming Distance), 同一个编码规则下的两个码之间对应位置上不同的二进制数的个数。

例如, 某个个编码规则下的两个 8 位的二进制字符串：

- 字符串 A: 10101010
- 字符串 B: 10010010

比较每一位：

- 第 1 位相同 (1 vs 1)
- 第 2 位相同 (0 vs 0)
- 第 3 位不同 (1 vs 0)
- 第 4 位不同 (0 vs 1)
- 第 5 位相同 (1 vs 0)
- 第 6 位相同 (0 vs 0)
- 第 7 位不同 (1 vs 0)
- 第 8 位相同 (0 vs 0)

总共有 3 个不同的位, 因此这两个字符串之间的码距是 3。

某种编码的码距位其中任意两个码之间的最小码距。比一组编码从 `0000` 到 `1111`, 那么它们之间最大的码距是 4 (`0000` 和 `1111`), 最小的码距是 1 (比如 `0000` 和 `0001`), 则这种编码的码距就是 1。

纠错理论: 编码的码距 - 1 = 检错位数 + 纠错位数。比如码距为 1, 则它的 检错位数 + 纠错位数 = 0, 这种编码就不具备纠错能力。

上面的海明码能检错 1 位, 纠错 1 位, 带入得到该海明码的码距为 3。对于能检错 2 位, 纠错 1 位的海明码, 带入得到海明码的码距为 4。

## 循环冗余校验码
