# 冒泡排序

1. 相邻元素比较：从数组的第一个元素开始，依次比较相邻的两个元素
2. 交换位置：如果前一个元素大于后一个元素（升序排序），就交换它们的位置
3. 一轮结束：每完成一轮比较，最大的元素会 “浮” 到数组的末尾（如同水中的气泡上升）
4. 重复操作：忽略已经排好序的末尾元素，对剩余元素重复上述过程，直到所有元素有序

以数组 `[3, 1, 4, 2]` 为例：

1. 第 1 轮：
   1. 比较 3 和 1 → 交换 → `[1, 3, 4, 2]`
   2. 比较 3 和 4 → 不交换 → `[1, 3, 4, 2]`
   3. 比较 4 和 2 → 交换 → `[1, 3, 2, 4]`
   4. 结果：最大元素 4 已排到末尾。
2. 第 2 轮（忽略最后一个元素 4）：
   1. 比较 1 和 3 → 不交换 → `[1, 3, 2, 4]`
   2. 比较 3 和 2 → 交换 → `[1, 2, 3, 4]`
   3. 结果：第二大元素 3 排到倒数第二位。
3. 第 3 轮（忽略最后两个元素）：
   1. 比较 1 和 2 → 不交换 → `[1, 2, 3, 4]`
   2. 所有元素有序，排序结束。

```java
public class BubbleSort {

    public static void sort(int[] arr) {
        int n = arr.length;
        // 外层循环控制需要进行多少轮比较
        for (int i = 0; i < n - 1; i++) {
            // 内层循环控制每轮比较的元素范围
            // 每轮结束后，最大的元素已"浮"到末尾，下一轮可减少一次比较
            // 经过i轮循环后, 就会有i个元素已经浮到末尾, 所以减i
            for (int j = 0; j < n - 1 - i; j++) {
                // 相邻元素比较，前一个大于后一个则交换
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```
