# 微服务

微服务的特点: 

- 单一职责: 微服务中每一个服务都对应唯一的业务能力, 做到单一职责
- 微: 微服务的服务拆分粒度很小, 例如一个用户管理就可以作为一个服务。每个服务虽小, 但“五脏俱全”。
- 面向服务: 面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现, 做到与平台和语言无关, 也不限定用什么技术实现, 只要提供Rest的接口即可。
- 自治: 自治是说服务间互相独立, 互不干扰
- 团队独立: 每个服务都是一个独立的开发团队, 人数不能过多。
- 技术独立: 因为是面向服务, 提供Rest接口, 使用什么技术没有别人干涉
- 前后端分离: 采用前后端分离开发, 提供统一Rest接口, 后端不用再为PC、移动段开发不同接口
- 数据库分离: 每个服务都使用自己的数据源
- 部署独立, 服务间虽然有调用, 但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件, 可复用, 可替换, 降低耦合, 易维护

# 服务间的远程调用方式

常见的远程调用方式有以下几种: 

- RPC: Remote Produce Call远程过程调用, 类似的还有RMI。自定义数据格式, 基于原生TCP通信, 速度快, 效率高。早期的webservice, 现在热门的dubbo, 都是RPC的典型
- Http: http其实是一种网络传输协议, 基于TCP, 规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。

## RPC

RPC, 即 Remote Procedure Call(远程过程调用), 是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序, 而程序员无需额外地为这个交互作用编程。说得通俗一点就是: A计算机提供一个服务, B计算机可以像调用本地服务那样调用A计算机的服务。

通过上面的概念, 我们可以知道, 实现RPC主要是做到两点:  

- 实现远程调用其他计算机的服务: 现在比较流行的RPC框架, 都会采用TCP作为底层传输协议
- 像调用本地服务一样调用远程服务: 如果仅仅是远程调用, 还不算是RPC, 因为RPC强调的是过程调用, 调用的过程对用户而言是应该是透明的, 用户不应该关心调用的细节, 可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装

# Spring的RestTemplate

Spring提供了一个RestTemplate模板工具类, 对基于Http的客户端进行了封装, 并且实现了对象与json的序列化和反序列化。RestTemplate并没有限定Http的客户端类型, 而是进行了抽象, 目前常用的3种都有支持: 

- HttpClient
- OkHttp
- JDK原生的URLConnection(默认的)

首先在项目中注册一个`RestTemplate`对象, 可以在启动类位置注册: 
```
@SpringBootApplication
public class HttpDemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(HttpDemoApplication.class, args);
    }

  @Bean
  public RestTemplate restTemplate() {
    return new RestTemplate();
  }
}
```

在测试类中直接`@Autowired`注入: 
```
@RunWith(SpringRunner.class)
@SpringBootTest(classes = HttpDemoApplication.class)
public class HttpDemoApplicationTests {

	@Autowired
	private RestTemplate restTemplate;

	@Test
	public void httpGet() {
		User user = this.restTemplate.getForObject(url, User.class);
		System.out.println(user);
	}
}
```

# SpringCloud

SpringCloud将现在非常流行的一些技术整合到一起, 实现了诸如: 配置管理, 服务发现, 智能路由, 负载均衡, 熔断器, 控制总线, 集群状态等等功能。其主要涉及的组件包括: 

- Eureka: 注册中心
- Zuul: 服务网关
- Ribbon: 负载均衡
- Feign: 服务调用
- Hystrix: 熔断器

# 微服务场景模拟

首先, 我们需要模拟一个服务调用的场景。方便后面学习微服务架构

## 服务提供者

我们新建一个项目, 对外提供查询用户的服务。访问接口: http://localhost:8081/user/7

### Spring脚手架创建工程

借助于Spring提供的快速搭建工具搭建

依赖已经全部自动引入: 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
   http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.demo</groupId>
	<artifactId>user-service-demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>user-service-demo</name>
	<description>Demo project for Spring Boot</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.0.1.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<project.build.sourceEncoding>
      UTF-8
    </project.build.sourceEncoding>
		<project.reporting.outputEncoding>
      UTF-8
    </project.reporting.outputEncoding>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.2</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
```

当然, 因为要使用通用mapper, 所以我们需要手动加一条依赖: 
```xml
<dependency>
    <groupId>tk.mybatis</groupId>
    <artifactId>mapper-spring-boot-starter</artifactId>
    <version>2.0.2</version>
</dependency>
```

### 编写代码

添加一个对外查询的接口: 
```
@RestController
@RequestMapping("user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public User queryById(@PathVariable("id") Long id) {
        return this.userService.queryById(id);
    }
}
```

属性文件,这里我们采用了yaml语法, 而不是properties: 
```yaml
server:
  port: 8081
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb01
    username: root
    password: 123
    hikari:
      maximum-pool-size: 20
      minimum-idle: 10
mybatis:
  type-aliases-package: com.demo.pojo
```

## 服务调用者

### 创建工程

与上面类似, 这里不再赘述, 需要注意的是, 我们调用user-service的功能, 因此不需要mybatis相关依赖了。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
   http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.demo</groupId>
	<artifactId>user-consumer-demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>user-consumer-demo</name>
	<description>Demo project for Spring Boot</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.0.1.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<project.build.sourceEncoding>
      UTF-8
    </project.build.sourceEncoding>
		<project.reporting.outputEncoding>
      UTF-8
    </project.reporting.outputEncoding>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
        <!-- 添加OkHttp支持 -->
		<dependency>
			<groupId>com.squareup.okhttp3</groupId>
			<artifactId>okhttp</artifactId>
			<version>3.9.0</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
```

### 编写代码

首先在启动类中注册`RestTemplate`: 
```
@SpringBootApplication
public class UserConsumerDemoApplication {

    @Bean
    public RestTemplate restTemplate() {
        // 这次我们使用了OkHttp客户端,只需要注入工厂即可
        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    }

    public static void main(String[] args) {
        SpringApplication.run(UserConsumerDemoApplication.class, args);
    }
}
```

然后编写UserDao, 注意, 这里不是调用mapper查数据库, 而是通过RestTemplate远程查询user-service-demo中的接口: 
```
@Component
public class UserDao {

    @Autowired
    private RestTemplate restTemplate;

    public User queryUserById(Long id){
        String url = "http://localhost:8081/user/" + id;
        return this.restTemplate.getForObject(url, User.class);
    }
}
```

然后编写user-service, 循环查询UserDAO信息: 
```
@Service
public class UserService {

    @Autowired
    private UserDao userDao;

    public List<User> querUserByIds(List<Long> ids){
        List<User> users = new ArrayList<>();
        for (Long id : ids) {
            User user = this.userDao.queryUserById(id);
            users.add(user);
        }
        return users;
    }
}
```

编写controller: 
```
@RestController
@RequestMapping("consume")
public class ConsumerController {

    @Autowired
    private UserService userService;

    @GetMapping
    public List<User> consume(@RequestParam("ids") List<Long> ids) {
        return this.userService.queryUserByIds(ids);
    }
}
```

### 启动测试: 

因为我们没有配置端口, 那么默认就是8080, 我们访问: http://localhost:8080/consume?ids=6,7,8

一个简单的远程服务调用案例就实现了。

## 存在的问题

简单回顾一下, 刚才我们写了什么: 

- use-service-demo: 一个提供根据id查询用户的微服务
- consumer-demo: 一个服务调用者, 通过RestTemplate远程调用user-service-demo

存在什么问题？

- 在consumer中, 我们把url地址硬编码到了代码中, 不方便后期维护
- consumer需要记忆user-service的地址, 如果出现变更, 可能得不到通知, 地址将失效
- consumer不清楚user-service的状态, 服务宕机也不知道
- user-service只有1台服务, 不具备高可用性
- 即便user-service形成集群, consumer还需自己实现负载均衡

其实上面说的问题, 概括一下就是分布式服务必然要面临的问题: 

- 如何自动注册和发现服务
- 如何实现服务状态监管
- 如何实现服务动态路由
- 服务如何实现负载均衡
- 服务如何解决容灾问题
- 服务如何实现统一配置

以上的问题, 我们都将在SpringCloud中得到答案。
