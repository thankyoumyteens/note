# 基于表记录

创建一张锁表，想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。

```sql
CREATE TABLE `database_lock` (
    `id` BIGINT NOT NULL AUTO_INCREMENT,
    `resource` int NOT NULL COMMENT '锁定的资源',
    `description` varchar(1024) NOT NULL DEFAULT "" COMMENT '描述',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uiq_idx_resource` (`resource`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表';
```
在表database_lock中，resource字段做了唯一性约束，这样如果有多个请求同时提交到数据库的话，数据库可以保证只有一个操作可以成功，其它的会报错

想要获得锁时，可以插入一条数据
```sql
INSERT INTO database_lock(resource, description) VALUES (1, 'lock');
```

当需要释放锁的时，可以删除这条数据
```sql
DELETE FROM database_lock WHERE resource=1;
```

这种实现方式非常的简单，但是需要注意以下几点：

1. 这种锁没有失效时间，一旦释放锁的操作失败就会导致锁记录一直在数据库中，其它线程无法获得锁。这个缺陷也很好解决，比如可以做一个定时任务去定时清理。
1. 这种锁的可靠性依赖于数据库。建议设置备库，避免单点，进一步提高可靠性。
1. 这种锁是非阻塞的，因为插入数据失败之后会直接报错，想要获得锁就需要再次操作。如果需要阻塞式的，可以弄个for循环、while循环之类的，直至INSERT成功再返回。
1. 这种锁也是非可重入的，因为同一个线程在没有释放锁之前无法再次获得锁，因为数据库中已经存在同一份记录了。想要实现可重入锁，可以在数据库中添加一些字段，比如获得锁的主机信息、线程信息等，那么在再次获得锁的时候可以先查询数据，如果当前的主机信息和线程信息等能被查到的话，可以直接把锁分配给它。

# 乐观锁

系统认为数据的更新在大多数情况下是不会产生冲突的，只在数据库更新操作提交的时候才对数据作冲突检测。如果检测的结果出现了与预期数据不一致的情况，则返回失败信息。

1. 获取资源： SELECT resource, version FROM optimistic_lock WHERE id = 1
1. 执行业务逻辑
1. 更新资源：UPDATE optimistic_lock SET resource = ?, version = version + 1 WHERE id = 1 AND version = oldVersion

# 悲观锁

借助数据库中自带的锁来实现分布式锁。在查询语句后面增加FOR UPDATE，数据库会在查询过程中给数据库表增加悲观锁，也称排他锁。当某条记录被加上悲观锁之后，其它线程也就无法再该行上增加悲观锁。

MySQL InnoDB引起在加锁的时候，只有明确地指定主键(或索引)的才会执行行锁 (只锁住被选取的数据)，否则MySQL将会执行表锁。

在使用悲观锁时，我们必须关闭MySQL数据库的自动提交。这样在使用FOR UPDATE获得锁之后可以执行相应的业务逻辑，执行完之后再使用COMMIT来释放锁。

1. 获取锁：SELECT * FROM database_lock WHERE id = 1 FOR UPDATE;。
1. 执行业务逻辑。
1. 释放锁：COMMIT。
