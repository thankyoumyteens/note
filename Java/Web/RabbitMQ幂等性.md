# 唯一ID + 指纹码

指纹码是为了应对用户在一瞬间的频繁操作，这个指纹码可能是时间戳加别的服务给到的唯一信息码，基本都是由业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断唯一ID + 指纹码是否存在数据库中，如果存在，就表示操作重复。

好处就是实现简单，就一个拼接，然后查询判断是否重复。

坏处就是在高并发时，如果是单个数据库就会有写入性能瓶颈。

解决方案：根据 ID 进行分库分表，对 id 进行算法路由，落到一个具体的数据库，然后当这个 id 第二次来又会落到这个数据库，这时候就像单库时的查重一样了。利用算法路由把单库的幂等变成多库的幂等，分摊数据流量压力，提高性能。

# 利用 redis 的原子性去实现

使用 redis 的原子性去实现需要考虑两个点

一、进行数据落库。问题是数据库和缓存如何做到原子性？数据库与缓存进行同步肯定要进行写操作，到底先写 redis 还是先写数据库，这个问题，涉及到缓存更新与淘汰的问题

二、不落库，那么都存储到缓存中，如何设置定时同步的策略？不入库的话，可以使用双重缓存等策略，保障一个消息副本，具体同步可以使用类似 databus 这种同步工具。
