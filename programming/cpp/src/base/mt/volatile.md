# volatile

volatile 关键字用于修饰变量，告诉编译器该变量的值可能在程序未显式修改的情况下被意外改变。编译器会因此避免对该变量进行某些优化，确保每次访问都直接读写内存，而非使用寄存器中的缓存值。

## volatile 的核心作用

### 阻止编译器优化

编译器通常会对变量访问进行优化，比如将频繁访问的变量缓存到寄存器中（减少内存读写次数）。但对于 volatile 变量，编译器必须每次访问都直接操作内存，避免因缓存导致的读取旧值问题。

示例：

```cpp
int a = 0;
volatile int b = 0;

// 对普通变量 a，编译器可能优化为：a = 3（跳过中间步骤）
a = 1;
a = 2;
a = 3;

// 对 volatile 变量 b，编译器必须逐行执行（每次写内存）
b = 1;
b = 2;
b = 3;
```

### 标记 “易变” 变量

用于表示变量的值可能被程序外部因素修改。

## 注意事项

- 不保证线程安全：volatile 仅确保变量读写不被优化，但无法解决线程安全问题（如读写操作的原子性）
- 与 const 可共存：volatile const int x; 表示 x 是只读的，但值可能被外部修改
- 避免过度使用：普通变量无需加 volatile，否则会降低性能（减少编译器优化机会）

## 典型使用场景示例（硬件交互）

```cpp
// 假设 0x1234 是硬件寄存器地址，用于读取温度
volatile int* temperature_reg = (volatile int*)0x1234;

// 每次读取都直接访问内存（寄存器），确保获取最新温度
int current_temp = *temperature_reg;
```
