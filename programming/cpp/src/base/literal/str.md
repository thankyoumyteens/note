# 字符串字面量

```cpp
std::cout << "Hello, World!" << std::endl;
```

在上面的代码中, `"Hello, World!"` 是一个字符串字面量(string literal), 因为这个字符串以值的形式写出, 而不是一个变量。与字符串字面量关联的真正内存位于内存的只读部分。通过这种方式, 编译器可重用等价字符串字面量的引用, 从而优化内存的使用。也就是说, 即使一个程序使用了 500 次 `"Hello, World!"` 字符串字面量, 编译器也只在内存中创建一个 `"Hello, World!"` 实例。这种技术称为字面量池(literal pooling)。

字符串字面量可赋值给变量, 但因为字符串字面量位于内存的只读部分, 且使用了字面量池, 所以这样做会产生风险。C++标准正式指出：字符串字面量的类型为 n 个 const char 的数组, 然而为了向后兼容较老的不支持 const 的代码, 大部分编译器不会强制程序将字符串字面量赋值给 `const char*` 类型的变量。一般情况下, 试图修改字符串字面量的行为是没有定义的。可能会导致程序崩溃；可能使程序继续执行, 这完全取决于编译器。

```cpp
char *str = "Hello, World!";
str[1] = 'a'; // 未知结果
```

正确的写法是这样的:

```cpp
const char *str = "Hello, World!";
```

如果想要修改字符串的值, 可将字符串字面量用作字符数组 `char[]` 的初始值。这种情况下, 编译器会创建一个足以放下这个字符串的数组, 然后将字符串面量复制到这个数组。因此, 编译器不会将字面量放在只读的内存中, 也不会进行字面量的池操作。

```cpp
char str[] = "Hello, World!";
str[1] = 'a'; // 没问题
```
