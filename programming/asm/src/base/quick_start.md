# 第一个汇编程序

创建 `exit.s` 文件:

```x86asm
# 目的： 退出并向Linux内核返回一个状态码的简单程序
#
# 输入： 无
#
# 输出：返回一个状态码。在运行程序后可通过输入echo $?来读取状态码

# 变量：
#   %rax保存系统调用号
#   %rbx保存返回状态

.section .data

.section .text

    .globl _start

    _start:
        movq $1, %rax   # 这是用于退出程序的Linux内核命令号(系统调用)
        movq $123, %rbx # 这是我们将返回给操作系统的状态码
                        # 改变这个数字，则返回到echo $?的值会不同
        int $0x80       # 这将唤醒内核，以运行退出命令
```

## 汇编

```sh
as exit.s -o exit.o
```

## 链接

```sh
ld exit.o -o exit
```

## 运行

```sh
./exit
```

## 验证

```sh
echo $?
```

## 解释

在汇编语言程序的开始处，许多行都是以 `#` 号开始的，这些行被称为注释。

`.section .data`, 在汇编程序中，任何以小数点符号 `.` 开始的指令都不会被直接翻译成机器指令，这些针对汇编程序本身的指令，由于是由汇编程序处理，实际上并不会由计算机运行，因此被称为汇编指令或伪操作。在本程序中，`.section` 指令将程序分成几个部分。`.section .data` 命令是数据段的开始，数据段中要列出程序数据所需的所有内存空间。由于该程序没有使用任何数据， 所以我们不需要这个段。

上述指令之后是: `.section .text`, 这表示文本段开始，文本段是存放程序指令的部分。

再下一条指令是: `.globl _start`, 这条指令指示汇编程序：`_start` 很重要，必须记住。`_start` 是一个符号，这就是说它将在汇编或链接过程中被其他内容替换。符号一般用来标记程序或数据的位置。

`.g1obl` 表示汇编程序不应在汇编之后废弃此符号，因为链接器需要它。`_start` 是个特殊符号，总是用 `.g1ob1` 来标记，因为它标记了该程序的开始位置。如果不这样标记这个位置，当计算机加载程序时就不知道从哪里开始运行你的程序。

下一行: `_start:`, 定义 `_start` 标签的值。标签是一个符号，后面跟一个冒号。标签定义一个符号的值。当汇编器对程序进行汇编时，必须为每个数值和每条指令分配地址。标签告诉汇编程序以该符号的值作为下一条指令或下一个数据元素的位置。

`movq $1, %rax` 当程序运行时，该指令将数字 1 移人 `rax` 寄存器。在汇编语言中，很多指令都有操作数。`movq` 有两个操作数: 源操作数和目的操作数。在本例中，源操作数是数字 1，目的操作数是 `rax` 寄存器。操作数可以是数字、内存位置引用或寄存器。因此，`movq` 指令将数字 1 移入 `rax`。数字 1 前面的美元符号 `$` 表示我们要使用立即寻址方式寻址(立即数)。如果没有 `$` 符号，指令将会进行直接寻址，加载地址 1 中的数字。

将数字 1 移入 `rax` 是因为我们准备调用 Linux 内核，数字 1 表示系统调用 `exit`。进行系统调用时必须将系统调用号加载到 `rax`。不同的系统调用可能要求其他寄存器也必须含有值。但除了知晓进行哪个调用，操作系统通常需要更多的信息。这些额外的详细信息称为参数，存储在其他寄存器中。在进行系统调用 `exit` 的情况下，操作系统需要将状态码加载到 `rbx`。稍后这个值被返回给系统，它就是你键入 `echo $?` 时提取的值。因此，通过键入以下指令将 123 放到 `rbx`: `movq $123, %rbx`。

`int $0x80`: `int` 代表中断，`0x80` 是要用到的中断号。中断会中断正常的程序流，把控制权从我们的程序转移到 Linux，因此将进行一个系统调用。当系统调用完成后，控制权再度回到你手中。在本例中，我们所做的就是要求 Linux 终止程序，在这种情况下，我们不会再度获得控制权。而如果我们不发出中断信号，系统调用就不会被执行。

在 x86-64 系统上，虽然仍然可以使用 `int 0x80` 来进行系统调用，但它执行的是 32 位的系统调用，使用的是 32 位的系统调用表，且效率低下，不应该再使用；在 64 位系统上，应该使用` syscall` 系统调用，来使用 64 位的系统调用表。
