# GDB 常用命令

## 在可执行文件中包含调试信息

```sh
as --32 --gstabs demo.s -o demo.o
ld -melf_i386 demo.o -o demo
```

## 运行调试器

保证源代码也在当前目录下:

```sh
gdb 程序名
```

## 运行程序

要运行程序, 输入 `run` 即可。

## 设置断点

设置断点必须在运行程序之前进行。执行 `run` 命令之前, 可以使用 `break` 命令设置断点。

例如, 要在第 10 行设置断点, 可以执行命令 `break 10`。

然后, 程序到达第 10 行时就会停止运行, 并打印出当前行和指令。

接着, 就可以从该断点开始单步运行程序, 并检查寄存器和内存的内容。

```
(gdb) break 10
Breakpoint 1 at 0x4000b0: file maximum.s, line 10.
(gdb) run
Starting program: /root/asm_practice/maximum

Breakpoint 1, _start () at maximum.s:10
10              movl $0, %edi
(gdb)
```

当处理函数时, 也可以在函数名上设置断点: `break 函数名`。这会使调试器在函数调用和函数设置后立即中断(会跳过 `%esp`入栈和·%esp· 复制)。

## 单步调试

- `stepi`: 执行每一行代码, 相当于 IDE 中的 `Step Into`
- `nexti`: 跳过整个函数, 相当于 IDE 中的 `Step Over`

## 查看寄存器的值

- `info register`: 以十六进制显示所有寄存器的值
- `print/x $eax`: 以十六进制显示 `%eax` 寄存器的值
- `print/d $eax`: 以十进制显示 `%eax` 寄存器的值

## 查看内存地址中的值

命令格式:

```
x/<n/f/u>  <addr>
```

- n: 是正整数, 表示需要显示的内存单元的个数, 即从当前地址向后显示 n 个内存单元的内容, 一个内存单元的大小由第三个参数 u 定义
- f:表示 addr 指向的内存内容的输出格式, s 对应输出字符串: 
  - x 按十六进制格式显示变量
  - d 按十进制格式显示变量
  - u 按十进制格式显示无符号整型
  - o 按八进制格式显示变量
  - t 按二进制格式显示变量
  - a 按十六进制格式显示变量
  - c 按字符格式显示变量
  - f 按浮点数格式显示变量
- u:就是指以多少个字节作为一个内存单元,默认为 4。u 还可以用被一些字符表示:
  - b: 1 个字节
  - h: 2 个字节
  - w: 4 个字节
  - g: 8 个字节
- addr: 要查看的内存地址

比如下面的命令会显示从 rbp 寄存器存储的地址开始, 取 32 个字节的内容(8xw: 8 个内存单元, 按十六进制显示, 以 4 个字节作为一个内存单元):

```
(gdb) x/8xw $rbp
0x7fffffffe420: 0x00000000      0x00000000      0x00400081      0x00000000
0x7fffffffe430: 0x00000002      0x00000000      0x00000003      0x00000000
(gdb)
```

上面的命令通过汇编表示:

```x86asm
(%rbp)      # 0x00000000
4(%rbp)     # 0x00000000
8(%rbp)     # 0x00400081
12(%rbp)    # 0x00000000
16(%rbp)    # 0x00000002
20(%rbp)    # 0x00000000
24(%rbp)    # 0x00000003
28(%rbp)    # 0x00000000
32(%rbp)
```

## 设置命令行参数

进入 gdb 调试界面

输入参数命令 `set args` 后面加上程序所要用的参数, 注意, 不再带有程序名, 直接加参数, 如: 

```sh
set args -l a -C abc
```

回车后输入

```sh
run
```

即可开始运行
