# Unix 文件

当打开一个文件时，操作系统会提供一个编号，称为文件描述符，程序需要用它来指代该文件。接下来，就可以使用文件描述符对该文件进行读取和写入。完成读写后关闭文件，关闭后文件描述符就会失效。

## 操作文件的过程

1. open 系统调用可以打开文件，它需要 3 个参数: 一个文件名, 一个表示模式的数字以及一个权限集合。
   1. 将系统调用号 `5` 存放在 `%eax` 中
   2. 文件名的首地址存放在 `%ebx` 中
   3. 操作类型存放在 `%ecx` 中。`0` 表示读文件，`03101`表示写文件
   4. 文件权限模式存放在 `%edx` 中
2. 接着，Linux 将把文件描述符返回到 `%eax`
3. 接下来，就可以对文件进行读/写操作，每次都要向 Linux 指明要使用的文件描述符。
   1. `read` 是系统调用 `3`，调用时要将文件描述符存入 `%ebx`，将存储数据的缓冲区地址存入 `%ecx` 中，将缓冲区大小放入 `%edx` 中。`read` 会返回从文件中读取的字符数，或者一个错误代码(错误代码是负数)。
   2. `write` 是系统调用 `4`，需要的参数与 `read` 系统调用相同，唯一的区别是缓冲区应该已经填满了要写入的数据。`write` 系统调用将把写入的字节数或错误代码存入 `%eax`
4. 文件使用完毕后，就可以关闭文件, 此后这个文件描述符将失效。
   1. `close` 是系统调用 `6`。唯一的参数就是文件描述符，存储在 `%ebx` 中

## 缓冲区

缓冲区是连续的字节块，用于批量数据传输。一般缓冲区仅用于暂时存储数据，然后数据被从缓冲区中读出并转换成便于程序处理的形式。缓冲区的大小是固定的，由程序员设定。所以，如果想一次读入 500 字节的数据，可以将 500 字节未使用内存位置的地址发送给 `read` 系统调用，并将数字 500 发送给它，这样 `read` 就知道数据的大小。

汇编程序可以通过 `.section .bss` 段实现缓冲区。在数据段(`.section .data`)中，既可以保留存储位置，也能为其设置初始值， 但在 `.bss` 段中却不能设置初始值。对于缓冲区来说，这非常有用，因为我们并不需要初始化，只需要保留存储位置。

使用以下命令创建 `.bss` 段：

```x86asm
.section .bss
.lcomm my_buffer, 500
```

`.lcomm` 指令将创建一个符号 `my_buffer`，指代用作缓冲区的 500 字节存储位置。接着执行以下指令通过缓冲区来读文件，假设文件已经打开，并已经将文件描述符放在 `%ebx` 中：

```x86asm
# 缓冲区地址
movl $my_buffer, %ecx
# 缓冲区大小
movl 500, %edx
# read系统调用
movl 3, %eax
int $0x80
```

`my_buffer` 之前需要加 `$` 符号。如果没有 `$` 符号，`my_buffer` 将作为以直接寻址方式访问的内存位置。而 `$` 符号则将寻址方式变为立即寻址方式，实际上就是将 `my_buffer` 本身(即缓冲区的起始地址)加载到 `%ecx` 中。

## 特殊的文件

Linux 的程序在启动时, 至少会打开 3 个文件描述符:

1. `STDIN`: 这是标准输入，是一个只读文件，通常代表键盘，文件描述符为 `0`
2. `STDOUT`: 这是标准输出，是一个只写文件，通常代表屏幕显示，文件描述符为 `1`
3. `STDERR`: 这是标准错误，是一个只写文件，通常代表屏幕显示, 文件描述符为 `2`。处理结果通常输出到 `STDOUT`，但在这个过程中出现的任何错误消息都输出到 `STDERR`

这些“文件”都可以重定向，以一个真正的文件取代屏幕或键盘。程序操作的许多“文件”根本就不是文件。基于 UNIX 的操作系统把所有输入/输出系统都视作文件。网络连接被视为文件，串行端口被视为文件，甚至音频设备都被视为文件。进程之间的通信也通常是通过称为管道的特殊文件实现的。与普通文件相比，这些文件有一些不同的打开和创建方法(例如，不使用 `open` 系统调用)，但可以使用标准的 `read` 和 `write` 系统调用进行读写。
