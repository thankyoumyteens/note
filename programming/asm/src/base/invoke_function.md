# 函数的执行原理

C 语言调用约定（Calling Convention）是一组规则，定义了如何在函数调用过程中传递参数、如何管理函数调用期间的寄存器以及函数返回值的存放方式。

在 C 语言调用约定中，栈是实现函数的局部变量、参数和返回地址的关键。

## 调用函数

以函数 a 中调用函数 b 为例, 函数 b 需要 3 个参数, 每个参数都占用 4 个字节。

在调用 b 之前，a 会将 b 需要的所有参数按逆序压入栈中。

此时的栈结构:

![](../img/invoke_function1.jpg)

接着，函数 a 会执行 `call` 指令, `cal1` 指令会做两件事：

1. 将 `cal1` 指令的下一条指令的地址(即返回地址)压入栈中, 让 CPU 知道调用完函数后要从哪里继续执行
2. 修改指令指针 `%eip` , 指向 b 的起始地址

此时的栈结构:

![](../img/invoke_function2.jpg)

此时 `%eip` 已经指向了函数 b, 接着开始执行 b 中的指令。

首先，函数 b 通过 `pushl %ebp` 指令保存当前的基址指针寄存器 `%ebp`(即 a 的 `%ebp`)。基址指针是一个特殊的寄存器，用于访问函数的参数和局部变量。

此时的栈结构:

![](../img/invoke_function3.jpg)

然后，函数 b 会用 `movl %esp, %ebp` 将栈指针 `%esp` 复制到 `%ebp`，这使得 b 能够通过 `%ebp` 加上偏移量访问到所有的参数。

在函数开始时将 `%esp` 复制到 `%ebp` 可以让函数一直清楚参数和局部变量的位置。如果函数中存在入栈或出栈操作, 就会导致 `%esp` 的变化, 而 `%ebp` 将一直是栈指针在函数开始时的位置，所以可以说 `%ebp` 是对栈帧的常量引用。(栈帧包含一个函数中使用的所有栈变量， 包括参数、局部变量和返回地址。)

此时的栈结构:

![](../img/invoke_function4.jpg)

可以看到，每个参数都可以用 `%ebp` 通过基址寻址方式访问。

接下来，函数 b 会为它的所有局部变量保留栈空间，只需将 `%esp` 向下(低地址方向)移动即可实现。假设函数 b 需要两个局部变量, 每个局部变量占用 4 字节的内存，那么只需通过 `subl $8 %esp` 命令将 `%esp` 向下移动 8 字节即可 。

此时的栈结构:

![](../img/invoke_function5.jpg)

现在可以使用 `%ebp` 中的不同偏移量，通过基址寻址访问函数所需的所有数据。这就是 `%ebp` 被称为基址指针的原因。虽然也可以在基址指针寻址方式中使用其他寄存器，但在 x86 架构中，使用 `%ebp` 寄存器的速度会快得多。

## 函数返回

当函数 b 执行完毕后，它会做三件事:

1. 将返回值存储到 `%eax`
2. 将栈恢复到调用函数时的状态: 将栈指针 `%esp` 和基址指针 `%ebp` 重新设置为函数开始时的值
3. 调用 `ret` 指令, 将控制权交还给调用它的函数 a。`ret` 指令将栈顶的值(返回地址)弹出，并将指令指针寄存器 `%eip` 设置为这个返回地址, 由于返回地址中保存的是函数 a 中 `call` 指令的下一条指令的地址, 所以函数 a 可以继续执行

函数返回时需要执行的指令：

```x86asm
# 栈恢复到调用函数时的状态
movl %ebp, %esp
# 恢复调用方的%ebp寄存器
popl %ebp
# 把返回地址的值设置给%eip
ret
```

执行 `movl %ebp, %esp` 后的栈结构:

![](../img/invoke_function6.jpg)

执行 `popl %ebp` 后的栈结构:

![](../img/invoke_function7.jpg)

执行 `ret` 后的栈结构:

![](../img/invoke_function8.jpg)

现在控制权已经转回函数 a 那里，a 现在可以检查 `%eax` 中的返回值。同时, 如果不再需要参数值，函数 a 可以用 `add1 $12 %esp` 将 3 个参数出栈。

## 调用函数前保存寄存器的中的值

当调用函数时，当前寄存器中的一切内容都可能会被覆盖, 唯一一个不会被覆盖的寄存器就是 `%ebp`。

`%eax` 作为返回值肯定会被覆盖，而其他寄存器则可能被覆盖。如果要在调用函数前保存寄存器的内容，必须在函数参数入栈前将寄存器的内容入栈。然后，在弹出参数后以逆序将其弹出存回寄存器。即使知道函数不会覆盖某个寄存器，也应该保存它，因为该函数将来的版本可能会覆盖该寄存器。
