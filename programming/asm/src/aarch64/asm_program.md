# 汇编程序结构

```x86asm
# 汇编程序示例
    .section    __TEXT,__text
    .globl  _main
    .p2align    2
_main:
    mov    w0, #0
    ret
```

说明:

- 以 `#` 号开始的内容是注释
- `.section`, 在汇编程序中, 任何以 `.` 开始的指令都不会被直接翻译成机器指令, 这些针对汇编程序本身的指令, 由于是由汇编程序处理, 实际上并不会由计算机运行
  - `.section` 常用的格式: `.section segname, sectname`。segname 是段名，sectname 是节名。汇编代码放在 `__TEXT`段的 `__text` 节中。 `.section __TEXT, __text` 可以用 `.section .text` 简写
- `.globl` 也可以写成 `.global`, 用于声明一个符号为全局的，`.global` 的作用：
  - 设置符号的可见性，使得符号在整个程序中都是可见的，包括其他源文件
  - 在多个源文件组成的程序中，`.global` 允许编译器生成外部符号的引用，这些符号可以在链接时被其他源文件中的代码访问
  - 通过 `.globl _main` 声明程序入口（类似 C 语言中的 main 函数）
- `.p2align 2`, 指令对齐
- `_main:`, 定义 `_main` 标签的值。标签为汇编代码中的指令、数据定义或内存位置提供了一个标识符，使得在代码中引用这些位置变得更加容易和清晰

## 赋值指令

```asm
mov 目标 源
```

例如，`mov w0, w1` 可以将 w1 的值赋值给 w0。`mov x0, x1` 可以将 x1 的值赋值给 x0。

### 扩展

mov 指令只能在相同宽度的寄存器之间赋值, 小宽度寄存器赋值给大宽度寄存器时需要使用扩展指令。

有符号扩展赋值

1. sxtb: 将源寄存器的最低位的 1 个字节赋值给目的寄存器，并进行相应的有符号扩展
2. sxth: 将源寄存器的最低位的 2 个字节赋值给目的寄存器，并进行相应的有符号扩展
3. sxtw: 将源寄存器的最低位的 4 个字节赋值给目的寄存器，并进行相应的有符号扩展

无符号扩展赋值

1. uxtb: 将源寄存器的最低位的 1 个字节赋值给目的寄存器，并进行相应的无符号扩展
2. uxth: 将源寄存器的最低位的 2 个字节赋值给目的寄存器，并进行相应的无符号扩展
3. uxtw: 将源寄存器的最低位的 4 个字节赋值给目的寄存器，并进行相应的无符号扩展

### 截断

将 x0 的值赋给 w1:

```asm
mov w1, w0
```

### 将立即数赋值给寄存器

```asm
ldr 寄存器, =立即数
```

比如:

```asm
ldr w0, =0x123456
```

## 计算指令

- 加法 `add 目标寄存器, 寄存器1, 寄存器2/立即数`
  ```asm
      .section __TEXT,__text
      .globl _main
      .p2align 2
  _main:
      # w1 = 1
      ldr w1, =1
      # w0 = w1 + 2 = 3
      add w0, w1, #2
      ret
  ```
- 减法 `sub 目标寄存器, 寄存器1, 寄存器2/立即数`
- 与 `and 目标寄存器, 寄存器1, 寄存器2/立即数`
- 或 `orr 目标寄存器, 寄存器1, 寄存器2/立即数`
- 非 `mvn 目标寄存器, 寄存器1`
- 异或 `eor 目标寄存器, 寄存器1, 寄存器2/立即数`
