# 计算指令

- 加法 `add 目标寄存器, 寄存器1, 寄存器2/立即数`
- 减法 `sub 目标寄存器, 寄存器1, 寄存器2/立即数`
- 与 `and 目标寄存器, 寄存器1, 寄存器2/立即数`
- 或 `orr 目标寄存器, 寄存器1, 寄存器2/立即数`
- 非 `mvn 目标寄存器, 寄存器1`
- 异或 `eor 目标寄存器, 寄存器1, 寄存器2/立即数`

示例:

```asm
    .section __TEXT,__text
    .globl _main
    .p2align 2
_main:
    # w1 = 1
    ldr w1, =1
    # w0 = w1 + 2
    add w0, w1, #2
    # w0 == 3
    ret
```

- 乘法
  - `mul 目标寄存器(32位), 寄存器1(32位), 寄存器2(32位)`
  - 无符号乘法 `umull 目标寄存器(64位), 寄存器1(32位), 寄存器2(32位)`
  - 有符号乘法 `smull 目标寄存器(64位), 寄存器1(32位), 寄存器2(32位)`
- 除法
  - 无符号除法 `udiv 目标寄存器, 寄存器1, 寄存器2`
  - 有符号除法 `sdiv 目标寄存器, 寄存器1, 寄存器2`
- 取模, aarch64 指令集不提供直接的求余数的指令
  ```asm
  # w0 = w1 % w2
  sdiv w0, w1, w2
  mul w0, w2, w0
  sub w0, w1, w0
  ```
- 逻辑左移 `lsl w0, w1, #2`, 将 w1 内的值逻辑左移 2 位赋值给 w0。如果想将一个数乘 2, 可以直接逻辑左移 1 位, 乘 4 就逻辑左移 2 位
