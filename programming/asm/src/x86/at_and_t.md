# AT&T 汇编和 Intel 汇编

在 20 世纪 70 年代, AT&T 的贝尔实验室开发了 UNIX 操作系统。当时, UNIX 系统使用的汇编语言就是基于 AT&T 的语法风格。由于 UNIX 对操作系统和计算机科学产生了深远的影响, AT&T 汇编语法也因此在学术界和工业界得到了广泛传播。

Intel 汇编是 x86 架构汇编语言的一种语法风格, 广泛用于编写与 Intel 处理器相关的低级代码。这种语法是由 Intel 公司在其处理器文档中定义的, 因此得名。

## 区别

AT&T 汇编和 Intel 汇编是 x86 架构汇编语言的两种不同的语法风格。它们在表示指令和操作数的方式上有一些显著的区别, 以下是这两种语法的主要区别: 

1. **操作数顺序**: 

   - **AT&T 语法**: 使用“目标, 源”的顺序, 即目标操作数在源操作数之前。例如, 将`EBX`寄存器的值赋给`EAX`寄存器, 在 AT&T 语法中写作`movl %ebx, %eax`。
   - **Intel 语法**: 使用“源, 目标”的顺序, 即源操作数在目标操作数之前。在 Intel 语法中相同的操作写作`mov eax, ebx`。

2. **寄存器表示**: 

   - 在**AT&T 语法**中, 寄存器前有一个`%`符号。
   - 在**Intel 语法**中, 寄存器前没有特殊符号。

3. **立即数表示**: 

   - 在**AT&T 语法**中, 立即数前使用`$`符号。例如, 将立即数`0x1`赋给`EAX`寄存器, 写作`movl $0x1, %eax`。
   - 在**Intel 语法**中, 立即数前没有特殊符号, 直接写出数值。例如, `mov eax, 1`。

4. **指令后缀**: 

   - **AT&T 语法**中, 指令的后缀通常用来表示指令的执行大小, 例如`movb`, `movw`, `movl`, `b`表示字节(8位), `w`表示字(16位), `l`表示长字(32位)。
   - **Intel 语法**中, 指令后缀的使用不如 AT&T 语法那么常见, 指令名称通常足以表达其操作的大小, 例如`mov al, bl`, `mov ax,bx`, `mov eax, ebx`。

5. **内存寻址**: 

   - 在**AT&T 语法**中, 内存地址的表示方式与 Intel 语法不同。例如, 访问基址为`EBX`, 偏移量为`0x10`的内存地址, 在 AT&T 语法中写作`movl 0x10(%ebx), %eax`。
   - 在**Intel 语法**中, 相同的内存寻址写作`mov eax, dword ptr [ebx+0x10]`。

6. **系统调用**: 

   - 在 UNIX 系统下, 特别是在使用 AT&T 语法的系统中, 系统调用通常使用特定的指令序列, 如`int $0x80`。

7. **汇编指示符**: 

   - AT&T 汇编中使用如`.byte`, `.word`, `.long`等指示符来定义数据。
   - Intel 汇编中也有类似的指示符, 但可能会有不同的使用习惯。

8. **语法的普及**: 

   - AT&T 语法在 UNIX 系统和相关的文档中更为常见, 特别是在基于 UNIX 的操作系统如 Linux 中。
   - Intel 语法则在 Windows 和一些其他的文档中更为常见。

9. **汇编器兼容性**: 
   - AT&T 语法通常与 GNU 汇编器(GAS)兼容。
   - Intel 语法则可能与 NASM(Netwide Assembler)等汇编器兼容。

两种语法在功能上是等价的, 只是表示方法不同。程序员可以根据个人喜好、特定系统的要求或特定汇编器的需要选择使用其中一种语法。
