# 方法调用指令

## invokevirtual

用于调用所有的虚方法

```
操作码:
        invokevirtual
操作数:
        indexbyte1
        indexbyte2
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
        objectref
操作数栈-执行后:
        -
```

无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值，构建方式为`(indexbyte1 << 8) | indexbyte2`，该索引所指向的运行时常量池项应当是一个方法的符号引用，它包含了方法的名称和描述符，以及包含该方法的接口的符号引用。这个方法的符号引用是已被解析过的，而且这个方法不能是实例初始化方法和类或接口的初始化方法。最后，如果调用的方法是 protected 的，并且这个方法是当前类的父类成员，并且这个方法没有在同一个运行时包中定义过，那 objectref 所指向的对象的类型必须为当前类或者当前类的子类。

假设 C 是 objectref 所对应的类，虚拟机将按下面规则查找实际执行的方法：

1. 如果 C 中定义了一个实例方法 M，它重写了符号引用中表示的方法，那方法 M 就会被调用，查找过程终止
2. 如果 C 有父类，查找过程将按第一点的方式顺序递归搜索 C 的直接父类，如果超类中能搜索到符合的方法，那这个方法就会被调用
3. 否则，抛出 AbstractMethodError 异常

在操作数栈中，objectref 之后必须跟随 N 个参数，它们的数量、类型和顺序都必须与方法描述符所描述的保持一致。

如果要调用的是同步方法，那与 objectref 相关的管程（monitor）将会进入或者重入，就如当前线程中同执行了 monitorenter 指令一般。如果要调用的不是本地方法(JNI)，n 个 args 参数和 objectref 将从操作数栈中出栈。

方法调用的时候，一个新的栈帧将在 JVM 栈中被创建出来，objectref 和连续的 n 个参数将存放到新栈帧的局部变量表中，objectref 存为局部变量 0，arg1 存为局部变量 1（如果 arg1 是 long 或 double 类型，那将占用局部变量 1 和 2 两个位置），依此类推。新栈帧创建后就成为当前栈帧，JVM 的程序计数器被设置成指向调用方法的首条指令，程序就从这里开始继续执行。

## invokespecial

用于调用实例构造器`<init>`方法、私有方法和父类中的方法

```
操作码:
        invokespecial
操作数:
        indexbyte1
        indexbyte2
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
        objectref
操作数栈-执行后:
        -
```

无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值，构建方式为`(indexbyte1 << 8) | indexbyte2`，该索引所指向的运行时常量池项应当是一个方法的符号引用，它包含了方法的名称和描述符，以及包含该方法的接口的符号引用。最后，如果调用的方法是 protected 的，并且这个方法是当前类的父类成员，并且这个方法没有在同一个运行时包中定义过，那 objectref 所指向的对象的类型必须为当前类或者当前类的子类。

只有下面所有的条件都成立的前提下，才会进行调用方法的搜索：

- 当前类的 ACC_SUPER 标志为真
- 调用方法所在的类是当前类的超类
- 调用方法不是`<init>`方法

如果以上条件都成立，虚拟机将按下面规则查找实际执行的方法，假设 C 是当前类的直接父类：

1. 如果 C 中包含了名称和描述符都和要调用的实例方法一致的方法，那这个方法就会被调用，查找过程终止
2. 如果 C 有父类，查找过程将按顺序递归搜索 C 的直接父类，如果超类中能搜索到名称和描述符都和要调用的实例方法一致的方法，那这个方法就会被调用
3. 否则，抛出 AbstractMethodError 异常

objectref 必须是一个 reference 类型的数据，在操作数栈中，objectref 之后还跟随着连续 n 个参数值，这些参数的数值、数据类型和顺序都必须遵循实例方法的描述符中的描述。如果要调用的是同步方法，那与 objectref 相关的管程（monitor）将会进入或者重入，就如当前线程中同执行了 monitorenter 指令一般。如果要调用的不是本地方法，n 个 args 参数和 objectref 将从操作数栈中出栈。方法调用的时候，一个新的栈帧将在 Java 虚拟机栈中被创建出来，objectref 和连续的 n 个参数将存放到新栈帧的局部变量表中，objectref 存为局部变量 0，arg1 存为局部变量 1（如果 arg1 是 long 或 double 类型，那将占用局部变量 1 和 2 两个位置），依此类推。新栈帧创建后就成为当前栈帧，Java 虚拟机的 PC 寄存器被设置成指向调用方法的首条指令，程序就从这里开始继续执行。

## invokestatic

用于调用静态方法

## invokeinterface

用于调用接口方法

## invokedynamic
