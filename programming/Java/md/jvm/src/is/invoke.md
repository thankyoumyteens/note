# 方法调用指令

## invokevirtual

用于调用所有的虚方法

```
操作码:
        invokevirtual
操作数:
        indexbyte1
        indexbyte2
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
        objectref
操作数栈-执行后:
        -
```

无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值, 构建方式为`(indexbyte1 << 8) | indexbyte2`, 该索引所指向的运行时常量池项应当是一个方法的符号引用, 它包含了方法的名称和描述符, 以及包含该方法的接口的符号引用。这个方法的符号引用是已被解析过的, 而且这个方法不能是实例初始化方法和类或接口的初始化方法。最后, 如果调用的方法是 protected 的, 并且这个方法是当前类的父类成员, 并且这个方法没有在同一个运行时包中定义过, 那 objectref 所指向的对象的类型必须为当前类或者当前类的子类。

假设 C 是 objectref 所对应的类, 虚拟机将按下面规则查找实际执行的方法：

1. 如果 C 中定义了一个实例方法 M, 它重写了符号引用中表示的方法, 那方法 M 就会被调用, 查找过程终止
2. 如果 C 有父类, 查找过程将按第一点的方式顺序递归搜索 C 的直接父类, 如果超类中能搜索到符合的方法, 那这个方法就会被调用
3. 否则, 抛出 AbstractMethodError 异常

在操作数栈中, objectref 之后必须跟随 N 个参数, 它们的数量、类型和顺序都必须与方法描述符所描述的保持一致。

如果要调用的是同步方法, 那与 objectref 相关的管程（monitor）将会进入或者重入, 就如当前线程中同执行了 monitorenter 指令一般。如果要调用的不是本地方法(JNI), n 个 args 参数和 objectref 将从操作数栈中出栈。

方法调用的时候, 一个新的栈帧将在 JVM 栈中被创建出来, objectref 和连续的 n 个参数将存放到新栈帧的局部变量表中, objectref 存为局部变量 0, arg1 存为局部变量 1（如果 arg1 是 long 或 double 类型, 那将占用局部变量 1 和 2 两个位置）, 依此类推。新栈帧创建后就成为当前栈帧, JVM 的程序计数器被设置成指向调用方法的首条指令, 程序就从这里开始继续执行。

## invokespecial

用于调用实例构造器`<init>`方法、私有方法和父类中的方法

```
操作码:
        invokespecial
操作数:
        indexbyte1
        indexbyte2
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
        objectref
操作数栈-执行后:
        -
```

无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值, 构建方式为`(indexbyte1 << 8) | indexbyte2`, 该索引所指向的运行时常量池项应当是一个方法的符号引用, 它包含了方法的名称和描述符, 以及包含该方法的接口的符号引用。最后, 如果调用的方法是 protected 的, 并且这个方法是当前类的父类成员, 并且这个方法没有在同一个运行时包中定义过, 那 objectref 所指向的对象的类型必须为当前类或者当前类的子类。

只有下面所有的条件都成立的前提下, 才会进行调用方法的搜索：

- 当前类的 ACC_SUPER 标志为真
- 调用方法所在的类是当前类的超类
- 调用方法不是`<init>`方法

如果以上条件都成立, 虚拟机将按下面规则查找实际执行的方法, 假设 C 是当前类的直接父类：

1. 如果 C 中包含了名称和描述符都和要调用的实例方法一致的方法, 那这个方法就会被调用, 查找过程终止
2. 如果 C 有父类, 查找过程将按顺序递归搜索 C 的直接父类, 如果超类中能搜索到名称和描述符都和要调用的实例方法一致的方法, 那这个方法就会被调用
3. 否则, 抛出 AbstractMethodError 异常

objectref 必须是一个 reference 类型的数据, 在操作数栈中, objectref 之后还跟随着连续 n 个参数值, 这些参数的数值、数据类型和顺序都必须遵循实例方法的描述符中的描述。如果要调用的是同步方法, 那与 objectref 相关的管程（monitor）将会进入或者重入, 就如当前线程中同执行了 monitorenter 指令一般。如果要调用的不是本地方法, n 个 args 参数和 objectref 将从操作数栈中出栈。方法调用的时候, 一个新的栈帧将在 JVM 栈中被创建出来, objectref 和连续的 n 个参数将存放到新栈帧的局部变量表中, objectref 存为局部变量 0, arg1 存为局部变量 1（如果 arg1 是 long 或 double 类型, 那将占用局部变量 1 和 2 两个位置）, 依此类推。新栈帧创建后就成为当前栈帧, JVM 的程序计数器被设置成指向调用方法的首条指令, 程序就从这里开始继续执行。

## invokestatic

用于调用静态方法

```
操作码:
        invokestatic
操作数:
        indexbyte1
        indexbyte2
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
操作数栈-执行后:
        -
```

无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值, 构建方式为`(indexbyte1 << 8) | indexbyte2`, 该索引所指向的运行时常量池项应当是一个方法的符号引用, 它包含了方法的名称和描述符, 以及包含该方法的接口的符号引用。此方法应是已被解析过的, 而且不能是实例的初始化方法和类或接口的初始化方法。这个方法必须被声明为 static, 因此它也不能是 abstract 方法。在方法被成功解析之后, 如果方法所在的类没有被初始化过, 那指令执行时将会触发其初始化过程。

在操作数栈中必须包含连续 n 个参数值, 这些参数的数值、数据类型和顺序都必须遵循实例方法的描述符中的描述。如果要调用的是同步方法, 那与这个类的 Class 对象相关的管程（monitor）将会进入或者重入, 就如当前线程中同执行了 monitorenter 指令一般。如果要调用的不是本地方法, n 个 args 参数将从操作数栈中出栈。方法调用的时候, 一个新的栈帧将在 JVM 栈中被创建出来, 连续的 n 个参数将存放到新栈帧的局部变量表中, arg1 存为局部变量 0（如果 arg1 是 long 或 double 类型, 那将占用局部变量 0 和 1 两个位置）, 依此类推。新栈帧创建后就成为当前栈帧, JVM 的程序计数器被设置成指向调用方法的首
条指令, 程序就从这里开始继续执行。

## invokeinterface

用于调用接口方法

```
操作码:
        invokeinterface
操作数:
        indexbyte1
        indexbyte2
        count
        0
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
        objectref
操作数栈-执行后:
        -
```

无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值, 构建方式为`(indexbyte1 << 8) | indexbyte2`, 该索引所指向的运行时常量池项应当是一个接口方法的符号引用, 它包含了方法的名称和描述符, 以及包含该方法的接口的符号引用。这个方法的符号引用是已被解析过的, 而且这个方法不能是实例初始化方法和类或接口的初始化方法。

操作数 count 是一个无符号 byte 型数据, 而且不能为零。objectref 必须是一个 reference 类型的数据。在操作数栈中, objectref 之后还跟随着连续 n 个参数值, 这些参数的数值、数据类型和顺序都必须遵循接口方法的描述符中的描述。

invokeinterface 指令的第四个参数规定永远为 byte 类型的 0。

假设 C 是 objectref 所对应的类, 虚拟机将按下面规则查找实际执行的方法:

1. 如果 C 中包含了名称和描述符都和要调用的接口方法一致的方法, 那这个方法就会被调用, 查找过程终止
2. 如果 C 有父类, 查找过程将按顺序递归搜索 C 的直接父类, 如果超类中能搜索到名称和描述符都和要调用的接口方法一致的方法, 那这个方法就会被调用
3. 否则, 抛出 AbstractMethodError 异常

如果要调用的是同步方法, 那与 objectref 相关的管程（monitor）将会进入或者重入, 就如当前线程中同执行了 monitorenter 指令一般。如果要调用的不是本地方法, n 个 args 参数和 objectref 将从操作数栈中出栈。方法调用的时候, 一个新的栈帧将在 JVM 栈中被创建出来, objectref 和连续的 n 个参数将存放到新栈帧的局部变量表中, objectref 存为局部变量 0, arg1 存为局部变量 1（如果 arg1 是 long 或 double 类型, 那将占用局部变量 1 和 2 两个位置）, 依此类推。新栈帧创建后就成为当前栈帧, JVM 的程序计数器被设置成指向调用方法的首条指令, 程序就从这里开始继续执行

## invokedynamic

调用动态方法

```
操作码:
        invokedynamic
操作数:
        indexbyte1
        indexbyte2
        0
        0
操作数栈-执行前:
        argn(可选)
        ...
        arg2(可选)
        arg1(可选)
操作数栈-执行后:
        -
```

代码中每条 invokedynamic 指令出现的位置都被称为一个动态调用点（Dynamic Call Site）。

首先。无符号数 indexbyte1 和 indexbyte2 用于构建一个当前类的运行时常量池的索引值, 构建方式为`(indexbyte1 << 8) | indexbyte2`, 该索引所指向的运行时常量池项应当是一个调用点限定符的符号引用。指令第 3、4 个操作数固定为 0。

调用点限定符会被解析为一个动态调用点, 从中可以获取到 java.lang.invoke.MethodHandle 实例的引用、java.lang.invoke.MethodType 实例的引用和所涉及的静态参数的引用。

接着, 作为调用点限定符解析过程的一部分, 引导方法将会被执行。如同使用 invokevirtual 指令调用普通方法那样, 会包含一个运行时常量池的索引指向一个带有如下属性的方法：

- 此方法名为 invoke。
- 此方法描述符中的返回值是 java.lang.invoke.CallSite。
- 此方法描述符中的参数来源自操作数栈中的元素, 包括如下顺序排列的 4
  个参数：
  - java.lang.invoke.MethodHandle
  - java.lang.invoke.MethodHandles.Lookup
  - String
  - java.lang.invoke.MethodType
- 如果调用点限定符有静态参数, 那么这些参数的参数类型应附加在方法描述符的参数类型中, 以便在调用时按顺序入栈至操作数栈。静态参数的参数类型可以包括：
  - Class
  - java.lang.invoke.MethodHandle
  - java.lang.invoke.MethodType
  - String
  - int
  - long
  - float
  - double
- 在 java.lang.invoke.MethodHandle 之中可以提供关于在哪个类中能找到方法的符号引用所对应的实际方法的信息。

引导方法执行前, 下面各项内容将会按顺序压入到操作数栈中：

- 用于代表引导方法的 java.lang.invoke.MethodHandle 对象的引用。
- 用于确定动态调用点发生位置的 java.lang.invoke.MethodHandles.Lookup 对象的引用。
- 用于确定调用点限定符中方法名的 String 对象引用。
- 在方法限定符中出现的各种静态参数, 包括：类、方法类型、方法句柄、字符串以及各种数值类型都必须按照他们在方法限定符中出现的顺序依次入栈（此处基本类型不会发生自动装箱）。

只要引导方法能够被正确调用, 它的描述符可以是不精确的。举个例子, 引导方法的第一个参数应该是 java.lang.invoke.MethodHandles.Lookup, 但是在可以使用 Object 来代替, 返回值应该是 java.lang.invoke.CallSite, 也可以使用 Object 来代替。

如果引导方法是一个变长参数方法（Variable Arity Method）, 那某些（甚至是全部）上面描述中要压入到操作数栈的参数会被包含在一个数组参数之中。

引导方法的调用发生在试图解析动态方法调用点的调用点限定符的那条线程上, 如果同时有多条线程进行此操作, 那引导方法将会被并发调用。因此, 如果引导方法中有访问公有数据的话, 需要注意多线程竞争问题, 对公有数据访问施行适当的保护措施。

引导方法执行后的返回值是一个 java.lang.invoke.CallSite 或其子类的实例, 这个对象被称为调用点对象（Call Site Object）, 此对象的引用将会从操作数栈中出栈, 就像 invokevirtual 指令执行过程一样。 如果多条线程同时执行了一个动态调用点的引导方法, 那 JVM 必须选择其中一个引导方法的返回值作为调用点对象, 并将其发布到所有线程之中。此动态调用点中其余的引导方法会完成整个执行过程, 但是它们的返回结果将被忽略掉, 转为使用哪个被 JVM 选中的调用点对象来继续执行。

调用点对象拥有一个类型描述符（一个 java.lang.invoke.MethodType 的实例）, 它必须语义上等同于调用点限定符中方法描述符内所包含的 java.lang.invoke.MethodType 对象。 调用点限定符解析的结果是一个调用点对象, 此对象将会与它的动态调用点永
久绑定起来。 绑定于动态调用点的调用点对象所表示的方法句柄将会被调用, 这次调用就和执行 invokevirtual 指令一样, 会带有一个指向运行时常量池的索引, 它指向的常量池项是一个方法的符号引用, 此方法具备如下属性：

- 方法名为 invokeExact。
- 方法描述符为调用点限定符中包含的描述符。
- 由 java.lang.invoke.MethodHandle 来确定在哪个类中查找方法的符号引用所对应的方法。

指令执行时, 操作数栈中的内容会被虚拟机解释为包含一个调用点对象的引用以及跟随 nargs 个参数值, 这些参数的数量、类型和顺序都必须与调用点限定符中的方法描述符保持一致。
