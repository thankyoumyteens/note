# 模块路径

JDK 9 提出了与类路径(ClassPath)相对应的模块路径(ModulePath)的概念。某个类库到底是模块还是传统的 JAR 包, 只取决于它存放在哪种路径上。只要是放在类路径上的 JAR 文件, 无论其中是否包含模块化信息, 都会被当作传统的 JAR 包来对待。只要放在模块路径上的 JAR 文件, 即使没有使用 JMOD 后缀、其中并不包含 module-info.class 文件, 它也仍然会被当作一个模块来对待。

模块路径上的每个目录都可以包含零个或多个模块定义，其中模块可以是文件夹形式或者 jar 包形式。使用`--module-path`参数指定模块路径, 比如:

```sh
java --module-path my_path1/:my_path2/my_module1:my_path3/my_module2.jar
```

my_path1 目录中的所有模块都在模块路径上, my_path2 目录中只有 my_module1 文件夹在模块路径上, my_path3 目录中只有 my_module2.jar 在模块路径上。

块路径中的冒号(:)是分隔符, Linux 和 MacOS 上的分隔符是冒号, 而在 Windows 上则使用分号。此外`--module-path`可以缩写成`-p`。

当模块路径上相同目录中具有相同名称的多个模块, Java 就会显示错误，并且不会启动应用程序。这样一来, 就可以防止以前在类路径上可能发生的 jar 包冲突的问题。当具有相同名称的多个模块位于模块路径上的不同目录中时, 则不会产生错误, 而是选择第一个模块, 并忽略具有相同名称的后续模块。另外, 模块不允许循环依赖, 如果模块间存在循环依赖(直接或间接), 在编译时会报错。

## 兼容 JDK9 之前的版本

模块化系统将按照以下规则来保证使用传统类路径依赖的 Java 程序可以不经修改地直接运行在 JDK 9 及以后的 Java 版本上:

- JAR 文件在类路径的访问规则: 所有类路径下的 JAR 文件及其他资源文件, 都被视为自动打包在一个匿名模块(Unnamed Module)里, 这个匿名模块几乎是没有任何隔离的, 它可以看到和使用类路径上所有的包、JDK 系统模块中所有的导出包, 以及模块路径上所有模块中导出的包
- 模块在模块路径的访问规则: 模块路径下的具名模块(Named Module)只能访问到它依赖定义中列出的模块和包, 匿名模块里所有的内容对具名模块来说都是不可见的, 即具名模块看不见传统 JAR 包的内容
- JAR 文件在模块路径的访问规则: 如果把一个传统的、不包含模块定义的 JAR 文件放置到模块路径中, 它就会变成一个自动模块(Automatic Module)。自动模块将默认依赖于整个模块路径中的所有模块, 因此可以访问到所有模块导出的包, 自动模块也默认导出自己所有的包
