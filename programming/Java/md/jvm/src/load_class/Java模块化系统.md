# Java模块化系统

在JDK 9中引入了Java模块化系统(Java Platform Module System，JPMS)。

在JDK 9之前，Java平台是以JAR包的形式发布的，这些JAR包之间没有依赖关系，可以随意地混用。JDK 9引入了模块化系统之后，Java平台被划分为若干个模块，每个模块有自己的依赖关系和加载顺序。模块化系统使得Java平台变得灵活、稳定和易于维护。

---

JDK 9提出了与类路径(ClassPath)相对应的模块路径(ModulePath)的概念。某个类库到底是模块还是传统的JAR包，只取决于它存放在哪种路径上。只要是放在类路径上的JAR文件，无论其中是否包含模块化信息，都会被当作传统的JAR包来对待。只要放在模块路径上的JAR文件，即使没有使用JMOD后缀、其中并不包含module-info.class文件，它也仍然会被当作一个模块来对待。

模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上：

- JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块(Unnamed Module)里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包
- 模块在模块路径的访问规则：模块路径下的具名模块(Named Module)只能访问到它依赖定义中列出的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容
- JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块(Automatic Module)。自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包

---

为了模块化系统的顺利施行，模块化下的类加载器发生了一些变动。

首先，是扩展类加载器被平台类加载器(Platform Class Loader)取代。原来的rt.jar和tools.jar被拆分成数十个JMOD文件，删除了`<JAVA_HOME>\lib\ext`目录，取消了通过java.ext.dirs系统变量来扩展JDK功能的机制。同时，取消了jre目录，因为随时可以组合构建出程序运行所需的JRE来，假设我们只使用java.base模块中的类型，那么可以通过以下命令打包出一个JRE：

```
jlink -p $JAVA_HOME/jmods --add-modules java.base --output jre
```

其次，平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中
加载的逻辑，以及模块中资源可访问性的处理。

启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器，表示成名为BootClassLoader的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景(如Object.class.getClassLoader())中仍然会返回null来代替，而不会得到BootClassLoader的实例。

Java模块化系统规定了三个类加载器负责各自加载的模块，即归属关系，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。
