# 解析

解析(Resolution)阶段是是连接阶段(Linking)的第三步，它是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。

直接引用(Direct References)：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

虚拟机可以自由决定解析阶段发生的具体时间，只要保证在操作符号引用的字节码指令执行之前，先对它们所使用的符号引用进行解析即可。

除invokedynamic指令以外，虚拟机可以对第一次解析的结果进行缓存，从而避免重复解析。

# 类或接口的解析

把一个类或接口的符号引用解析为直接引用：

1. 如果被访问类不是数组，那虚拟机会把被访问类的全限定名传递给访问类的类加载器去加载。在加载过程中，可能会加载其他相关的类，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析就会失败
2. 如果被访问类是数组类型，并且数组的元素类型为对象，那虚拟机会先加载数组的元素类型，接着由虚拟机生成一个代表该数组维度和元素的数组对象
3. 如果上面两步没有出现任何异常，就开始验证访问权限。如果不具备访问权限，将抛出java.lang.IllegalAccessError异常
4. 最后，如果验证通过，虚拟机将会把符号引用转换为直接引用

在JDK 9引入了模块化以后，还必须检查模块间的访问权限。需要以下3条规则中至少有其中一条成立：

- 被访问类是public的，并且与访问类处于同一个模块
- 被访问类是public的，不与访问类处于同一个模块，但是被访问类的模块允许访问类的模块进行访问
- 被访问类不是public的，但是它与访问类处于同一个包中

# 字段解析

把一个字段的符号引用解析为直接引用，首先会将这个字段所属的类(或接口)的符号引用解析为直接引用，再解析字段本身。如果在解析这个类的过程中出现了任何异常，字段解析也会失败。

如果这个类解析成功，就会在该类中进行字段的搜索：

1. 如果这个类(或接口)本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
2. 否则，如果它实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了匹配的字段，则返回这个字段的直接引用，查找结束
3. 否则，如果不是Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了匹配的字段，则返回这个字段的直接引用，查找结束
4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常
5. 如果查找成功，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常

# 类方法解析

把一个方法的符号引用解析为直接引用，首先会解析方法所属的类的符号引用。如果在解析这个类的过程中出现了任何异常，方法解析也会失败。

如果这个类解析成功，就会在该类中进行方法的搜索：

1. 如果在这个类的方法表中发现class_index中索引的是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常
2. 否则，在类中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
3. 否则，在类的父类中递归查找是否有匹配的方法，如果有则返回这个方法的直接引用，查找结束
4. 否则，在类实现的接口列表及它们的父接口之中递归查找是否有匹配的方法，如果存在匹配的方法，说明类是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常
5. 否则，查找失败，抛出java.lang.NoSuchMethodError异常
6. 如果查找成功，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常

# 接口方法解析

把一个方法的符号引用解析为直接引用，首先会解析方法所属的接口的符号引用。如果在解析这个接口的过程中出现了任何异常，方法解析也会失败。

如果这个接口解析成功，就会在该接口中进行方法的搜索：

1. 如果在接口的方法表中发现class_index中索引的是个类的话，那就直接抛出java.lang.IncompatibleClassChangeError异常
2. 否则，在接口中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
3. 否则，在接口的父接口(包括Object类)中递归查找是否有匹配的方法，如果有则返回这个方法的直接引用，查找结束
4. 如果在不同的父接口中存有多个匹配的方法，那将会从这多个方法中返回其中一个并结束查找
5. 否则，查找失败，抛出java.lang.NoSuchMethodError异常
6. 如果查找成功，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常

在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题。但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也有可能因访问权限控制而出现java.lang.IllegalAccessError异常。
