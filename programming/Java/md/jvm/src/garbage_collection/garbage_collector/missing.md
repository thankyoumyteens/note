# 漏标

如果用户线程在标记进行时并发修改了引用关系, 就可能导致漏标。比如正在标记对象 b 的时候, b 指向 e 的引用被切断了, e 又与已扫描过的黑色对象 a 建立了引用关系。但是垃圾回收器不会再次扫描黑色对象, 所以 e 就会一直是白色对象, 在标记结束后会被当做垃圾清理掉, 导致程序运行出错。

![](../../img/ThreeColorMarking6.png)

为了解决漏标问题, JVM 实现了两种解决方案: 增量更新(Incremental Update)和原始快照(Snapshot At The Beginning, SATB)。CMS 使用的是增量更新方案, G1 使用的是原始快照方案。

## 增量更新

在黑色对象新增了一个指向白色对象的引用时, 就将这个引用记录到一个集合中, 在并发标记结束后, 进入重新标记阶段, 重新标记过程会暂停所有用户线程, 此时将记录的引用关系中的黑色对象为根, 重新扫描一次, 这次扫描, 白色对象就会变成黑色对象或者灰色对象, 不会被当做垃圾清理掉。

![](../../img/ThreeColorMarking8.png)

## 原始快照

当扫描到灰色对象的引用删除时, 会将这个引用删除前的状态保存成一个快照, 然后放到集合里。等到重新标记阶段, 将记录的引用关系中的灰色对象为根, 重新扫描一次, 由于保存的是删除前的快照, 这样就可以扫描到白色对象了, 将这些白色对象全部标记为黑色对象。但是如果灰色对象删除引用后, 并没有黑色对象与这个白色对象建立新的引用, 这个对象就会成为浮动垃圾。

![](../../img/ThreeColorMarking7.png)

无论是对引用关系记录的插入还是删除, JVM 的记录操作都是通过写屏障实现的。
