# 经典垃圾收集器

经典的垃圾收集器有Serial收集器、Parallel收集器、CMS收集器、G1收集器、ParNew收集器等。

## Serial收集器

Serial收集器是一个单线程的收集器，基于标记-复制算法，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

它是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。对于单核处理器来说，Serial收集器由于没有线程交互的开销，可以获得最高的单线程收集效率。在用户桌面的应用场景以及部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代，垃圾收集的停顿时间可以控制在最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。

## ParNew收集器

ParNew收集器是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余都与Serial收集器完全一致。

除了Serial收集器外，目前只有它能与CMS收集器配合工作。

从JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。

## Parallel Scavenge收集器

Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，其他收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是提高吞吐量。

吞吐量是处理器用于运行用户代码的时间与处理器总消耗时间的比值。如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

## SerialOld收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。

如果在服务端模式下，它也可能有两种用途：

1. 在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用
2. 作为CMS收集器发生失败时的后备预案

## ParallelOld收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直没有合适的老年代收集器搭配。

直到Parallel Old收集器出现后，吞吐量优先收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。
