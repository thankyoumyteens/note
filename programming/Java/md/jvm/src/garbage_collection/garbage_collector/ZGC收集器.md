# ZGC收集器

ZGC(Z Garbage Collector)是一款在JDK 11中新加入的由Oracle公司研发的具有实验性质的低延迟垃圾收集器。ZGC的设计目标是在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

## 内存布局

ZGC也采用基于Region的堆内存布局，但不同的是，ZGC的Region可以动态创建和销毁，以及动态的容量。在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量：

- 小型Region(Small Region)：容量固定为2MB，用于放置小于256KB的小对象
- 中型Region(Medium Region)：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象
- 大型Region(Large Region)：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，虽然名字叫作大型Region，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂

![](../../img/zgc_region.jpeg)

## 染色指针

三色标记本质上与对象无关，仅仅与引用有关，它通过引用关系判断对象是否存活。HotSpot虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在
对象头上(如Serial收集器)，有的把标记记录在与对象相互独立的数据结构上(如G1使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息)，而ZGC的染色指针(Colored Pointer)直接把标记信息记在引用对象的指针上，无需进行对象访问就可以获得标记信息，提高了垃圾收集的效率。

当前版本的AMD64架构规定了只用48位地址(可以支持256TB的内存)，当前完全够用，为了节省地址转换的开销，指针的高16位暂时保留。在可用的48位中，ZGC的染色指针将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集(即被移动过)、是否只能通过finalize()方法才能被访问到。由于这些标志位进一步压缩了原本就只有46位的地址空间，导致ZGC能够管理的内存不可以超过16TB。

![](../../img/ColoredPointer.png)

Finalizable标识表示对象是否只能通过finalize()方法访问到，Remapped、Marked0和Marked1用作三色标记。

## 染色指针的优势

1. 染色指针可以实现一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理
2. 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，将这些信息直接维护在指针中，就可以省去一些专门的记录操作。到目前为止ZGC都并未使用任何写屏障，只使用了读屏障
3. 由于Linux下的64位指针还有前16位并未使用，染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能

## AMD64架构实现染色指针

在远古时代的x86计算机系统里面，所有进程都是共用同一块物理内存空间的，这样会导致不同进程之间的内存无法相互隔离，当一个进程污染了别的进程内存后，就只能对整个系统进行复位后才能得以恢复。

为了解决这个问题，从Intel 80386处理器开始，提供了保护模式用于隔离进程。在保护模式下，386处理器的全部32条地址寻址线都有效，进程可访问最高也可达4GB的内存空间，但此时已不同于之前实模式下的物理内存寻址了，处理器会使用分页管理机制把线性地址空间(在虚拟内存管理中，进程所使用的地址空间的逻辑视图)和物理地址空间分别划分为大小相同的块，这样的内存块被称为页(Page)。通过在线性虚拟空间的页与物理地址空间的页之间建立的映射表，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。

Linux/x86-64平台上的ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上，把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。

## ZGC的运作过程

ZGC的运作过程大致可划分为四个大的阶段，全部四个阶段都是可以并发执行的，在两个阶段中间会存在短暂的停顿小阶段。

1. 并发标记(Concurrent Mark)：与G1一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked0、Marked1标志位
2. 并发预备重分配(Concurrent Prepare for Relocate)：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集(Relocation Set)。ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放

