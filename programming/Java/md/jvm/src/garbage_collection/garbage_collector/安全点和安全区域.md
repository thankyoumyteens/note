# 安全点和安全区域

在 OopMap 的协助下，HotSpot 可以快速准确地完成根节点枚举，但可能导致引用关系变化，或者说导致 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外存储空间。

HotSpot 只会在特定的位置记录 OopMap 的变化，这些位置被称为安全点(Safepoint)。由于垃圾收集需要借助 OopMap，因此必须到达安全点时才可以开始垃圾收集。

一般会在如下几个位置选择安全点：

- 循环的末尾
- 方法临返回前
- 调用方法之后
- 抛异常的位置

另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程都执行到最近的安全点，然后停顿下来。这里有两种方案可供选择：抢先式中断(Preemptive Suspension)和主动式中断(Voluntary Suspension)。

抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它执行到安全点上再重新中断。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应 GC 事件。

主动式中断是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。设置轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在 Java 堆上分配内存的地方。

由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot 使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。

内存保护陷阱(Memory Protection Fault)是一种计算机硬件或操作系统的异常情况，通常发生在程序试图访问未分配给它的内存区域或越界访问内存时。当程序执行期间发生内存保护陷阱时，操作系统会中断程序的执行并进行相应的处理。

HotSpot 使用汇编指令 test 实现轮询操作，假设地址 0x160100 是一个安全点：

```asm
test %eax,0x160100
```

当需要暂停用户线程时，虚拟机把 0x160100 的内存页设置为不可读，那线程执行到 test 指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。

当用户线程处于 Sleep 或者 Blocked 状态时，是无法响应虚拟机的中断请求的，不能再走到安全的地方去中断挂起自己，虚拟机也不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域来解决。

安全区域(Safe Region)是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举，或者垃圾收集过程中其他需要暂停用户线程的阶段，如果完成了，那线程就可以继续执行，否则它就必须一直等待，直到收到可以离开安全区域的信号为止。
