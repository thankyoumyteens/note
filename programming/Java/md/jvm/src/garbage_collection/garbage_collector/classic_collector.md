# 经典垃圾收集器

经典的垃圾收集器有 Serial 收集器、Parallel 收集器、CMS 收集器、G1 收集器、ParNew 收集器等。

## Serial 收集器

Serial 收集器是一个单线程的收集器, 基于标记-复制算法, 它进行垃圾收集时, 必须暂停其他所有工作线程, 直到它收集结束。

它是 HotSpot 虚拟机运行在客户端模式下的默认新生代收集器, 对于内存资源受限的环境, 它是所有收集器里额外内存消耗最小的。对于单核处理器来说, Serial 收集器由于没有线程交互的开销, 可以获得最高的单线程收集效率。在用户桌面的应用场景以及部分微服务应用中, 分配给虚拟机管理的内存一般来说并不会特别大, 收集几十兆甚至一两百兆的新生代, 垃圾收集的停顿时间可以控制在最多一百多毫秒以内, 只要不是频繁发生收集, 这点停顿时间对许多用户来说是完全可以接受的。

## ParNew 收集器

ParNew 收集器是 Serial 收集器的多线程并行版本, 除了同时使用多条线程进行垃圾收集之外, 其余都与 Serial 收集器完全一致。

除了 Serial 收集器外, 目前只有它能与 CMS 收集器配合工作。

从 JDK 9 开始, ParNew 加 CMS 收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。

## Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一款新生代收集器, 它同样是基于标记-复制算法实现的收集器, 也是能够并行收集的多线程收集器。

Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同, 其他收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间, 而 Parallel Scavenge 收集器的目标是提高吞吐量。

吞吐量是处理器用于运行用户代码的时间与处理器总消耗时间的比值。如果虚拟机完成某个任务, 用户代码加上垃圾收集总共耗费了 100 分钟, 其中垃圾收集花掉 1 分钟, 那吞吐量就是 99%。

停顿时间越短就越适合需要与用户交互的程序, 良好的响应速度能提升用户体验。而高吞吐量则可以最高效率地利用处理器资源, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的分析任务。

## SerialOld 收集器

Serial Old 是 Serial 收集器的老年代版本, 它同样是一个单线程收集器, 使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的 HotSpot 虚拟机使用。

## ParallelOld 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本, 支持多线程并发收集, 基于标记-整理算法实现。

这个收集器是直到 JDK 6 时才开始提供的, 在此之前, 新生代的 Parallel Scavenge 收集器一直没有合适的老年代收集器搭配。在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。
