# 写屏障

当有其他分代区域中的对象引用了本区域的对象时，其对应的 card 就会变脏。解释执行时，JVM 负责每条字节码指令的执行，可以在赋值操作时更新卡表。但在编译执行时，经过即时编译后的代码已经是纯粹的机器指令流，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中。

在 HotSpot 虚拟机里是通过写屏障(Write Barrier)技术维护卡表状态的，注意，这不是内存屏障(Memory Barrier)。写屏障可以看作在 JVM 层面对引用类型字段赋值这个动作的 AOP 切面，在引用对象赋值时会产生一个环绕(Around)通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障(Pre-Write Barrier)，在赋值后的则叫作写后屏障(Post-Write Barrier)。直至 G1 收集器出现之前，其他收集器都只用到了写后屏障。

```c++
// 写后屏障更新卡表
void oop_field_store(oop* field, oop new_value) {
    // 引用字段赋值操作
    *field = new_value;
    // 写后屏障，在这里完成卡表状态更新
    post_write_barrier(field, new_value);
}
```

## 伪共享

除了写屏障的开销外，卡表在高并发场景下还存在伪共享(False Sharing)问题。

CPU 的运算速度远快于主内存，为了解决这个问题，一般会在 CPU 与主内存之间添加一级或者多级高速缓存。按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存(L1)、二级缓存(L2)和三级缓存(L3)。每一级缓存中所储存的全部数据都是下一级缓存的一部分。越靠近 CPU 的缓存越快也越小，L1 和 L2 只能被一个单独的 CPU 核心使用，L3 被所有 CPU 核心共享。当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，如果这些缓存中都没有所需的数据，就要去主存中查找。

![](../../img/cpu_cache.png)

CPU 缓存是以缓存行(Cache Line)为单位存储的，缓存行是 CPU 和主存之间数据传输的最小单位，每个缓存行的大小通常是 64 字节。当 CPU 访问某个变量时，首先会去看缓存内是否有该变量，如果有则直接从中获取，否则就去主内存中查找该变量，然后把该变量所在内存区域的一个缓存行大小的内存都复制到缓存中。由于存放到缓存行的是一块内存区域而不是单个变量，所以可能会把多个连续的变量存放到一个缓存行中。

当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能降低，这就是伪共享问题。比如一个缓存行中有 a 和 b 两个变量，当核心 1 上的线程 1 要修改变量 a 时，首先会修改缓存中的变量 a。这时由于 a 的值改变了，为了保证数据一致，a 所在的所有缓存行都会失效，如果线程 2 被分配了核心 2，那么当它读取(或写入)变量 b 时，发现这个缓存行已经失效了，需要从主内存中重新加载。这样就出现了一个问题，b 和 a 完全不相干，却每次因为 a 的更新而从主内存重新读取，导致程序性能降低。

![](../../img/fs.png)

假设处理器的缓存行大小为 64 字节，由于一个 card 占 1 个字节，64 个 card 将共享同一个缓存行。这 64 个 card 对应的卡页总的内存为 32KB(64×512 字节)，如果不同线程更新的对象正好处于这 32KB 的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。JDK 7 加入一个参数-XX:+UseCondCardMark 来控制是否进行有条件的写屏障，开启时会先判断卡表元素是否已经被标记为 Dirty，如果是就不再重复进行标记了，以减少修改缓存行的次数。

### 字节填充

在 JDK 8 之前，可以通过创建一个对象时使用填充字段填充该对象所在的缓存行，这样就避免了将多个对象存放在同一个缓存行中(栈中的变量是线程独享的，所以不存在伪共享问题)：

```java
public class MyLongpublic {
    public volatile long value;
    public long p1, p2, p3, p4, p5;
}

MyLongpublic[] longs = new MyLongpublic[N];
```

一个缓存行有 64 字节，一个 long 类型是 8 个字节，填充 5 个 long 之后，一共就是 48 个字节。而 Java 对象头在 64 位系统下占用 16 个字节，这样填充 5 个 long 型即可填满 64 字节，也就是一个缓存行。虽然解决了伪共享问题，但是这种填充的方式也浪费了缓存资源，明明只有 8 个字节的大小，却使用了 64 个字节缓存空间。

### @Contented 注解

JDK 8 及之后的版本提供了@Contented 注解，加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要设置 jvm 参数 -XX:-RestrictContended 才会生效。
