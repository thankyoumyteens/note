# 分代GC模式

G1中存在纯G1模式(pure garbage-first mode)和分代G1模式(generational garbage-first mode)两种模式。OpenJDK虽然实现了纯G1模式，但是并没有将这种模式开放给用户，用户使用的都是分代G1模式。

和纯G1模式相比，分代G1模式主要有以下两个不同点

1. Region是分代的
2. 回收集的选择是分代的

在分代G1模式中，Region被分为新生代Region和老年代Region两类。和其他收集器一样，分代的对象也保存了自身在各次转移中存活下来的次数(年龄)。新生代Region用来存放新生代对象，老年代Region用来存放老年代对象。

G1中的新生代GC称为Yong GC，老年代GC称为Mixed GC。Yong GC和Mixed GC的主要区别在于CSet的选择。Yong GC将所有新生代Region选入CSet，而Mixed GC将所有新生代Region，以及一部分老年代Region选入CSet。

## 新生代Region

新生代Region可以分为两类：创建Region，存活Region。创建Region用来存放刚刚生成、一次也没有被转移过的对象。存活Region用来存放被转移过至少一次的对象。另外，写屏障不会应用在新生代Region的对象上，即使新生代Region的对象存在对其他Region对象的引用，被引用Region的RSet中也不会记录引用方的卡片。

对于新生代RegionA中的对象a对老年代RegionB中对象b的引用，写屏障是无效的，所以RSetB不会记录这次引用。而对于来自老年代Region对象的引用，写屏障仍然有效。

![](../../img/g1bm16.png)

在分代G1模式中，所有的新生代Region都会被选入CSet，因此在转移新生代Region时所有对象的引用都会被检查。即使被引用Region的RSet中记录了来自新生代Region的引用，这些记录也都是重复的信息，因为遍历新生代对象时就会找到这些Region了。因此，RSet中不会记录来自新生代Region的引用。

## 分代对象转移

存活对象保存了自己被转移的次数，这个次数称为对象的年龄。转移时对象的年龄如果低于阈值，对象就会被转移到新生代Region，否则就会被转移到老年代Region。将对象转移到老年代Region的行为称为晋升。如果转移的目标Region满了，G1就会选择一个空闲的Region，把它修改成新生代Region或者老年代Region之后，作为转移的目标Region使用。对象被转移到新生代Region之后，即使该对象引用了CSet以外的Region，也不需要记录在RSet中。相反，往老年代Region转移对象时就必须要记录。因为老年代Region并非每次都会被选入回收集合。

## 软实时性

在G1中，用户可以设置如下3个值：

1. 可用内存上限
2. GC暂停时间上限
3. GC单位时间

设置可用内存上限是为了避免内存被过度占用。就算是为了实现软实时性，也不能让GC完全占用内存。

GC暂停时间上限指定的是执行GC所导致的用户线程的最大暂停时间。这个最大暂停时间并不包含G1的并发处理的时间。G1为了避免GC暂停时间超过指定上限，会频繁地执行暂停时间较短的GC。虽然这样做确实可以缩短GC暂停时间，但是用户线程的执行也会频繁地被GC打断，从而导致用户线程几乎无法正常执行。要解决这个问题，需要指定GC单位时间。

指定GC单位时间后，G1将在每个单位时间内遵守GC的暂停时间上限。如果 GC暂停时间上限是1秒，而GC单位时间是3秒，就表示在任意3秒的时间段内，GC的暂停时间不可以超过1秒。

G1会努力实现软实时性。软实时性是指GC单位时间内GC暂停时间超过上限的次数在用户的容忍范围之内。因此，尽管会出现GC暂停时间超过了上限的情况，但是只要用户认为可以接受，就算是实现了软实时性。

要想在GC暂停时间上限之内完成转移，就需要选择可以在这个时间范围内完成转移的CSet。在往CSet中添加Region时，要先预测一下该Region的转移时间，如果超过了GC暂停时间上限，就不再添加该Region，并终止CSet的选择。

为了满足"在GC单位时间内不得超过GC暂停时间的上限"的要求，GC中需要暂停用户线程的处理必须在合适的时机进行。当堆内空间充足时，可以根据需要扩展堆，从而延迟转移处理。而且，转移处理并不一定发生在并发标记完全结束之后。因此，即使并发标记过程中的暂停处理延迟开始，也不会产生致命的问题。

在一般情况下（除了堆内空间紧缺时），GC暂停处理发生的时机是可以调度的。G1中有一个队列名为调度队列，其中的元素是暂停处理的开始时间和结束时间的组合。G1使用这个队列来高效地调度GC的暂停处理任务。调度队列中保存了最近一次暂停处理的开始时间和结束时间。调度队列中元素个数是有上限的，如果添加元素时超过上限，队列头部中最早添加的元素就会被删除。调度程序会基于调度队列中的信息来决定下次GC暂停的适当时机。但是，在GC的预测时间不准确或堆内空间不足等导致GC必须提前开始时，GC暂停处理还是会超出暂停时间上限。并发标记中的暂停处理阶段(初始标记阶段、最终标记阶段、收尾工作)也会以这种方法按照合适的间隔执行。但是，这些步骤的暂停时间不像转移中的暂停时间一样可控，如果暂停时间本身就超过了GC暂停时间上限，就不能遵守GC暂停时间上限了。

## 最大新生代Region数

选择全部新生代Region的做法可能会打破软实时性。如果新生代Region数太多，就有可能无法遵守用户设置的GC暂停时间上限。要想避免这个问题，分代G1模式就需要计算出合理的最大新生代Region数。

Yong GC的最大新生代Region数是在遵守GC暂停时间上限的前提下，尽量设置较大的值。即根据过去的转移时间记录，预测出单个新生代Region转移所需的大概时间，然后基于这个时间计算出刚好不超过GC暂停时间上限的最大新生代Region数。

而Mixed GC的最大新生代Region数是在遵守GC单位时间的前提下，尽量设置较小的值。首先，计算出下次能够进行GC暂停处理的时机。然后，预测出在这个时机之前大概能回收多少个Region，并以此作为新生代Region的最大数目。当预测值命中时，达到最大新生代Region数的时机，刚好就是下次能够进行GC暂停处理的时机，因此能够遵守GC单位时间。另外，因为最大新生代Region数设置的是最小值，所以被选入回收集合的新生代Region数也是最少的。这样一来，距离GC暂停时间上限很可能还有一段时间，就可以往回收集合里
添加一些老年代Region。

最大新生代Region数的设置发生在并发标记结束之后。

垃圾回收器在选择GC算法时，通常会选择Mixed GC，只有在使用Yong GC效率更高时才会切换为Yong GC。切换的时间点和设置最大新生代Region数时一样，都是在并发标记结束之后。首先，参考并发标记中标记出的死亡对象个数，预测出下次Mixed GC的转移效率。然后，根据过去的Yong GC的转移效率，预测出下次Yong GC的转移效率。如果预测出Yong GC的转移效率更高，则切换为Yong GC。

当新生代Region数达到上限时，会触发转移的执行。换句话说，通过调节最大新生代Region数，可以控制转移执行的时机。

当转移完成并通过以下4项检查之后，会开始执行并发标记：

1. 不在并发标记执行过程中
2. 并发标记的结果已被上次转移使用完
3. 已经使用了一定量的堆内存(默认是全部堆内存的45%以上)
4. 相比上次转移完成之后，堆内存的使用量有所增加

其中第2步是为了避免重复地并发标记。如果有并发标记的结果尚未在转移过程中被使用，则不会开始并发标记。
