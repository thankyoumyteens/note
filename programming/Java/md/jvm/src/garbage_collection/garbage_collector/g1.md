# G1

从 JDK 9 开始, Garbage First(简称 G1)成为了默认的垃圾回收器, 并且删除了 CMS。G1 会尽力满足用户期望的暂停时间, 比如设置参数: -XX:MaxGCPauseMillis=200, 表示要求 G1 在任意 1 秒的时间段内, 停顿不得超过 200ms。G1 会尽量达成这个目标, 它能够推算出本次要收集的大体区域, 以增量的方式完成收集。

连续的内存将导致垃圾回收的事件过长, 停顿时间不可控, 所以 G1 把 Java 堆划分为多个大小相等的独立区域(Region)。每一个 Region 都可以根据需要, 作为新生代空间, 或者老年代空间, G1 对作为不同空间的 Region 采用不同的策略去处理。在逻辑上, 所有的新生代 Region 合起来就是整个新生代, 所有的老年代 Region 合起来就是整个老年代。这样划分之后, G1 不必每次都去收集整个堆空间, 而是每次只处理一部分 Region。

Region 中还有一类特殊的 Humongous Region, 专门用来存储大对象。一个对象的大小如果超过了一个 Region 容量的一半, 就会被当作大对象。如果一个更大的大对象超过了一个 Region 容量, G1 会使用多个连续的 Humongous Region 存储它, G1 的大多数行为都会把 Humongous Region 作为老年代的一部分来看待。

![](../../img/g1_region.png)

G1 提供了 3 种垃圾回收方式: Yong GC、Mixed GC 和 Full GC。Yong GC 总是回收所有新生代 Region, Mixed GC 会回收所有的新生代 Region 以及部分老年代 Region, 而 Full GC 则是回收所有的 Region。在 G1 中, 新生代 Region 的数量不是固定不变的, G1 会自动计算合适的新生代 Region 的数量, 通过控制新生代的 Region 个数, 来控制垃圾回收的暂停时间。

## CSet

CSet 是 G1 的回收集, 代表每次垃圾回收要回收的的一系列目标 Region。在任意一次 GC 中, CSet 中所有的 Region 都会被释放, 其中存活的对象都会被转移到空闲的 Region 中。因此无论是 Young GC, 还是 Mixed GC, 工作的机制都是一致的。

Young GC 的 CSet 是所有的新生代 Region,。而 Mixed GC 不仅会回收所有的新生代 Region, 还会在老年代 Region 中筛选出回收收益最高的一部分 Region 添加到 CSet 中。

## Young GC

当 Eden 区空间不足时, 会开始新生代回收过程, G1 的新生代回收是并行执行的, 在新生代回收期间, G1 会暂停所有应用程序线程, 启动多个 GC 线程执行新生代回收, 从新生代 Region 移动存活对象到 Survivor Region 或者老年代 Region。

## 并发标记

Mixed GC 会回收所有的新生代 Region 和一部分老年代 Region。老生代 Region 的选择涉及 G1 的并发标记算法，这个过程称为并发标记阶段。并发标记是指并发标记线程和应用程序线程同时运行，它有 4 个典型的子阶段: 初始标记子阶段、并发标记子阶段、再标记子阶段和清理子阶段。

1. 初始标记子阶段: 负责标记所有从根集合直接可达的对象，根集合是对象图的起点，初始标记需要将应用程序线程暂停，也就是需要一个 STW 的时间段。初始标记子阶段和新生代的初始标记几乎一样。其实初始标记子阶段借用了 Young GC 的结果，把新生代垃圾回收后的 Survivor Region 作为根。所以 Mixed GC 一定发生在 Young GC 之后，且不需要再进行一次初始标记
2. 并发标记子阶段: 当 Young GC 执行结束之后，如果发现满足并发标记的条件，并发线程就开始进行并发标记。从新生代的 Survivor Region 开始并发标记。并发标记的时机是在 Young GC 后，只有内存占用达到一定的阈值后才会触发。在 G1 中，这个阈值通过参数 InitiatingHeapOccupancyPercent 控制(默认 45，表示的是当已经分配的内存加上本次将分配的内存超过内存总容量的 45% 时就可以开始并发标记)。并发标记子阶段会启动多个并发标记线程，每个线程每次只扫描一个 Region，标记出其中的存活对象。在标记的时候还会计算存活对象的数量，同时会计算存活对象所占用的内存大小。并发标记子阶段会对所有的 Region 进行标记。这个阶段并不需要 STW，故标记线程和应用程序线程并发运行
3. 再标记子阶段: 在该阶段中，G1 需要一个 STW 的时间段, 标记那些在并发标记子阶段发生变化的对象
4. 清理子阶段: 在该阶段中，G1 也需要一个 STW 的时间段, 清理子阶段主要执行以下操作：
   - 统计存活对象，统计的结果将会用来排序 Region，以用于下一次的垃圾回收时 CSet 的选择
   - 交换标记位图，为下次并发标记做准备
   - 如果存在空闲 Region, 则把空闲 Region 放到空闲 Region 列表中。空闲 Region 指的是全都是垃圾对象的 Region，如果一个 Region 中还有存活的对象，则不会被放到空闲 Region 列表中。空闲 Region 列表中的 Region

## Mixed GC

Mixed GC 和 Young GC 的步骤完全一致, 并且重用了 Young GC 的代码, 最大的不同是在回收时不仅回收新生代 Region, 还会回收并发标记中识别出的垃圾多的老年代 Region。Mixed GC 可能会发生多次，因为 G1 对停顿时间是有要求的，G1 会根据预测的停顿时间决定一次回收多少个老生代 Region，所以可能需要多次 Mixed GC，才能完成并发标记阶段识别出的垃圾比较多的老生代 Region 的回收。

Mixed GC 的触发时机其实是由一些参数控制的:

- G1HeapWastePercent: 在并发标记结束之后, 可以知道老年代 Region 中有多少空间要被回收, 在每次 Yong GC 之后和再次发生 Mixed GC 之前, 会检查垃圾占比是否达到此参数, 只有达到了, 下次才会发生 Mixed GC
- G1MixedGCLiveThresholdPercent: 老年代 Region 中的存活对象的占比, 只有在此参数之下, 才会被选入 CSet
- G1MixedGCCountTarget: 一次 global concurrent marking 之后, 最多执行 Mixed GC 的次数
- G1OldCSetRegionThresholdPercent: 一次 Mixed GC 中能被选入 CSet 的最多老年代 Region 数量

## Full GC

Mixed GC 只能回收部分老年代的 Region, 如果 Mixed GC 实在无法跟上程序分配内存的速度, 导致老年代填满无法继续进行 Mixed GC, 就会触发 Full GC 来回收整个堆。Full GC 时，也需要 STW 对整个内存进行串行回收。在 JDK 10 中对 Full GC 做了改进，把串行回收改进成并行回收。

## RSet

G1 使用 RSet 避免全堆作为根集合扫描, 每个 Region 都维护有自己的 RSet, 这些 RSet 会记录下别的 Region 指向自己的指针, 并标记这些指针分别在哪些卡页的范围之内。由于 Region 数量比传统收集器的分代数量更多, 因此 G1 收集器要比其他的传统垃圾回收器有着更高的内存占用, G1 至少要耗费大约相当于 Java 堆容量 10%至 20%的额外内存来维持收集器工作。

## 与 CMS 对比

与 CMS 的标记-清除算法不同, G1 从整体来看是基于标记-整理算法实现的, 但从局部(两个 Region 之间)上看又是基于标记-复制算法实现, 所以 G1 运行期间不会产生内存空间碎片, 有利于程序长时间运行, 在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次 GC。

比起 CMS, G1 的适用对象被限定为搭载多核处理器、拥有大容量内存的机器。就内存占用来说, 虽然 G1 和 CMS 都使用卡表来处理跨代指针, 但 G1 的卡表实现更为复杂, 而且堆中每个 Region 都必须有一份卡表, 这导致 G1 的 RSet 会占整个堆容量的更多内存空间。相比起来 CMS 的卡表就相当简单, 只有一份, 而且只需要处理老年代到新生代的引用。

在执行负载的角度上, 两个收集器都使用到写屏障, CMS 用写后屏障来更新维护卡表, 而 G1 除了使用写后屏障来进行卡表维护操作外, 为了实现原始快照搜索(SATB)算法, 还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法, 原始快照搜索能够减少并发标记和重新标记阶段的消耗, 避免 CMS 那样在最终标记阶段停顿时间过长的缺点, 但是在用户程序运行过程中会产生由跟踪引用变化带来的额外负担。由于 G1 对写屏障的复杂操作要比 CMS 消耗更多的运算资源, 所以 CMS 的写屏障实现是直接的同步操作, 而 G1 就需要将其实现为类似于消息队列的结构, 把写前屏障和写后屏障中要做的事情都放到队列里, 然后再异步处理。
