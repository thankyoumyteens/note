# GarbageFirst收集器

JDK 9发布时，Garbage First(简称G1)收集器取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，并且不再推荐使用CMS收集器。

在G1收集器出现之前的所有其他收集器，垃圾收集的目标范围要么是整个新生代(Minor GC)，要么就是整个老年代(Major GC)，再要么就是整个Java堆(Full GC)。而G1可以面向堆内存任何部分来组成回收集(Collection Set)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域的动态集合。G1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，作为新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。而对于那些超过了整个Region容量的大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。

![](../../img/g1_region.png)

G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的比值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region，这也就是Garbage First名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。

---

G1使用记忆集避免全堆作为GC Roots扫描，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的是卡表的索引号。由于Region数量比传统收集器的分代数量更多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。

对于并发标记阶段的漏标问题，G1使用了原始快照(SATB)算法来解决。对于在并发标记时，用户线程可能会创建对象的情况，G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针，把Region中的一部分空间划分出来用于并发标记过程中的新对象分配，并发标记时新分配的对象地址都必须要在这两个指针的范围内，G1收集器默认在这个地址内的对象是存活的，不纳入回收范围。

与CMS类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC。

用户可以通过-XX:MaxGCPauseMillis参数指定垃圾收集允许的停顿时间。G1收集器的停顿预测模型是以衰减均值(Decaying Average)为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表最近的平均状态，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过用户期望停顿时间的约束下获得最高的收益。

## G1收集器的回收过程

1. 初始标记(Initial Marking)：只标记GC Roots，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短
2. 并发标记(Concurrent Marking)：和CMS的并发标记类似，从GC Root开始扫描整个堆里的对象图，找出要回收的对象。这阶段耗时较长，但不需要暂停用户线程
3. 最终标记(Final Marking)：和CMS的重新标记类似，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段也会暂停用户线程
4. 筛选回收(Live Data Counting and Evacuation)：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所指定的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region中存活的对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条收集器线程并行完成

![](../../img/g1.png)
