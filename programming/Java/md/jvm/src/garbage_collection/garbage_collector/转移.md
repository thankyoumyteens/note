# 转移

通过转移，所选Region内的所有存活对象都会被转移到空闲Region。这样一来，被转移的Region内就只剩下死亡对象。重置之后，该Region就会成为空闲Region，能够再次利用。

![](../../img/g1bm8.png)

## 记忆集

SATB队列集合主要用来记录标记过程中对象之间引用关系的变化，而不同Region之间的引用关系则使用记忆集来记录。记忆集中记录了来自其他Region的引用，因此在转移时即使不扫描所有Region内的对象，也可以查到它被其他Region引用的情况，从而简化单个Region的转移处理。

### 卡表

G1是通过卡表来实现记忆集的。卡表是由元素大小为1B的数组实现的，卡表里的元素称为卡片。一个卡片对应着堆中的一段内存空间，这段内存空间被称作卡页。在当前的JDK中，这个大小被定为512B。因此，当堆的大小是1GB时，可以计算出卡表的大小就是2MB。一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象的字段存在着跨代指针，那么就将对应卡片称为脏卡片。

堆中的对象所对应的卡片在卡表中的索引值可以通过公式快速计算出来：(对象的地址 － 堆的头部地址) ／ 512。

![](../../img/g1bm9.png)

### 转移专用记忆集

每个Region中都有一个转移专用的记忆集，它是通过哈希表实现的。哈希表的key是其他Region的地址，value是key指向的Region中的卡片索引集合。

Region间对象的引用关系是由转移专用记忆集合以卡片为单位粗略记录的。因此，在转移时必须扫描被记录的卡片所对应的全部对象的引用。

![](../../img/g1bm10.png)

### 写屏障

当对象的字段被修改时，被修改对象所对应的卡片的索引会被写屏障记录到转移专用记忆集中。写屏障的伪代码：

```c++
/**
 * obj 表示field所在的对象
 * field 表示对象中被修改的字段
 * newobj 表示要引用的新对象
 * 如果obj中的字段field引用的其他Region的对象，则obj对应的卡片变脏
 */
void evacuation_write_barrier(obj, field, newobj) {
    // 检测两个对象地址的高位部分是否相等
    // 每个Region都是按固定大小进行分配的，如果obj和newobj的地址在同一个Region中，
    // 那么由于两个地址中超过Region大小的高位部分是完全相等的，
    // 所以变量check的值小于Region的大小。
    check = obj ^ newobj;
    // Region的大小必须是2的指数幂，指数就是LOG_OF_HEAP_REGION_SIZE
    // 将check右移LOG_OF_HEAP_REGION_SIZE后，小于Region大小的比特值都会归0，
    // 这样一来，如果check的值小于Region大小，右移之后的结果就会变为0
    check = check >> LOG_OF_HEAP_REGION_SIZE;
    if (newobj == NULL) {
        check = 0;
    }
    // check为0表示obj和newobj在同一个Region中
    if (check == 0) {
        return;
    }
    // 函数 is_dirty_card() 用来检查参数 obj 所对应的卡片是否为脏卡片
    // 脏卡片指的是已经被写屏障添加到转移专用记忆集日志中的卡片
    // 该行的检查就是为了避免向转移专用记忆集日志中添加重复的卡片
    // 相反，不在转移专用记忆集日志中的卡片是净卡片
    // 如果是净卡片，则该卡片将变成脏卡片，然后被添加到队列rs_log中
    if (!is_dirty_card(obj)) {
        to_dirty(obj);
        enqueue(current_thread.rs_log, obj);
    }
    *field = newobj;
}
```

### 转移专用记忆集日志

每个用户线程都持有一个名为转移专用记忆集日志的缓冲区，其中存放的是卡片索引的数组。当对象b的字段被修改时，写屏障就会获知，并会将对象b所对应的卡片索引添加到转移专用记忆集日志中。转移专用记忆集合日志是由各个用户线程持有的，所以在添加时不用担心线程之间的竞争，写屏障不需要进行互斥处理，因而具有更好的性能。转移专用记忆集日志会在写满后被添加到全局的转移专用记忆集日志的集合中。这个添加过程可能存在多个线程之间的竞争，所以需要做互斥处理。添加完成后，用户线程会被重新分配一个空的转移专用记忆集日志。

![](../../img/g1bm11.png)

### 转移专用记忆集的维护线程

转移专用记忆集的维护线程是和用户线程并发执行的线程，它的作用是基于转移专用记忆集日志的集合，来维护转移专用记忆集。它主要进行以下处理：

1. 从转移专用记忆集日志的集合中取出转移专用记忆集日志，从头开始扫描
2. 将卡片变为净卡片
3. 检查卡片所对应存储空间内所有对象的字段
4. 往字段所指向的Region的记忆集中添加卡片

如果卡片在3和4的处理过程中被用户线程修改了，那么又会变成脏卡片，然后再次被添加到转移专用记忆集日志中。在转移专用记忆集日志的集合中，当日志的数量超过阈值(默认为5个)时，维护线程就会启动，然后一直处理到数量降至阈值的1/4以下。

### 热卡片

频繁发生修改的存储空间所对应的卡片称为热卡片(hot card)。热卡片可能会多次被维护线程处理成脏卡片，从而加重维护线程的负担。识别热卡片，需要用到卡片计数表，它记录了卡片变成脏卡片的次数。卡片计数表记录了自上次转移以来哪个卡片变成了脏卡片，以及变成脏卡片的次数，其内容会在下次转移时被清空。

变成脏卡片的次数超过阈值(默认是4)的卡片会被当成热卡片，在被处理为脏卡片后添加到热队列尾部。热队列的大小是固定的(默认是1KB)。如果队列满了，则从队列头部取出卡片，给新的卡片腾出位置。取出的卡片由维护线程当作普通卡片处理。

热队列中的卡片不会被维护线程处理，因为即使处理了，它也有可能马上又变成脏卡片。因此，热队列中的卡片会被留到转移的时候再处理。

## 转移的执行步骤

转移的执行步骤：

1. 选择回收集：参考并发标记提供的信息来选择被转移的Region。被选中的Region称为回收集(collection set)
2. 根转移：将回收集内由GC Root直接引用的对象，以及被其他Region引用的对象转移到空闲Region中
3. 转移： 以根转移中转移的对象为起点扫描其子孙对象，将所有存活对象一并转移

这3个步骤都是暂停处理，步骤2和3是可以由多个线程并行执行。在转移开始后，即使并发标记正在进行也会先中断，而优先进行转移处理。

### 选择回收集

回收集的选择标准有两个：

1. 转移效率高
2. 转移的预测暂停时间在用户的容忍范围内

在选择回收集合时，堆中的Region已经在并发标记的收尾工作中按照转移效率被降序排列了。

接下来，按照排好的顺序依次计算各个Region的预测暂停时间，并选择回收集。当所有已选Region预测暂停时间的总和快要超过用户的容忍范围时，后续Region的选择就会停止，所有已选Region成为1个回收集。

在多数情况下，垃圾越多，Region的转移效率就越高，因此G1会优先选择垃圾多的Region进入回收集。这就是Garbage First名称的由来。

### 根转移

根转移的转移对象包括：

1. 由GC Root直接引用的对象
2. 并发标记处理中的对象
3. 回收集内由其他Region中的对象直接引用的的对象

```c++
void evacuate_roots() {
    // 把回收集中被GC Root引用的对象转移到其他的空闲Region
    for (r in roots) {
        if (is_into_collection_set(*r)) {
            // 更新指针，指向转移后的地址
            // evacuate_obj()用于转移对象，
            // 它的返回值是转移后对象的地址
            *r = evacuate_obj(r);
        }
    }
    // 将未被转移专用记忆集维护线程扫描的脏卡片更新到转移专用记忆集中
    // 1. 各个用户线程的转移专用记忆集日志
    // 2. 转移专用记忆集日志的集合
    // 3. 热卡片
    // 转移专用记忆集的更新是并发进行的。
    // 在转移开始时，转移专用记忆集的维护线程很可能还没处理结束，
    // 因此需要将1和2中的脏卡片更新到转移专用记忆集中
    force_update_rs();
    // 转移被其他Region引用的对象
    for (region in collection_set) {
        // rs_cards中保存了Region的转移专用记忆集中的所有卡片
        for (card in region.rs_cards) {
            scan_card(card);
        }
    }
}
// 扫描转移专用记忆集中的卡片所对应的卡页中的每个对象
// 如果某对象存在对回收集内对象的引用，那么该对象也会被转移
// 如果卡页中的对象是未被标记的，那么其子对象不会继续被扫描
void scan_card(card) {
    for (obj in objects_in_card(card)) {
        if (is_marked(obj)) {
            for (child in children(obj)) {
                if (is_into_collection_set(*child)) {
                    // 更新指针，指向转移后的地址
                    *child = evacuate_obj(child);
                }
            }
        }
    }
}
```

***转移对象的过程***

1. 将对象a转移到空闲Region

2. 将对象a在空闲Region中的新地址写入到转移前所在Region中的旧位置。保存在旧位置的这个新地址称为forwarding指针。在垃圾回收期间，当其他对象引用原始位置的对象时，G1会通过forwarding指针将引用重定向到新位置。这样可以确保程序在垃圾回收后，仍然能够正确地访问对象

3. 将对象a引用的所有位于回收集内的对象都添加到转移队列中。转移队列用来临时保存待转移对象的引用方。a'.field1引用了对象b，而且b所在的Region在回收集中。因为a'是存活对象，所以a'引用的对象b也是存活对象。这样一来，对象b就成了回收集中的待转移对象，它的引用方a'.field1 会被添加到转移队列中。之所以往转移队列中添加a'.field1而不是b，是因为我们必须要在转移完b之后将新的地址写入到a'.field1中

4. 针对对象a引用的位于回收集外的对象，更新转移专用记忆集。a'.field2引用了对象c，而c所在的Region不在回收集中。c所在Region的转移专用记忆集中虽然记录了a.field2对应的卡片，但是a被转移到了a'，所以有必要更新转移专用记忆集。a'.field2对应的卡片被添加到了c所在Region的转移专用记忆集中

5. 针对对象a的引用方，更新转移专用记忆集。对象转移时只有1个引用方能够以参数的形式进行传递。a的引用方是d.field1。d.field1指向的是a的地址，但是a被转移到了a'，所以有必要让d.field1指向a'的地址。d.field1对应的卡片被添加到了a'所在Region的转移专用记忆集中

6. 对象转移最终返回的是转移后的地址。在调用转移的地方，返回的地址会被赋值给引用方。d.field1的地址被替换成了对象a'的地址

