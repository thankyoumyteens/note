# Javac编译器

Javac编译过程大致可以分为1个准备过程和3个处理过程：

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程，包括：
    - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树
    - 填充符号表。产生符号地址和符号信息
3. 插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段
4. 分析与字节码生成过程，包括：
    - 标注检查。对语法的静态信息进行检查
    - 数据流及控制流分析。对程序动态运行过程进行检查
    - 解语法糖。将简化代码编写的语法糖还原为原有的形式
    - 字节码生成。将前面各个步骤所生成的信息转化成字节码

# 解析与填充符号表

## 词法、语法分析

词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。

关键字、变量名、字面量、运算符都可以作为标记，如`int a=b+2`这句代码中就包含了6个标记，分别是`int`、`a`、`=`、`b`、`+`、`2`，虽然关键字int由3个字符构成，但是它只是一个独立的标记，不可以再拆分。

语法分析是根据标记序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree，AST)是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构(SyntaxConstruct)，例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。

经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。

## 填充符号表

符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构，类似哈希表中键值对的存储形式，符号表中所登记的信息在编译的不同阶段都要被用到。比如在语义分析的过程中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。

如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性与当前类型一致的默认构造函数。

# 注解处理器

JDK 5之后，Java语言提供了对注解(Annotations)的支持，注解原本只会在程序运行期间发挥作用。但在JDK 6中又提出了一组被称为插入式注解处理器的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。

插入式注解处理器可以看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次(Round)。

# 语义分析与字节码生成

经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，比如进行类型检查、控制流检查、数据流检查，等等。

Javac在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤。

## 标注检查

标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等。

在标注检查中，还会顺便进行一个称为常量折叠(Constant Folding)的代码优化。如`int a=b+2`在经过常量折叠优化之后，它们将会被折叠为字面量`3`。

## 数据及控制流分析

数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。

## 解语法糖

语法糖(Syntactic Sugar)，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。使用语法糖能够减少代码量、增加程序的可读性，从而减少程序代码出错的机会。

Java中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖。

## 字节码生成

字节码生成是Javac编译过程的最后一个阶段，字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。

实例构造器`<init>()`方法和类构造器`<clinit>()`方法就是在这个阶段被添加到语法树之中的。`<init>()`和`<clinit>()`这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块、变量初始化、调用父类的实例构造器等操作收敛到`<init>()`和`<clinit>()`方法之中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行。

除了生成构造器以外，还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为StringBuffer或StringBuilder的append()操作，等等。

完成了对语法树的遍历和调整之后，就会生成最终的Class文件，到此，整个编译过程宣告结束。
