# 提前编译器

Java提前编译器是指将Java源代码在运行之前提前编译成本地机器码的工具。与传统的Java虚拟机执行方式不同，提前编译器将Java代码直接编译成可执行的机器码，而无需在运行时通过即时编译器将字节码转换为机器码。

## 传统的提前编译

传统的提前编译类似于C/C++的编译器，在程序运行之前把程序代码编译成机器码。

在程序运行之前进行的静态编译，可以采取许多原本在HotSpot即时编译中并不会做的全程序优化措施，使用更多的编译时间以获得更好的运行时性能。

## 动态提前编译

动态提前编译(Dynamic AOT)或者叫即时编译缓存(JIT Caching)是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用。动态提前编译已经完全被主流的商用JDK支持。

JDK 9中所带的Jaotc提前编译器让用户可以针对目标机器，为应用程序进行提前编译。HotSpot运行时可以直接加载这些编译的结果，实现加快程序启动速度，减少程序达到全速运行状态所需时间的目的。

各种Java应用最起码会用到Java的标准类库，如java.base等模块，如果能够将这个类库提前编译好，并进行比较高质量的优化，显然能够节约不少应用运行时的编译成本。但实际应用起来并不是那么容易，原因是这种提前编译方式不仅要和目标机器相关，甚至还必须与HotSpot虚拟机的运行时参数绑定。比如虚拟机运行时采用了不同的垃圾收集器，这原本就需要即时编译子系统的配合才能正确工作，要做提前编译的话，自然也要配合这些工作。

# 即时编译器的优势

- 性能分析制导优化(Profile-Guided Optimization，PGO)。在解释器或者客户端编译器运行过程中，会不断收集性能监控信息，比如条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，这些数据一般只有在动态运行时才可以精确计算。如果一个条件分支的某一条路径执行特别频繁，而其他路径很少执行，那就可以把热的代码集中放到一起，集中优化和分配更好的资源给它。
- 激进预测性优化(Aggressive Speculative Optimization)。即时编译可以按照监控结果做一些激进的优化，如删除执行概率低的代码，即使真的走到罕见分支上，也可以退回到低级编译器或解释器上去执行。而静态编译时做这种激进的优化可能会导致程序报错或者结果不对。
- 链接时优化(Link-Time Optimization，LTO)，在使用提前编译的语言和程序上，主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码。当出现跨链接库边界的调用时，那些理论上应该要做的优化，如这种跨越动态链接库的方法内联，就会执行起来相当的困难。
