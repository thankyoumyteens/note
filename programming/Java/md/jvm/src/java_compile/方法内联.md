# 方法内联

方法内联(Method Inlining)是一种编译器优化技术，它将被调用方法的代码直接插入到调用处，以避免方法调用的开销。通过内联，可以减少方法调用的额外开销，如参数传递、栈帧的创建和销毁等，从而提高程序的执行效率。在多数情况下Java虚拟机进行的方法内联都是一种激进优化。

在Java中，只有使用invokespecial、invokestatic指令调用的方法和被final修饰的方法才会在编译期进行解析。其他的Java方法都必须在运行时才能确定调用方法的对象。对于一个虚方法的调用，是根据实际类型动态分派的，而实际类型必须在实际运行到这一行代码时才能确定，编译器很难在编译时确定。

为了支持虚方法的内联，JVM引入了类型继承关系分析(Class Hierarchy Analysis，CHA)技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。

这样，编译器在进行内联时就会分不同情况采取不同的处理：如果是非虚方法，那么直接进行内联就可以了。如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设此方法一直是只有一个版本而进行内联，这种内联被称为守护内联(Guarded Inlining)。

不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类从而改变CHA的结论，因此这种内联属于激进预测性优化，必须预留当假设条件不成立时的退路(Slow Path)。假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的调用方的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。

假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器会使用内联缓存(Inline Cache)的方式来缩减方法调用的开销。内联缓存是一个建立在目标方法正常入口之前的缓存，在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法调用方的版本信息，并且每次进行方法调用时都比较调用方的版本。如果每次的调用方版本都是一样的，那么这时它就是一种单态内联缓存(Monomorphic Inline Cache)。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。如果出现方法调用方不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存(Megamorphic Inline Cache)，其开销相当于真正查找虚方法表来进行方法分派。
