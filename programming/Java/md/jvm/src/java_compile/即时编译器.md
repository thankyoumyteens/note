# 即时编译器

目前主流的商用Java虚拟机，内部都同时包含解释器与编译器。

当程序需要迅速启动和执行的时候，解释器可以省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器可以把越来越多的代码编译成本地代码，以减少解释器的中间损耗，获得更高的执行效率。

当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时，可以让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时可以通过逆优化退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作。

HotSpot虚拟机中内置了两个即时编译器，分别被称为客户端编译器(Client Compiler)和服务端编译器(Server Compiler)，简称为C1编译器和C2编译器。

在分层编译出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用`-client`或`-server`参数指定虚拟机运行在客户端模式还是服务端模式。

解释器与编译器搭配使用的方式在虚拟机中被称为混合模式(Mixed Mode)，用户可以使用参数`-Xint`强制虚拟机运行于解释模式(Interpreted Mode)，全部代码都使用解释方式执行。也可以使用参数`-Xcomp`强制虚拟机运行于编译模式(Compiled Mode)，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。

为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译(Tiered Compilation)功能，分层编译在JDK 7的服务端模式虚拟机中作为默认编译策略被开启。

分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次：

- 第0层。程序纯解释执行，并且解释器不开启性能监控功能
- 第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能
- 第2层。使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能
- 第3层。使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息
- 第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化

# 热点代码

在运行过程中会被即时编译器编译的目标是热点代码，热点代码主要有两类：

- 被多次调用的方法
- 被多次执行的循环体

