# 方法调用

方法调用阶段唯一的任务就是确定要调用哪一个方法。

主要的方法调用形式：解析和分派。

# 解析

在类加载过程中的解析(Resolution)阶段，JVM会将字节码文件里的一部分符号引用转化为直接引用，这些方法是在编译那一刻就已经确定下来，并且在JVM运行期间是不会改变的。这类方法的调用被称为解析(Resolution)。

符合“编译期可知，运行期不可变”要求的方法，主要有静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。

# JVM调用方法的指令

- invokestatic：用于调用静态方法
- invokespecial：用于调用实例构造器`<init>()`方法、私有方法和父类中的方法
- invokevirtual：用于调用所有的虚方法
- invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象
- invokedynamic：先在运行时动态解析出所引用的方法，然后再执行该方法

# 虚方法

只要能被invokestatic和invokespecial指令调用的方法，都是符合“编译期可知，运行期不可变”要求的方法。

Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法(子类中通过super.xxx()调用)、被final修饰的方法，这5种方法调用会在类加载的时候就可以把符号引用解析为直接引用。这些方法统称为非虚方法(Non-Virtual Method)。与之相反，其他方法就被称为虚方法(Virtual Method)。

其中被final修饰的方法比较特殊，由于历史设计的原因，它使用invokevirtual指令调用。

# 分派

分派（Dispatch）调用可能是静态的也可能是动态的。

## 静态分派

演示
```java
public class StaticDispatch {
    static abstract class Human {}

    static class Man extends Human {}

    static class Woman extends Human {}

    public void sayHello(Human guy) {
        System.out.println("hello,guy!");
    }

    public void sayHello(Man guy) {
        System.out.println("hello,gentleman!");
    }

    public void sayHello(Woman guy) {
        System.out.println("hello,lady!");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}
```

程序运行结果：

```
hello,guy!
hello,guy!

Process finished with exit code 0
```

Human man = new Man() 这行代码中的Human称为变量的静态类型(Static Type)，或者叫外观类型(Apparent Type)，后面的Man则被称为变量的实际类型(Actual Type)或者叫运行时类型(Runtime Type)。

静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

```java
// 实际类型变化，编译时无法确定
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
// 静态类型变化，即使强制转型，编译时也可以确定
sr.sayHello((Man) human)
sr.sayHello((Woman) human)
```

main()里面的两次sayHello()方法调用，使用哪个重载版本，取决于传入参数的数量和数据类型。

代码中故意定义了两个静态类型相同，而实际类型不同的变量，但方法在重载时是通过参数的静态类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段，编译器就可以根据参数的静态类型决定使用哪个重载版本，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。

![](./img/static_dispatch.png)

所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型的应用就是方法重载。

静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

注意：解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。

## 动态分派

演示
```java
public class DynamicDispatch {

    static abstract class Human {
        protected abstract void sayHello();
    }

    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        }
    }

    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```

程序运行结果：

```
man say hello
woman say hello
woman say hello

Process finished with exit code 0
```

上面代码编译后的字节码使用`javap -verbose DynamicDispatch.class`命令解析后如下：

![](./img/dynamic_dispatch.png)

```
0: new           #2                  // class DynamicDispatch$Man
3: dup
4: invokespecial #3                  // Method DynamicDispatch$Man."<init>":()V
7: astore_1
8: new           #4                  // class DynamicDispatch$Woman
11: dup
12: invokespecial #5                  // Method DynamicDispatch$Woman."<init>":()V
15: astore_2
```

上面的指令为man和woman分配内存空间，并把两个变量放入局部变量表。

`16: aload_1`和`20: aload_2`表示把局部变量表的两个变量分别压入栈顶。

invokevirtual指令的运行过程:

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验。如果通过，则返回这个方法的直接引用，查找过程结束。不通过则返回java.lang.IllegalAccessError异常
3. 如果没有匹配的方法，则按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本。

Java实现多态的根源就在于虚方法调用指令invokevirtual的执行逻辑。

这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

## 单分派与多分派

