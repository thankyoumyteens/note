# 方法区

方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。如果方法区无法满足新的内存需求时，将抛出OutOfMemoryError异常。

---

类型信息包括：类(class)、接口(interface)、枚举(enum)、注解(annotation)、域(Field)、方法(Method)。

# 运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。进入运行时常量池后，这些字面量与符号引用就会被分配内存地址，符号引用也会变成直接引用。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，并非只有Class文件中常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中，比如String类的intern()方法。

当运行时常量池无法再申请到内存时会抛出OutOfMemoryError异常。

# Java8使用元空间替换永久代

永久代(Permanent Generation)是在JVM堆中分配的，空间有限，当加载过多的类或者常量的时候，就可能导致永久代的空间不足，抛出OutOfMemoryError异常。而JVM加载的class的总数，方法的大小等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张。

到了JDK 7，已经把原本放在永久代的字符串常量池、静态变量等移出到堆中。

到了JDK 8，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间(Metaspace)，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。由于元空间使用的是本地内存，而不是JVM内存，其大小只受限于操作系统的实际可用内存，大大减少了内存溢出的可能性。

# 垃圾收集

《Java虚拟机规范》不要求虚拟机在方法区中必须实现垃圾收集。

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

回收废弃常量与回收Java堆中的对象非常类似。假如一个字符串java曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是java，换句话说，已经没有任何字符串对象引用常量池中的java常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个java常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。

判定一个类型是否不再被使用需要同时满足下面三个条件：

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
2. 加载该类的类加载器已经被回收，这个条件通常是很难达成的。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。
