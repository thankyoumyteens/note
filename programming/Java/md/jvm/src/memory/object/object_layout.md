# 对象的内存布局

在 HotSpot 虚拟机里, 对象在堆中的存储布局可以划分为三个部分: 对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。

## 对象头

对象头包括两类信息。

### Mark Word

第一类是用于存储对象自身的运行时数据, 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等, 这部分数据的长度在 32 位和 64 位的 JVM 中分别为 32 个比特和 64 个比特, 称为 Mark Word。

对象需要存储的运行时数据很多, 其实已经超出了 32、64 位 Bitmap 结构所能记录的最大限度, 为了在极小的空间内存储尽量多的数据, Mark Word 被设计成一个有着动态定义的数据结构, 以便根据对象的状态复用自己的存储空间。

在 32 位的 HotSpot 虚拟机中, 如果对象处于无锁状态下, Mark Word 的 25 位用于存储对象哈希码, 4 位用于存储对象分代年龄, 2 位用于存储锁标志位, 1 位固定为 0。而在其他状态下, 不同的比特表示的数据与对象未被同步锁锁定的状态下也不同。

![](../../img/mark_word_32.jpg)

### 元数据指针

对象头的另外一部分是元数据指针, 即对象指向它的类的元数据的指针, 类的元数据描述了这个类的各种信息, JVM 通过这个指针来确定该对象是哪个类的实例。

并不是所有的虚拟机实现都必须在对象数据上保留类型指针, 查找对象的元数据信息并不一定要经过对象本身。此外, 如果对象是一个 Java 数组, 那在对象头中还必须有一块用于记录数组长度的数据, 因为 JVM 可以通过类的元数据信息确定 Java 对象的大小, 但是如果不知道数组的长度, 将无法通过元数据中的信息推断出数组的大小。

## 实例数据

实例数据部分是对象真正存储的有效信息, 即代码里面所定义的各种类型的字段内容, 无论是从父类继承下来的, 还是在子类中定义的字段都必须记录起来。

这部分的存储顺序会受到 JVM 参数 -XX:FieldsAllocationStyle 和字段在 Java 源码中定义的顺序的影响。

HotSpot 默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、对象指针(Ordinary Object Pointers, OOPs), 相同宽度的字段总是被分配到一起存放, 在满足这个前提条件的情况下, 在父类中定义的变量会出现在子类之前。如果 +XX:CompactFields 参数的值为 true(默认就为 true), 那子类之中较窄的变量也允许插入父类变量的空隙之中, 以节省空间。

## 对齐填充

对齐填充仅仅用作占位符。由于 HotSpot 要求任何对象的大小都必须是 8 字节的整数倍。对象头部分已经被精心设计成正好是 8 字节的倍数, 因此, 如果对象实例数据部分没有对齐的话, 就需要通过对齐填充来补全。
