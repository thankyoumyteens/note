# 方法区

方法区(Method Area)与 Java 堆一样, 是各个线程共享的内存区域, 它用于存储已被 JVM 加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。如果方法区无法满足新的内存需求时, 将抛出 OutOfMemoryError。

类型信息包括: 类(class)、接口(interface)、枚举(enum)、注解(annotation)、字段(Field)、方法(Method)。

## 运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分。字节码文件中除了有类的版本、字段、方法、接口等描述信息外, 还有一项信息是常量池表(Constant Pool Table), 用于存放编译期生成的各种字面量与符号引用, 这部分内容将在类加载后存放到方法区的运行时常量池中。进入运行时常量池后, 这些字面量与符号引用就会被分配内存地址, 符号引用也会变成直接引用。

运行时常量池相对于字节码文件常量池的另外一个重要特征是具备动态性, 并非只有字节码文件中常量池的内容才能进入运行时常量池, 运行期间也可以将新的常量放入池中, 比如 String 类的 intern()方法。

String::intern() 是一个 native 方法, 它的作用是: 如果字符串常量池中已经包含一个等于此 String 对象的字符串, 则返回字符串常量池中这个字符串的 String 对象的引用。否则, 会将此 String 对象创建的字符串添加到字符串常量池中, 并且返回此 String 对象的引用。

当运行时常量池无法再申请到内存时会抛出 OutOfMemoryError。

## 字符串常量池

在 Java 中, 字符串的创建是比较频繁的, 而字符串的分配和其他对象的分配是类似的, 需要耗费大量的时间和空间, 从而影响程序的运行性能。JVM 为了提高性能和减少内存开销, 在实例化字符串常量的时候进行了一些优化。

JVM 在运行时数据区中为字符串开辟了一块存储空间, 称为字符串常量池(String Pool)。在创建字符串常量时, 首先查找字符串常量池中是否存在该字符串, 如果存在该字符串, 就返回引用实例, 如果不存在, 则实例化该字符串并放入字符串常量池中。

## 元空间替换永久代

永久代(Permanent Generation)是在堆中分配的, 空间有限, 当加载过多的类或者常量的时候, 就可能导致永久代的空间不足, 抛出 OutOfMemoryError。而 JVM 加载的 class 的总数, 方法的大小等都很难确定, 因此很难配置永久代的大小。太小的永久代容易导致永久代内存溢出, 太大的永久代则容易导致虚拟机内存紧张。

在 JDK 7 时, 已经把原本放在永久代中的字符串常量池、静态变量等移出到堆中。

到了 JDK 8, 终于完全废弃了永久代的概念, 改用在本地内存中实现的元空间(Metaspace), 把 JDK 7 中永久代还剩余的内容(主要是类型信息)全部移到元空间中。由于元空间使用的是本地内存, 而不是 JVM 内存, 其大小只受限于操作系统的实际可用内存, 大大减少了内存溢出的可能性。

## 方法区的垃圾收集

《Java 虚拟机规范》不要求虚拟机在方法区中必须实现垃圾收集。

方法区的垃圾收集主要回收两部分内容: 废弃的常量和不再使用的类型。

回收废弃常量与回收 Java 堆中的对象非常类似。假如一个字符串"java"曾经进入常量池中, 但是当前系统已经没有任何字符串对象引用常量池中的"java"常量, 且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收, 而且垃圾回收器判断确有必要的话, 这个"java"常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。

判定一个类型是否不再被使用需要同时满足下面三个条件: 

1. 该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类及其任何派生子类的实例。
2. 加载该类的类加载器已经被回收, 这个条件通常是很难达成的。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib 等字节码框架, 动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中, 通常都需要 JVM 具备类型卸载的能力, 以保证不会对方法区造成过大的内存压力。
