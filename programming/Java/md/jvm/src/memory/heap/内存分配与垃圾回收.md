# 内存分配与垃圾回收

大多数情况下，对象在新生代Eden区中分配。每当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

Minor GC(Young GC)是指清理新生代内存区域的垃圾回收，只涉及到新生代中的对象。当Eden区满时，会触发Minor GC。垃圾收集器会检查Eden区和SurvivorFrom区的所有对象，把其中存活的对象复制到SurvivorTo区，然后直接清空Eden区和SurvivorFrom区。最后会把SurvivorFrom区和SurvivorTo区的定义交换，即原来的SurvivorFrom区变成了SurvivorTo区，原来的SurvivorTo区变成了SurvivorFrom区。

![](../../img/minorgc.jpg)

如果经过第一次Minor GC后仍然存活，并且能被SurvivorTo容纳的话，该对象会被移动到SurvivorTo中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被移动到老年代中。另外，如果一个对象超过了一定大小，会直接被分配在老年代，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。

如果老年代也放不下了，这个时候会触发Major GC / Full GC。不同的虚拟机实现可能有不同的GC算法和策略，因此触发的具体GC类型可能会有所不同。

当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出OutOfMemoryError。

Major GC是指清理老年代内存区域的垃圾回收，只涉及到老年代中的对象。Major GC的速度一般会比Minor GC慢10倍以上，程序暂停时间更长。在Major GC过程中，虚拟机会检查老年代中的对象是否存活，并清理老年代中的无用对象。Major GC执行时，通常会先做一次Minor GC，再紧接着进行Major GC。只有CMS收集器会只收集老年代。

Full GC是在堆内存不足时触发的对整个堆内存进行的垃圾回收，当新生代和老年代内存区域都满了的时候，就会触发Full GC。此外，当方法区满了，或者系统空闲时间比较长时，也可能会触发Full GC。在进行 Full GC 时，虚拟机可能会检查并回收不再使用的类的元数据信息，从而释放一些元空间。但是，这取决于具体的虚拟机实现和配置设置，不同的虚拟机可能有不同的行为。一般来说，Full GC 主要是针对堆内存的垃圾回收，而对于元空间的回收，虚拟机会有专门的机制来进行管理和回收。
