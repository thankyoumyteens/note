# 动态类型语言

JDK 7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。

```js
var arrays = {"abc", new ObjectX(), 123, Dog, Cat, Car..}
for(item in arrays){
    item.sayHello();
}
```

由于在运行时arrays中的元素可以是任意类型，即使它们的类型中都有sayHello()方法，也无法在编译优化的时候就确定具体sayHello()的代码在哪里，编译器只能不停编译它所遇见的每一个sayHello()方法，并缓存起来供执行时选择、调用和内联，如果arrays数组中不同类型的对象很多，就势必会对内联缓存产生很大的压力，缓存的大小总是有限的，类型信息的不确定性导致了缓存内容不断被失效和更新，先前优化过的方法也可能被不断替换而无法重复使用。

JDK 7时新加入的java.lang.invoke包提供了一种新的动态确定目标方法的机制，称为方法句柄(Method Handle)。

例如要实现一个用户自定义顺序的排序函数，在C/C++中可以用函数指针来把排序函数传递到sort中：

```c
void sort(int list[], int (*compare)(int, int))
```

但在Java中没有办法单独把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现这个接口的对象作为参数：

```java
void sort(List list, Comparator c)
```

# 方法句柄

```java
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;

public class MethodHandleTest {
    static class ClassA {
        public void println(String s) {
            System.out.println("ClassA " + s);
        }
    }

    private static MethodHandle getPrintlnMH(Object obj) throws Throwable {
        // MethodType：方法类型，第一个参数是方法的返回值，第二个及以后的参数是方法的具体参数
        MethodType methodType = MethodType.methodType(void.class, String.class);
        // lookup()方法在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄
        // bindTo()方法绑定this指向的对象
        return MethodHandles.lookup().findVirtual(obj.getClass(), "println", methodType).bindTo(obj);
    }

    public static void main(String[] args) throws Throwable {
        Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();
        getPrintlnMH(obj).invokeExact("icyfenix");
    }
}
```

findVirtual方法模拟了invokevirtual指令的执行过程。MethodHandle对象类似一个函数指针。有了MethodHandle就可以写出类似于C/C++那样的函数声明了：

```java
void sort(List list, MethodHandle compare)
```

方法句柄与反射的些区别：

- 反射和方法句柄机制本质上都是在模拟方法调用，但是反射是在模拟Java代码层次的方法调用，而方法句柄是在模拟字节码层次的方法调用。
- MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()分别对应了invokestatic、invokevirtual/invokeinterface和invokespecial指令的执行权限校验，而这些底层细节在使用反射时是不需要关心的
- 反射包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而方法句柄更轻量，仅包含执行该方法的相关信息

# invokedynamic指令

invokedynamic指令与方法句柄机制的作用是一样的，都是为了解决原有4
条invokeXXX指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转移到具体用户代码之中，只是一个用上层代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。

每一处含有invokedynamic指令的位置都被称作动态调用点(Dynamically-Computed Call Site)，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 7新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：引导方法(Bootstrap Method，该方法存放在新增的BootstrapMethods属性中)、方法类型(MethodType)和方法名称。

引导方法有固定的参数，并且返回值是java.lang.invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上。
