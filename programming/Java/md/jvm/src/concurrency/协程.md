# 协程

1:1 的内核线程模型是如今 Java 虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。

内核线程的调度成本主要来自于用户态与内核态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。

假设发生了这样一次线程切换：线程 A -> 系统中断 -> 线程 B

处理器要去执行线程 A 的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。上下文以程序员的角度来看，是方法调用过程中的各种局部的变量与资源。以线程的角度来看，是方法的调用栈中存储的各类信息。而以操作系统和硬件的角度来看，则是存储在内存、缓存和寄存器中的一个个具体数值。物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程 A 切换到线程 B 去执行之前，操作系统首先要把线程 A 的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程 B 挂起时候的状态，这样线程 B 被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。

协程(Coroutine)是一种轻量级的线程，也被称为用户级线程或绿色线程。与操作系统级线程不同，协程是在用户空间中实现的，由程序员控制其调度和执行。它允许程序在特定的位置暂停执行，并在稍后的时间点继续执行，而不需要进行线程切换和上下文切换。

由于协程运行在线程之上，实际上操作系统并不知道协程的存在，它只知道线程，如果协程调用了一个阻塞 IO 操作，操作系统就会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度。因此协程一般都会配合非阻塞 IO，确保线程不会因为阻塞被挂起。

## 虚拟线程

在 JDK 19 中，开始引入虚拟线程(Virtual Threads)来支持协程，并在 JDK 21 中成为了正式版特性。
