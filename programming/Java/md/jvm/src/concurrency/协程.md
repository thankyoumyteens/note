# 协程

1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。

内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。

假设发生了这样一次线程切换：线程A -> 系统中断 -> 线程B

处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。上下文以程序员的角度来看，是方法调用过程中的各种局部的变量与资源。以线程的角度来看，是方法的调用栈中存储的各类信息。而以操作系统和硬件的角度来看，则是存储在内存、缓存和寄存器中的一个个具体数值。物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程A切换到线程B去执行之前，操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。

协程(Coroutine)是一种轻量级的线程，也被称为用户级线程或绿色线程。与操作系统级线程不同，协程是在用户空间中实现的，由程序员控制其调度和执行。它允许程序在特定的位置暂停执行，并在稍后的时间点继续执行，而不需要进行线程切换和上下文切换。

有栈协程(Stackful Coroutine)是一种协程实现方式，它与无栈协程(Stackless Coroutine)相对应。有栈协程使用独立的栈空间来保存协程的执行上下文，包括局部变量、函数调用信息等，使得协程的执行状态可以在不同的调用层级之间切换。与无栈协程不同，有栈协程在每次切换时会保存和恢复整个执行上下文，包括栈指针、寄存器状态等。这使得有栈协程更接近于线程的行为，可以在协程之间进行更灵活的切换和调度。

# 纤程

从Java 15开始，引入了一种称为纤程(Fiber)的实验性特性，用于实现有栈协程。这些纤程需要使用特定的依赖库来支持，并且仍处于实验性阶段。
