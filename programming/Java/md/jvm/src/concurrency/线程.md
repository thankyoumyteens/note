# 线程

线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址、文件 I/O 等)，又可以独立调度。线程是 Java 里面进行处理器资源调度的最基本单位。

实现线程主要有三种方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现。

## 内核线程实现

使用内核线程实现的方式也被称为 1：1 实现。内核线程(Kernel-Level Thread，KLT)就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核(Multi-Threads Kernel)。

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间 1：1 的关系称为一对一的线程模型。

由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。

轻量级进程也具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源，因此一个系统支持轻量级进程的数量是有限的。

## 用户线程实现

使用用户线程实现的方式被称为 1：N 实现。

广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程(User Thread，UT)的一种，因此从这个定义上看，轻量级进程也属于用户线程，但轻
量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。

而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间 1：N 的关系称为一对多的线程模型。

用户线程所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如阻塞如何处理、多处理器系统中如何将线程映射到其他处理器上这类问题解决起来将会异常困难，甚至有些是不可能实现的。因为使用用户线程实现的程序通
常都比较复杂，除了有明确的需求外，一般的应用程序都不倾向使用用户线程。

## 混合实现

线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为 N：M 实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。

用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是 N：M 的关系，这种就是多对多的线程模型。

## Java 线程的实现

主流商用 Java 虚拟机的线程模型普遍采用 1：1 的线程模型。以 HotSpot 为例，它的每一个 Java 线程都是直接映射到一个操作系统原生线程来实现的，而且中间
没有额外的间接结构，所以 HotSpot 自己是不会去干涉线程调度的，何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的。

## Java 线程调度

线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式线程调度(Cooperative Threads-Scheduling)和抢占式线程调度(Preemptive Threads-Scheduling)。

如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。

如果使用抢占式调度的多线程系统，那么每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定。在 Java 中，通过`Thread::yield()`方法可以主动让出执行时间，但是无法主动获取执行时间。在这种实现线程调度的方式下，线程的执行时间是操作系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。

可以通过设置线程优先级来建议操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点。Java 语言一共设置了 10 个级别的线程优先级(Thread.MIN_PRIORITY 至 Thread.MAX_PRIORITY)。在两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。

## 状态转换

Java 语言定义了 6 种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。

1. 新建(New)：创建后尚未启动的线程处于这种状态
2. 运行(Runnable)：包括操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间
3. 无限期等待(Waiting)：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：
   - 没有设置 Timeout 参数的`Object::wait()`方法
   - 没有设置 Timeout 参数的`Thread::join()`方法
   - `LockSupport::park()`方法
4. 限期等待(Timed Waiting)：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
   - `Thread::sleep()`方法
   - 设置了 Timeout 参数的`Object::wait()`方法
   - 设置了 Timeout 参数的`Thread::join()`方法
   - `LockSupport::parkNanos()`方法
   - `LockSupport::parkUntil()`方法
5. 阻塞(Blocked)：线程被阻塞了，阻塞状态在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生
6. 结束(Terminated)：已终止线程的线程状态，线程已经结束执行
