# 缓存一致性

CPU的运算速度远快于主内存，为了解决这个问题，一般会在CPU与主内存之间添加一级或者多级高速缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存(L1)、二级缓存(L2)和三级缓存(L3)。每一级缓存中所储存的全部数据都是下一级缓存的一部分。越靠近CPU的缓存越快也越小，L1和L2只能被一个单独的CPU核心使用，L3被所有CPU核心共享。当CPU执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，如果这些缓存中都没有所需的数据，就要去主存中查找。CPU缓存是以缓存行(Cache Line)为单位存储的，缓存行是CPU和主存之间数据传输的最小单位，每个缓存行的大小通常是64字节。

![](../img/cpu_cache.png)

如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下需要把 Cache 中的数据同步到内存中。

## 写回

CPU通过写回（Write Back）策略将Cache中的数据同步回内存。

1. 当发生写操作时，如果数据已经在 Cache 里的话，则直接修改 Cache 里的数据，同时标记 Cache 里的这个 Cache Line 为脏（Dirty），表示 Cache 里面的这个 Cache Line 的数据和内存是不一致的，这种情况是不用把数据写到内存里的
2. 当发生写操作时，如果数据不在 Cache 中，CPU会选中一个 Cache Line 用于缓存该数据，并且检查这个 Cache Line 有没有被标记为脏，如果是脏的话，就会把这个 Cache Line 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Line 里，同时也把它标记为脏。如果 Cache Line 没有被标记为脏，就直接将数据写入到这个 Cache Line 里，然后再把这个 Cache Line 标记为脏的就好了。

在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Line 为脏的情况下，才会将数据写到内存中，而在缓存命中的情况下，只需把该数据对应的 Cache Line 标记为脏即可，而不用写到内存里。如果大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要直接读写内存。

## 缓存一致性问题

多核CPU会有缓存一致性问题。

例如两个CPU同时拥有共享变量a，且a=0，这时如果CPU 0修改了a的值为1，CPU使用写回策略，先把值为1的修改写入到自己的L1/L2 Cache 中，然后把 Cache 中对应的 Cache Line 标记为脏，这个时候数据其实没有被同步到内存中，CPU 0的这个 Cache Line 要被替换的时候，数据才会写入到内存里。如果此时另一个CPU 1尝试从内存读取变量a的值，则读到的将会是错误的值0。

