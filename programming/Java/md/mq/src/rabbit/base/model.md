# 消息模型

## 点对点消息模型

![](../../img/2.png)

- P: 生产者, 也就是要发送消息的程序
- C: 消费者: 消息的接受者, 会一直等待消息到来。
- queue: 消息队列, 图中红色部分。可以缓存消息；生产者向其中投递消息, 消费者从其中取出消息。

## work 消息模型

工作队列或者竞争消费者模式

![](../../img/3.png)

两个消费端共同消费同一个队列中的消息, 但是一个消息只能被一个消费者获取。

work 模型通过手动确认机制实现能者多劳

- P: 生产者: 任务的发布者
- C1: 消费者 1: 领取任务并且完成任务
- C2: 消费者 2: 领取任务并且完成任务

## 发布-订阅模型 Fanout

也称为广播

![](../../img/4.png)

- P: 生产者, 向交换机发送消息
- X: 交换机, 接收生产者的消息, 然后把消息发送给绑定的所有队列
- C1: 消费者
- C2: 消费者

在广播模式下, 消息发送流程是这样的:

- 可以有多个消费者
- 每个消费者有自己的队列
- 每个队列都要绑定到交换机
- 生产者发送的消息, 只能发送到交换机, 交换机来决定要发给哪个队列, 生产者无法决定。
- 交换机把消息发送给绑定过的所有队列
- 队列的消费者都能拿到消息。实现一条消息被多个消费者消费

## 发布-订阅模型 Direct

在 Direct 模型下, 队列与交换机的绑定, 不能是任意绑定了, 而是要指定一个 RoutingKey(路由 key)

消息的发送方在向交换机发送消息时, 也必须指定消息的 routing key。

![](../../img/5.png)

- P: 生产者, 向交换机发送消息, 发送消息时, 会指定一个 routing key。
- X: 交换机, 接收生产者的消息, 然后把消息递交给 与 routing key 完全匹配的队列
- C1: 消费者, 其所在队列指定了需要 routing key 为 error 的消息
- C2: 消费者, 其所在队列指定了需要 routing key 为 info、error、warning 的消息

## 发布-订阅模型 Topic

Topic 类型的交换机与 Direct 相比, 都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型交换机可以让队列在绑定 Routing key 的时候使用通配符

Routingkey 一般都是有一个或多个单词组成, 多个单词之间以"."分割, 例如: item.insert

通配符规则:

- `#`: 匹配一个或多个词, 如: `audit.#`: 能够匹配`audit.irs.corporate` 或者 `audit.irs`
- `*`: 匹配不多不少恰好 1 个词, 如: `audit.*`: 只能匹配`audit.irs`

![](../../img/6.png)

## RPC 模型

![](../../img/7.png)

- 当客户端启动的时候, 它创建一个匿名独享的回调队列。
- 在 RPC 请求中, 客户端发送的消息带有两个属性: 一个是设置回调队列的 reply_to 属性, 另一个是设置唯一值的 correlation_id 属性。
- 将请求发送到一个 rpc_queue 队列中。
- 服务器等待请求发送到这个队列中来。当请求出现的时候, 它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。
- 客户端等待回调队列里的数据。当有消息出现的时候, 它会检查 correlation_id 属性。如果此属性的值与请求匹配, 将它返回给应用
