# 指针压缩

从 JDK 1.6 开始在 64 位的操作系统中就 JVM 就支持指针压缩。

在 32 位机器上，一个机器字只有 32 位大小，但是到了 64 位系统就需要 64 位大小。由于指针大小的扩展，64 位系统上的堆空间要比相应的 32 位系统大，每个对象的 oop 与 klass 都增大一倍。占用的内存越多，也就意味着更长时间的 GC 周期，同时也意味着性能的下降。

寻址时每 1 位都代表一个地址，在 32 位系统中，可以寻址 2^32=4294967296 个地址，而操作系统使用内存的最小单位是字节，所以 32 位操作系统可以使用 4294967296\*1B=4GB 内存。可用的地址范围：00000000000000000000000000000000 ~ 11111111111111111111111111111111

开启指针压缩后，JVM 会要求任何对象的大小都必须是 8 字节的整数倍，对象进行这种对齐后，内存地址的后三位都是 0，根据这个规则，就可以在存储地址的时候舍弃后面的三位，读取地址的时候再加上这三位。在使用指针的时候，JVM 会先把地址左移 3 位(把指针解压缩)，找到对象实际的地址，把这个地址存储到 64 位寄存器中供后续使用。当这个对象用完了之后，JVM 会把这个地址从寄存器中取出来后右移 3 位(把指针压缩)，恢复成 32 位地址。这样，虽然使用的是 32 位的指针，实际上可以使用 2^35=32GB 的内存。开启指针压缩后可用的地址范围：00000000000000000000000000000000000 ~ 11111111111111111111111111111111000

例如，对象 b 的元数据指针存储的地址是`0x00000001`，JVM 取到这个地址后，会先把它左移 3 位(即乘 8)得到 Klass 对象的真正地址`0x00000008`。`0x00000008`右移 3 位后又变回了元数据指针存储的地址`0x00000001`。

由于指针压缩的实现方式，堆内存小于 4GB 时，不需要启用指针压缩，JVM 只使用 32 位地址就够了。堆内存大于 32GB 时，指针压缩会失效，JVM 会强制使用 64 位地址来寻址对象。

## 开启指针压缩的 Java 对象内存布局

打印 DemoObj 类的对象的内存布局：

```java
// JVM参数:
// -XX:+UseCompressedClassPointers
// -XX:+UseCompressedOops
public class DemoObj {

    public static void main(String[] args) {
        DemoObj obj = new DemoObj();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
```

输出：

```java
org.example.DemoObj object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4        (object header: class)    0xf800c105
 12   4        (object alignment gap)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

1. OFF 为 0：这一行是对象头中的 Mark Word, 由于代码运行在 64 位 JVM 上，所以占用 8 字节(64bit)
2. OFF 为 8：这一行是对象头中的元数据指针, 指向对应的 Klass 对象, 64 位操作系统中的指针应该也是 64 位的，但是由于开启了指针压缩, 所以这个指针只用了 32 位

## 关闭指针压缩的 Java 对象内存布局

打印 DemoObj 类的对象的内存布局：

```java
// JVM参数:
// -XX:-UseCompressedClassPointers
// -XX:-UseCompressedOops
public class DemoObj {

    public static void main(String[] args) {
        DemoObj obj = new DemoObj();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
```

输出：

```java
org.example.DemoObj object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   8        (object header: class)    0x0000024d08573140
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
```

与开启指针压缩的区别是 OFF 为 8 的元数据指针，它由 4 字节变成了 8 字节。

## 指针压缩失效

由于能够表示的最大内存是 32GB，所以如果配置的最大的堆内存大于等于 32GB 时，指针压缩将会失效。

```java
// JVM参数:
// -Xmx32g
// -XX:+UseCompressedClassPointers
// -XX:+UseCompressedOops
public class DemoObj {

    public static void main(String[] args) {
        DemoObj obj = new DemoObj();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
```

输出：

```java
org.example.DemoObj object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   8        (object header: class)    0x0000015cde533140
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total

OpenJDK 64-Bit Server VM warning: Max heap size too large for Compressed Oops
```

指针压缩失效，指针长度恢复到 8 字节。

## 修改对象默认对齐长度

可以通过修改默认对齐长度使指针压缩再次生效。比如，把对象从 8 字节对齐修改为 16 字节对齐，指针压缩支持的最大堆内存将从 32GB 变成 64GB。

```java
// JVM参数:
// -XX:ObjectAlignmentInBytes=16
// -Xmx32g
// -XX:+UseCompressedClassPointers
// -XX:+UseCompressedOops
public class DemoObj {

    public static void main(String[] args) {
        DemoObj obj = new DemoObj();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
```

输出：

```java
org.example.DemoObj object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4        (object header: class)    0x00060828
 12   4        (object alignment gap)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

指针再次被压缩，指针长度恢复到 4 字节。并且对象需要是 16 字节的整数倍，所以填充了 4 字节。
