# 指针压缩

从 JDK 1.6 开始在 64 位的操作系统中就 JVM 就支持指针压缩。

在 32 位机器上，一个机器字只有 32 位大小，但是到了 64 位系统就需要 64 位大小。由于指针大小的扩展，64 位系统上的堆空间要比相应的 32 位系统大，每个对象的 oop 与 klass 都增大一倍。占用的内存越多，也就意味着更长时间的 GC 周期，同时也意味着性能的下降。

寻址时每 1 位都代表一个地址，在 32 位系统中，可以寻址 2^32=4294967296 个地址，而操作系统使用内存的最小单位是字节，所以 32 位操作系统可以使用 4294967296\*1B=4GB 内存。可用的地址范围：00000000000000000000000000000000 ~ 11111111111111111111111111111111

开启指针压缩后，JVM 会要求任何对象的大小都必须是 8 字节的整数倍，对象进行这种对齐后，内存地址的后三位都是 0，根据这个规则，就可以在存储地址的时候舍弃后面的三位，读取地址的时候再加上这三位。在使用指针的时候，JVM 会先把地址左移 3 位(把指针解压缩)，找到对象实际的地址，把这个地址存储到 64 位寄存器中供后续使用。当这个对象用完了之后，JVM 会把这个地址从寄存器中取出来后右移 3 位(把指针压缩)，恢复成 32 位地址。这样，虽然使用的是 32 位的指针，实际上可以使用 2^35=32GB 的内存。开启指针压缩后可用的地址范围：00000000000000000000000000000000000 ~ 11111111111111111111111111111111000

例如，对象 b 的元数据指针存储的地址是`0x00000001`，JVM 取到这个地址后，会先把它左移 3 位(即乘 8)得到 Klass 对象的真正地址`0x00000008`。`0x00000008`右移 3 位后又变回了元数据指针存储的地址`0x00000001`。

由于指针压缩的实现方式，堆内存小于 4GB 时，不需要启用指针压缩，JVM 只使用 32 位地址就够了。堆内存大于 32GB 时，指针压缩会失效，JVM 会强制使用 64 位地址来寻址对象。

## 开启指针压缩的 Java 对象内存布局

1. 导入依赖：

```xml
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.17</version>
</dependency>
```

2. 测试类：

```java
public class DemoObj {
    public boolean val1;
    public int val2;
    public String val3;
}
```

3. 打印 DemoObj 类的对象的内存布局：

```java
// JVM参数:
// -XX:+UseCompressedClassPointers -XX:+UseCompressedOops
DemoObj obj = new DemoObj();
obj.val1 = true;
obj.val2 = 100;
obj.val3 = "str";
System.out.println(ClassLayout.parseInstance(obj).toPrintable());
```

4. 输出：

```java
demo.DemoObj object internals:
OFF  SZ               TYPE DESCRIPTION               VALUE
  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4                    (object header: class)    0xf800c146
 12   4                int DemoObj.val2              100
 16   1            boolean DemoObj.val1              true
 17   3                    (alignment/padding gap)
 20   4   java.lang.String DemoObj.val3              (object)
Instance size: 24 bytes
Space losses: 3 bytes internal + 0 bytes external = 3 bytes total
```

第 2 行的含义：

1. OFF: 偏移量
2. SZ: 占用字节数
3. TYPE: Java 类型
4. DESCRIPTION: 描述
5. VALUE: 值

第 2 行以下各行的含义：

1. OFF 为 0：这一行是对象头中的 Mark Word, 由于代码运行在 64 位 JVM 上，所以占用 8 字节(64bit)
2. OFF 为 8：这一行是对象头中的元数据指针, 指向对应的 Klass 对象, 64 位操作系统中的指针应该也是 64 位的，但是由于开启了指针压缩, 所以这个指针只用了 32 位
3. OFF 为 12：这一行是实例数据，存储 DemoObj 对象的字段 val2
4. OFF 为 16：这一行是实例数据，存储 DemoObj 对象的字段 val1
5. OFF 为 17：这一行是字段的对齐填充
6. OFF 为 20：这一行是实例数据，存储 DemoObj 对象的字段 val3
7. HotSpot 虚拟机要求任何对象的大小都必须是 8 字节的整数倍，由于这个对象占用 24 字节，是 8 字节的整数倍，所以不需要再进行填充

## 关闭指针压缩的 Java 对象内存布局

1. 打印 DemoObj 类的对象的内存布局：

```java
// JVM参数:
// -XX:-UseCompressedClassPointers -XX:-UseCompressedOops
DemoObj obj = new DemoObj();
obj.val1 = true;
obj.val2 = 100;
obj.val3 = "str";
System.out.println(ClassLayout.parseInstance(obj).toPrintable());
```

2. 输出：

```java
demo.DemoObj object internals:
OFF  SZ               TYPE DESCRIPTION               VALUE
  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   8                    (object header: class)    0x0000017d08b439a8
 16   4                int DemoObj.val2              100
 20   1            boolean DemoObj.val1              true
 21   3                    (alignment/padding gap)
 24   8   java.lang.String DemoObj.val3              (object)
Instance size: 32 bytes
Space losses: 3 bytes internal + 0 bytes external = 3 bytes total
```

与开启指针压缩的区别是 OFF 为 8 的元数据指针，它由 4 字节变成了 8 字节。
