# Young GC

当内存分配的时候，剩余的空间不能满足要分配的对象时就会优先触发新生代回收（Young GC，YGC）。

G1 的 YGC 是针对部分内存进行的垃圾回收，所以 YGC 花费的时间通常都比较短。G1 的 YGC 收集的内存是不固定的，每次回收的内存可能并不相同，即每次回收的 region 数目是不固定的，但是每一次 YGC 都是收集所有的新生代 region，所以每一次 GC 之后都会调整新生代 region 的数目。

Young GC 的收集过程：

1. 暂停所有的其他线程（STW）
2. 选择要收集的 CSet，对于 YGC 来说是所有的新生代 region
3. 并行任务处理：
   1. 根扫描并处理，处理过程会把根(GC Root)直接引用的对象复制到新的 Survivor 区，然后把被根引用的对象加入队列等待后续的处理
   2. 处理老年代 region 到新生代 region 的引用，首先会更新 refine 线程没处理完的 RSet，然后从 RSet 出发，把 RSet 中的卡表对应的内存块中所有的对象都认为是根，把这些根引用的对象复制到新的 Survivor 区，然后把被根引用的对象加入队列等待后续的处理
   3. 处理队列中的对象
4. 其他任务处理：
   1. 在并行任务中已经对代码进行了扫描和复制，这里会更新相关指针所指向的位置
   2. 引用处理，即把引用中使用的存活对象也要复制到新的 region，否则就会造成错误
   3. 字符串去重优化回收，优化字符串使用的效率
   4. 清除卡表，就是把全局卡表中已经处理过的 region 对应的卡片的 dirty 标记清空
   5. 如果对象复制失败，则进行处理，主要的工作就是恢复对象头
   6. 引用再处理，把引用中还活着的对象放入引用队列中
   7. 进行 Redirty，主要工作就是重构 RSet，包括收集过程中，因为对象移动需要重构老年代 region 到新 Survivor 区的引用，Redirty 通常是并行执行的
   8. 释放 CSet，释放内存，把这些 region 放入空闲列表（Free List），供后续使用，这里的后续指的是对象分配时如果需要新的 region，可以直接从空闲列表获取
   9. 尝试大对象回收，判断这些大对象所在的 region 是否有 RSet 引用，且只需要判断大对象所在第一个 region，如果没有引用则说明整个大对象肯定已经死亡，有引用则说明大对象可能还活着，在并发标记中进一步处理
   10. 尝试扩展内存
   11. 调整新生代 region 的数目，主要是根据 GC 的执行时间和目标停顿时间预测下次可能发生垃圾回收时能接受的最大 region 数。在 GC 中因为处理了 RSet，如果这个时间过大，说明 DCQS 白、绿、黄、红四个区域设置不合理，需要调整
   12. 如果可能的话，启动并发标记；使用的内存超过一定的阈值则可以启动
5. 恢复其他线程（STW 结束）
