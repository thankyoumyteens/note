# 并行任务处理

并行任务处理是通过工作线程 FlexibleWorkGang 来执行任务 G1ParTask，FlexibleWorkGang 是并行执行的，个数一般和 CPU 核心数相关。

G1ParTask 的任务：

1. 根扫描并处理：
   1. 如果对象还没有设置过标记信息，把对象从 Eden 复制到 Survivor，然后针对对象的每一个字段，如果字段所引用的对象在 CSet 中，则把对象的地址加入到 G1ParScanThreadState（PSS）队列中。如果字段不在 CSet 中，则更新该对象所在 region 中的 RSet
   2. 更新根对象到对象的新位置(更新根对象后，对象发生了复制，所以一个对象对应两个内存区域，以对象的老位置和新位置来区分对象复制前后的内存地址)
2. 处理老年代 region 到新生代 region 的引用：
   1. 更新 refine 线程没处理的 RSet，更新老年代 region 到新生代 region 的引用
   2. 扫描 RSet，把引用方作为根，从根出发，对可达对象进行根扫描并处理
3. 复制。在 PSS 中队列的对象都是存活对象，每一个对象都要复制到 Survivor 区，然后针对该对象的每一个字段：如果字段所引用的 region 在 CSet 中，则把该对象的地址加入到 PSS 队列中。循环处理 PSS 队列，直到队列中没有对象

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\g1CollectedHeap.cpp

```cpp
class G1ParTask : public AbstractGangTask {
public:
  /**
   * 并行处理的入口
   */
  void work(uint worker_id) {
    // ...
    // 根处理
    _root_processor->evacuate_roots(strong_root_cl,
                                    weak_root_cl,
                                    strong_cld_cl,
                                    weak_cld_cl,
                                    trace_metadata,
                                    worker_id);
    // ...
    // 处理DCQS中剩下的DCQ，以及把RSet作为根处理
    _root_processor->scan_remembered_sets(&push_heap_rs_cl,
                                          weak_root_cl,
                                          worker_id);
    // ...
      // 开始复制
      G1ParEvacuateFollowersClosure evac(_g1h, &pss, _queues, &_terminator);
      evac.do_void();
    // ...
  }
}
```
