# 查找需要回收的引用

引用对象的元数据指针会指向 InstanceRefKlass 类型的 klass。

> jdk8u60-master\hotspot\src\share\vm\oops\instanceRefKlass.cpp

```cpp
#if INCLUDE_ALL_GCS
#define InstanceRefKlass_OOP_OOP_ITERATE_BACKWARDS_DEFN(OopClosureType, nv_suffix) \
                                                                                \
int InstanceRefKlass::                                                          \
oop_oop_iterate_backwards##nv_suffix(oop obj, OopClosureType* closure) {        \
  /* Get size before changing pointers */                                       \
  SpecializationStats::record_iterate_call##nv_suffix(SpecializationStats::irk);\
  /* 处理这个对象的每一个字段 */                                                    \
  int size = InstanceKlass::oop_oop_iterate_backwards##nv_suffix(obj, closure); \
  /* 处理引用 */                                                                 \
  if (UseCompressedOops) {                                                      \
    InstanceRefKlass_SPECIALIZED_OOP_ITERATE(narrowOop, nv_suffix, contains);   \
  } else {                                                                      \
    InstanceRefKlass_SPECIALIZED_OOP_ITERATE(oop, nv_suffix, contains);         \
  }                                                                             \
}
#endif // INCLUDE_ALL_GCS

// 处理引用
#define InstanceRefKlass_SPECIALIZED_OOP_ITERATE(T, nv_suffix, contains)        \
  /* obj 是Java中Reference类的对象 */                                             \
  /* 获取obj的discovered字段的地址 */                                              \
  T* disc_addr = (T*)java_lang_ref_Reference::discovered_addr(obj);             \
  /* apply_to_weak_ref_discovered_field()方法会直接返回true */                    \
  if (closure->apply_to_weak_ref_discovered_field()) {                          \
    /* G1ParScanClosure::do_oop_nv() */                                         \
    closure->do_oop##nv_suffix(disc_addr);                                      \
  }                                                                             \
                                                                                \
  /* 获取obj的referent字段的地址 */                                                \
  T* referent_addr = (T*)java_lang_ref_Reference::referent_addr(obj);           \
  /* 获取指针指向的对象 */                                                         \
  T heap_oop = oopDesc::load_heap_oop(referent_addr);                           \
  ReferenceProcessor* rp = closure->_ref_processor;                             \
  if (!oopDesc::is_null(heap_oop)) {                                            \
    /* 解析压缩指针 */                                                            \
    oop referent = oopDesc::decode_heap_oop_not_null(heap_oop);                 \
    if (!referent->is_gc_marked() && (rp != NULL) &&                            \
        rp->discover_reference(obj, reference_type())) {                        \
      /* referent对象没有被标记 */                                                \
      /* 使用ReferenceProcessor::discover_reference()处理 */                     \
      /* discover_reference()如果返回true, 表示不需要继续进行后面的处理 */                 \
      return size;                                                              \
    } else if (contains(referent_addr)) {                                       \
      /* referent对象被标记, 即还有强引用指向这个对象(存活) */                         \
      /* 把这个对象当作普通对象处理 */                                               \
      SpecializationStats::record_do_oop_call##nv_suffix(SpecializationStats::irk);\
      closure->do_oop##nv_suffix(referent_addr);                                \
    }                                                                           \
  }                                                                             \
  /* 获取obj的next字段的地址 */                                                    \
  T* next_addr = (T*)java_lang_ref_Reference::next_addr(obj);                   \
  /* 兼容旧版JDK */                                                              \
  if (ReferenceProcessor::pending_list_uses_discovered_field()) {               \
    T next_oop  = oopDesc::load_heap_oop(next_addr);                            \
    /* Treat discovered as normal oop, if ref is not "active" (next non-NULL) */\
    if (!oopDesc::is_null(next_oop) && contains(disc_addr)) {                   \
      SpecializationStats::record_do_oop_call##nv_suffix(SpecializationStats::irk);\
      closure->do_oop##nv_suffix(disc_addr);                                    \
    }                                                                           \
  }                                                                             \
  /* 把next指向的对象当作普通对象处理 */                                             \
  if (contains(next_addr)) {                                                    \
    SpecializationStats::record_do_oop_call##nv_suffix(SpecializationStats::irk); \
    closure->do_oop##nv_suffix(next_addr);                                      \
  }                                                                             \
  return size;                                                                  \
```

> jdk8u60-master\hotspot\src\share\vm\memory\referenceProcessor.cpp

```cpp
/**
 * 查找需要回收的引用, 并加入到discovered_list中
 */
bool ReferenceProcessor::discover_reference(oop obj, ReferenceType rt) {
  // 判断是否不需要处理
  // _discovering_refs在执行GC的时候设置为true表示不执行
  // 在执行完GC或者并发标记时, 设置为false, 表示可以执行
  // RegisterReferences由参数-XX:RegisterReferences控制
  if (!_discovering_refs || !RegisterReferences) {
    return false;
  }
  // next != null表示引用对象不是Active状态
  // 只处理Active状态的引用对象
  oop next = java_lang_ref_Reference::next(obj);
  if (next != NULL) {
    return false;
  }

  HeapWord* obj_addr = (HeapWord*)obj;
  // 可以通过参数-XX:RefDiscoveryPolicy选择引用发现策略
  // 默认为0, 表示ReferenceBasedDiscovery,
  // 指如果引用对象在处理范围内, 则对这个引用对象进行处理
  // 1表示ReferentBasedDiscovery,
  // 指如果引用对象或者引用对象里面的对象在处理范围内,
  // 则对引用对象处理
  // 1会导致处理的对象更多
  if (RefDiscoveryPolicy == ReferenceBasedDiscovery &&
      !_span.contains(obj_addr)) {
    // 关联的span内存区中没有该引用对象
    return false;
  }

  // 引用里面的对象如果有强引用则无需处理
  if (is_alive_non_header() != NULL) {
    verify_referent(obj);
    if (is_alive_non_header()->do_object_b(java_lang_ref_Reference::referent(obj))) {
      // 存在其他的强引用
      return false;
    }
  }
  if (rt == REF_SOFT) {
    // 如果是软引用, 则通过清除策略判断其是否应该清除, 如果不需要则返回false
    // _current_soft_ref_policy通过编译选项控制
    // 服务器模式(C2): _current_soft_ref_policy = LRUMaxHeapPolicy
    // 非服务器模式: _current_soft_ref_policy = LRUCurrentHeapPolicy
    // _soft_ref_timestamp_clock: 记录了最后一次GC的时间点(时间单位为毫秒)
    if (!_current_soft_ref_policy->should_clear_reference(obj, _soft_ref_timestamp_clock)) {
      return false;
    }
  }

  ResourceMark rm;
  // 获取discovered字段
  HeapWord* const discovered_addr = java_lang_ref_Reference::discovered_addr(obj);
  const oop  discovered = java_lang_ref_Reference::discovered(obj);
  assert(discovered->is_oop_or_null(), "bad discovered field");
  if (discovered != NULL) {
    // 引用对象已经被处理过
    if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
      // ReferentBasedDiscovery策略
      return false;
    } else {
      // ReferenceBasedDiscovery策略
      return true;
    }
  }

  if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
    verify_referent(obj);
    // 判断你是否满足条件:
    // 引用对象的地址在_span的范围内
    // 引用对象内部的对象也在_span的范围内
    // 查找引用的操作是原子的
    if (_span.contains(obj_addr) ||
        (discovery_is_atomic() &&
         _span.contains(java_lang_ref_Reference::referent(obj)))) {
      // 需要把引用对象加入discovered_list
    } else {
      return false;
    }
  }

  // discovered_list的头节点
  DiscoveredList* list = get_discovered_list(rt);
  if (list == NULL) {
    return false;
  }

  if (_discovery_is_mt) {
    // 多线程
    add_to_discovered_list_mt(*list, obj, discovered_addr);
  } else {
    // 单线程
    oop current_head = list->head();
    // 如果current_head为NULL,
    // 则当前引用对象是链表的第一个节点也是最后一个节点,
    // discovered属性指向它自己
    oop next_discovered = (current_head != NULL) ? current_head : obj;

    oop_store_raw(discovered_addr, next_discovered);
    // 当前引用对象成为新的头节点
    list->set_head(obj);
    list->inc_length(1);
  }
  verify_referent(obj);
  return true;
}
```

> jdk8u60-master\hotspot\src\share\vm\memory\referencePolicy.cpp

```cpp
/**
 * 处理软引用
 */
bool LRUMaxHeapPolicy::should_clear_reference(oop p,
                                             jlong timestamp_clock) {
  jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);
  // 判断软引用对象的存活时间是否超过了阈值_max_interval
  if(interval <= _max_interval) {
    return false;
  }

  return true;
}

/**
 * 设置_max_interval
 */
void LRUMaxHeapPolicy::setup() {
  size_t max_heap = MaxHeapSize;
  max_heap -= Universe::get_heap_used_at_last_gc();
  max_heap /= M;

  // 根据最大可用的内存来估算软引用对象最大的生存时间
  _max_interval = max_heap * SoftRefLRUPolicyMSPerMB;
}
```
