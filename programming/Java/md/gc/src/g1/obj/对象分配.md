# 对象分配

Java 堆是线程共享区域，任何线程都可以访问到堆区的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为了避免多个线程操作同一地址，需要使用线程同步机制(加锁等)，而线程同步会影响分配速度。

G1 提供了两种分配策略：

1. TLAB 快速分配
2. 堆中慢速分配

## 对象的创建过程

开启 TLAB 时，JVM 会优先在 TLAB 中分配内存，当对象在 TLAB 空间分配内存失败时，JVM 会尝试通过使用同步机制确保数据操作的原子性，从而直接在堆空间中分配内存。

JVM 会先创建 InstanceKlass(InstanceKlass 定义了 Java 类的数据结构，InstanceKlass 就是一个 Java 字节码文件被加载到内存后的形式)，然后再调用 allocate_instance 方法创建对象实例：

> jdk8u60-master\hotspot\src\share\vm\oops\instanceKlass.cpp

```cpp
instanceOop InstanceKlass::allocate_instance(TRAPS) {
  // 是否实现了finalize()方法
  bool has_finalizer_flag = has_finalizer();
  // 查询实例对象的大小
  int size = size_helper();

  KlassHandle h_k(THREAD, this);

  instanceOop i;
  // 分配内存空间并创建实例对象
  i = (instanceOop)CollectedHeap::obj_allocate(h_k, size, CHECK_NULL);
  if (has_finalizer_flag && !RegisterFinalizersAtInit) {
    // 注册finalize()方法
    i = register_finalizer(i, CHECK_NULL);
  }
  return i;
}
```

CollectedHeap::obj_allocate()方法最终会调用 CollectedHeap::common_mem_allocate_noinit()方法完成对象的分配：

> jdk8u60-master\hotspot\src\share\vm\gc_interface\collectedHeap.inline.hpp

```cpp
HeapWord* CollectedHeap::common_mem_allocate_noinit(KlassHandle klass, size_t size, TRAPS) {
  // ...
  HeapWord* result = NULL;
  // 如果启用了TLAB，那么尝试从TLAB中分配内存。如果分配成功，返回分配的内存地址
  if (UseTLAB) {
    result = allocate_from_tlab(klass, THREAD, size);
    if (result != NULL) {
      // ...
      return result;
    }
  }
  // 如果从TLAB中分配内存失败，那么尝试从堆中分配内存
  bool gc_overhead_limit_was_exceeded = false;
  result = Universe::heap()->mem_allocate(size,
                                          &gc_overhead_limit_was_exceeded);
  if (result != NULL) {
    // ...
    return result;
  }
  // ...
}
```
