# 分代GC模式

G1中存在纯G1模式(pure garbage-first mode)和分代G1模式(generational garbage-first mode)两种模式。OpenJDK虽然实现了纯G1模式, 但是并没有将这种模式开放给用户, 用户使用的都是分代G1模式。

和纯G1模式相比, 分代G1模式主要有以下两个不同点

1. Region是分代的
2. 回收集的选择是分代的

在分代G1模式中, Region被分为新生代Region和老年代Region两类。和其他收集器一样, 分代的对象也保存了自身在各次转移中存活下来的次数(年龄)。新生代Region用来存放新生代对象, 老年代Region用来存放老年代对象。

G1中的新生代GC称为Yong GC, 老年代GC称为Mixed GC。Yong GC和Mixed GC的主要区别在于CSet的选择。Yong GC将所有新生代Region选入CSet, 而Mixed GC将所有新生代Region, 以及一部分并发标记统计出的收集收益高的老年代Region选入CSet。

分代GC模式的正常工作流程就是在Young GC与Mixed GC之间视情况切换, 背后定期做做全局并发标记。初始标记阶段默认会在Young GC的暂停时顺便执行。当全局并发标记正在工作时, G1不会选择做Mixed GC, 反之如果有Mixed GC正在进行中G1也不会启动初始标记阶段。在正常工作流程中没有Full GC的概念, 老年代Region的收集全靠Mixed GC来完成。

如果Mixed GC实在无法跟上程序分配内存的速度, 导致老年代填满无法继续进行Mixed GC, 就会切换到G1之外的Serial Old GC来收集整个Java堆, 这才是真正的Full GC。进入这种状态的G1就跟-XX:+UseSerialGC的Full GC一样, 背后的核心代码是两者共用的。

## 新生代Region

新生代Region可以分为两类: 创建Region, 存活Region。创建Region用来存放刚刚生成、一次也没有被转移过的对象。存活Region用来存放被转移过至少一次的对象。另外, 写屏障不会应用在新生代Region的对象上, 即使新生代Region的对象存在对其他Region对象的引用, 被引用Region的RSet中也不会记录引用方的卡片。

对于新生代RegionA中的对象a对老年代RegionB中对象b的引用, 写屏障是无效的, 所以RSetB不会记录这次引用。而对于来自老年代Region对象的引用, 写屏障仍然有效。

![](../../img/g1bm16.png)

在分代G1模式中, 所有的新生代Region都会被选入CSet, 因此在转移新生代Region时所有对象的引用都会被检查。即使被引用Region的RSet中记录了来自新生代Region的引用, 这些记录也都是重复的信息, 因为遍历新生代对象时就会找到这些Region了。因此, RSet中不会记录来自新生代Region的引用。

## 分代对象转移

存活对象保存了自己被转移的次数, 这个次数称为对象的年龄。转移时对象的年龄如果低于阈值, 对象就会被转移到新生代Region, 否则就会被转移到老年代Region。将对象转移到老年代Region的行为称为晋升。如果转移的目标Region满了, G1就会选择一个空闲的Region, 把它修改成新生代Region或者老年代Region之后, 作为转移的目标Region使用。对象被转移到新生代Region之后, 即使该对象引用了CSet以外的Region, 也不需要记录在RSet中。相反, 往老年代Region转移对象时就必须要记录。因为老年代Region并非每次都会被选入回收集合。

## 软实时性

在G1中, 用户可以设置如下3个值: 

1. 可用内存上限
2. GC暂停时间上限
3. GC单位时间

设置可用内存上限是为了避免内存被过度占用。就算是为了实现软实时性, 也不能让GC完全占用内存。

GC暂停时间上限指定的是执行GC所导致的用户线程的最大暂停时间。这个最大暂停时间并不包含G1的并发处理的时间。G1为了避免GC暂停时间超过指定上限, 会频繁地执行暂停时间较短的GC。虽然这样做确实可以缩短GC暂停时间, 但是用户线程的执行也会频繁地被GC打断, 从而导致用户线程几乎无法正常执行。要解决这个问题, 需要指定GC单位时间。

指定GC单位时间后, G1将在每个单位时间内遵守GC的暂停时间上限。如果 GC暂停时间上限是1秒, 而GC单位时间是3秒, 就表示在任意3秒的时间段内, GC的暂停时间不可以超过1秒。

G1会努力实现软实时性。软实时性是指GC单位时间内GC暂停时间超过上限的次数在用户的容忍范围之内。因此, 尽管会出现GC暂停时间超过了上限的情况, 但是只要用户认为可以接受, 就算是实现了软实时性。

要想在GC暂停时间上限之内完成转移, 就需要选择可以在这个时间范围内完成转移的CSet。在往CSet中添加Region时, 要先预测一下该Region的转移时间, 如果超过了GC暂停时间上限, 就不再添加该Region, 并终止CSet的选择。

为了满足"在GC单位时间内不得超过GC暂停时间的上限"的要求, GC中需要暂停用户线程的处理必须在合适的时机进行。当堆内空间充足时, 可以根据需要扩展堆, 从而延迟转移处理。而且, 转移处理并不一定发生在并发标记完全结束之后。因此, 即使并发标记过程中的暂停处理延迟开始, 也不会产生致命的问题。

在一般情况下(除了堆内空间紧缺时), GC暂停处理发生的时机是可以调度的。G1中有一个队列名为调度队列, 其中的元素是暂停处理的开始时间和结束时间的组合。G1使用这个队列来高效地调度GC的暂停处理任务。调度队列中保存了最近一次暂停处理的开始时间和结束时间。调度队列中元素个数是有上限的, 如果添加元素时超过上限, 队列头部中最早添加的元素就会被删除。调度程序会基于调度队列中的信息来决定下次GC暂停的适当时机。但是, 在GC的预测时间不准确或堆内空间不足等导致GC必须提前开始时, GC暂停处理还是会超出暂停时间上限。并发标记中的暂停处理阶段(初始标记阶段、最终标记阶段、收尾工作)也会以这种方法按照合适的间隔执行。但是, 这些步骤的暂停时间不像转移中的暂停时间一样可控, 如果暂停时间本身就超过了GC暂停时间上限, 就不能遵守GC暂停时间上限了。

## 最大新生代Region数

选择全部新生代Region的做法可能会打破软实时性。如果新生代Region数太多, 就有可能无法遵守用户设置的GC暂停时间上限。要想避免这个问题, 分代G1模式就需要计算出合理的最大新生代Region数。

Yong GC的最大新生代Region数是在遵守GC暂停时间上限的前提下, 尽量设置较大的值。即根据过去的转移时间记录, 预测出单个新生代Region转移所需的大概时间, 然后基于这个时间计算出刚好不超过GC暂停时间上限的最大新生代Region数。

而Mixed GC的最大新生代Region数是在遵守GC单位时间的前提下, 尽量设置较小的值。首先, 计算出下次能够进行GC暂停处理的时机。然后, 预测出在这个时机之前大概能回收多少个Region, 并以此作为新生代Region的最大数目。当预测值命中时, 达到最大新生代Region数的时机, 刚好就是下次能够进行GC暂停处理的时机, 因此能够遵守GC单位时间。另外, 因为最大新生代Region数设置的是最小值, 所以被选入回收集合的新生代Region数也是最少的。这样一来, 距离GC暂停时间上限很可能还有一段时间, 就可以往回收集合里
添加一些老年代Region。

最大新生代Region数的设置发生在并发标记结束之后。

垃圾回收器在选择GC算法时, 通常会选择Mixed GC, 只有在使用Yong GC效率更高时才会切换为Yong GC。切换的时间点和设置最大新生代Region数时一样, 都是在并发标记结束之后。首先, 参考并发标记中标记出的死亡对象个数, 预测出下次Mixed GC的转移效率。然后, 根据过去的Yong GC的转移效率, 预测出下次Yong GC的转移效率。如果预测出Yong GC的转移效率更高, 则切换为Yong GC。

当新生代Region数达到上限时, 会触发转移的执行。换句话说, 通过调节最大新生代Region数, 可以控制转移执行的时机。

当转移完成并通过以下4项检查之后, 会开始执行并发标记: 

1. 不在并发标记执行过程中
2. 并发标记的结果已被上次转移使用完
3. 已经使用了一定量的堆内存(默认是全部堆内存的45%以上)
4. 相比上次转移完成之后, 堆内存的使用量有所增加

其中第2步是为了避免重复地并发标记。如果有并发标记的结果尚未在转移过程中被使用, 则不会开始并发标记。
