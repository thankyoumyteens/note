# 老年代回收集处理

判断哪些 region 可以放入到老年代回收集中, 主要是根据老年代 region 的垃圾空闲的情况, 只有达到收集的阈值才可能被加入到 CSet Chooser, 另外会对 region 进行排序, 排序的依据是 gc_efficiency。

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\g1CollectorPolicy.cpp

```cpp
void
G1CollectorPolicy::record_concurrent_mark_cleanup_end(int no_of_gc_threads) {
  _collectionSetChooser->clear();

  uint region_num = _g1->num_regions();
  if (G1CollectedHeap::use_parallel_gc_threads()) {
    const uint OverpartitionFactor = 4;
    uint WorkUnit;
    // 设置并行工作的线程数
    if (no_of_gc_threads > 0) {
      const uint MinWorkUnit = MAX2(region_num / no_of_gc_threads, 1U);
      WorkUnit = MAX2(region_num / (no_of_gc_threads * OverpartitionFactor),
                      MinWorkUnit);
    } else {
      const uint MinWorkUnit = MAX2(region_num / (uint) ParallelGCThreads, 1U);
      WorkUnit =
        MAX2(region_num / (uint) (ParallelGCThreads * OverpartitionFactor),
             MinWorkUnit);
    }
    _collectionSetChooser->prepare_for_par_region_addition(_g1->num_regions(),
                                                           WorkUnit);
    // 确定可回收的region
    ParKnownGarbageTask parKnownGarbageTask(_collectionSetChooser,
                                            (int) WorkUnit);
    _g1->workers()->run_task(&parKnownGarbageTask);
  } else {
    // 单线程执行
    KnownGarbageClosure knownGarbagecl(_collectionSetChooser);
    _g1->heap_region_iterate(&knownGarbagecl);
  }
  // 对CSet Chooser中的region进行排序, 排序的依据是根据每个region的有效性
  // region的有效性取决于两点: 可回收的字节数以及回收的预测速度
  _collectionSetChooser->sort_regions();

  double end_sec = os::elapsedTime();
  double elapsed_time_ms = (end_sec - _mark_cleanup_start_sec) * 1000.0;
  _concurrent_mark_cleanup_times_ms->add(elapsed_time_ms);
  _cur_mark_stop_world_time_ms += elapsed_time_ms;
  _prev_collection_pause_end_ms += elapsed_time_ms;
  _mmu_tracker->add_pause(_mark_cleanup_start_sec, end_sec, true);
}
```

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\g1CollectorPolicy.cpp

```cpp
class ParKnownGarbageTask: public AbstractGangTask {
public:
  void work(uint worker_id) {
    ParKnownGarbageHRClosure parKnownGarbageCl(_hrSorted, _chunk_size);
    _g1->heap_region_par_iterate_chunked(&parKnownGarbageCl, worker_id,
                                         _g1->workers()->active_workers(),
                                         HeapRegion::InitialClaimValue);
  }
};

class ParKnownGarbageHRClosure: public HeapRegionClosure {
public:
  bool doHeapRegion(HeapRegion* r) {
    if (r->is_marked()) {
      if (_cset_updater.should_add(r) && !_g1h->is_old_gc_alloc_region(r)) {
        // 把region加入到CSet Chooser中
        _cset_updater.add_region(r);
      }
    }
    return false;
  }
};
```
