# 并发标记算法

并发标记中用到了几个指针：

1. Bottom：指向 region 的底部
2. Top：指向 region 中已使用的空间的顶部
3. Prev TAMS：上一次并发标记时 Top 指针的位置(Top at Mark Start，TAMS)
4. Next TAMS：新一次并发标记时 Top 指针的位置(Top at Mark Start，TAMS)

当并发标记开始之后，如果有新的对象分配，可以移动 Top 指针，使 Top 指针指向当前内存分配成功的地址。Next 指针和 Top 指针之间的地址就是新的对象被分配的位置。

并发标记引入了两个位图：

1. PrevBitMap：记录 Prev 指针之前内存标记情况、即`[Bottom，Prev]`区间中的对象存活情况
2. NextBitMap：记录 Next 指针之前内存标记情况、即`[Bottom，Next]`区间中的对象存活情况

在并发标记开始之前，GC 线程首先会创建 NextBitMap。位图中的每个比特都对应着关联 Region 内的一个对象,假设 Region 中有 4 个对象，那么 NextBitMap 中就有 4 个比特：

![](../../img/mark1.png)

并发标记结束后，NextBitmap 标记了 region 中对象存活的情况，黑色表示堆 region 中对应的对象还活着。在并发标记的同时 Java 线程也会继续运行，所以 Top 会继续增长：

![](../../img/mark2.png)

新一轮的并发标记开始，交换位图，重置指针：

![](../../img/mark3.png)

第二次并发标记结束：

![](../../img/mark4.png)

## 三色标记
