# 再标记子阶段

VMThread::execute 会调用传入的 VM_Operation 对象的 evaluate()方法: 

> jdk8u60-master\hotspot\src\share\vm\runtime\vm_operations.cpp

```cpp
void VM_Operation::evaluate() {
  ResourceMark rm;
  doit();
}
```

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\vm_operations_g1.cpp

```cpp
void VM_CGC_Operation::doit() {
  SharedHeap* sh = SharedHeap::heap();
  if (sh != NULL) {
    IsGCActiveMark x;
    _cl->do_void();
  } else {
    _cl->do_void();
  }
}
```

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\concurrentMarkThread.cpp

```cpp
class CMCheckpointRootsFinalClosure: public VoidClosure {

  ConcurrentMark* _cm;
public:

  void do_void(){
    _cm->checkpointRootsFinal(false);
  }
};
```

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\concurrentMark.cpp

```cpp
// clear_all_soft_refs: 是否清理所有软引用
void ConcurrentMark::checkpointRootsFinal(bool clear_all_soft_refs) {
  // 再标记子阶段需要STW
  assert(SafepointSynchronize::is_at_safepoint(),
         "world should be stopped");

  G1CollectedHeap* g1h = G1CollectedHeap::heap();

  if (has_aborted()) {
    g1h->set_marking_complete();
    return;
  }
  // 告诉GC这是一个非Full GC, 是其他类型的GC
  SvcGCMarker sgcm(SvcGCMarker::OTHER);

  g1h->check_bitmaps("Remark Start");

  G1CollectorPolicy* g1p = g1h->g1_policy();
  g1p->record_concurrent_mark_remark_start();

  // 再标记
  checkpointRootsFinalWork();

  double mark_work_end = os::elapsedTime();
  // 处理引用
  weakRefsWork(clear_all_soft_refs);
  // 判断标记栈是否溢出
  if (has_overflown()) {
    // 溢出则设置重启标志, 之后会重新进行一次并发标记
    _restart_for_overflow = true;
    // 重置标记状态
    reset_marking_state();
  } else {
    // 进行统计
    aggregate_count_data();

    SATBMarkQueueSet& satb_mq_set = JavaThread::satb_mark_queue_set();
    satb_mq_set.set_active_all_threads(false, /* new active value */
                                       true /* expected_active */);

    g1h->check_bitmaps("Remark End");
    // 标记完成, 重置标记状态
    set_non_marking_state();
  }

  // 判断是否需要扩展标记栈
  if (_markStack.should_expand()) {
    _markStack.expand();
  }
}

void ConcurrentMark::reset_marking_state(bool clear_overflow = true) {
  // 设置标记栈需要扩展
  _markStack.set_should_expand();
  // 清空标记栈
  _markStack.setEmpty();
  // 判断是否清除标记栈溢出标记
  if (clear_overflow) {
    clear_has_overflown();
  } else {
    assert(has_overflown(), "pre-condition");
  }
  // 重置全局_finger
  _finger = _heap_start;
  // 清空本地队列
  for (uint i = 0; i < _max_worker_id; ++i) {
    CMTaskQueue* queue = _task_queues->queue(i);
    queue->set_empty();
  }
}

void ConcurrentMark::set_non_marking_state() {
  // 标记完成, 重置标记状态
  reset_marking_state();
  _active_tasks = 0;
  clear_concurrent_marking_in_progress();
}

void ConcurrentMark::checkpointRootsFinalWork() {
  ResourceMark rm;
  HandleMark   hm;
  G1CollectedHeap* g1h = G1CollectedHeap::heap();

  G1RemarkGCTraceTime trace("Finalize Marking", G1Log::finer());

  g1h->ensure_parsability(false);

  if (G1CollectedHeap::use_parallel_gc_threads()) {
    // 多线程标记
    G1CollectedHeap::StrongRootsScope srs(g1h);
    // 使用所有活动线程进行标记
    uint active_workers = g1h->workers()->active_workers();
    if (active_workers == 0) {
      assert(active_workers > 0, "Should have been set earlier");
      active_workers = (uint) ParallelGCThreads;
      g1h->workers()->set_active_workers(active_workers);
    }
    set_concurrency_and_phase(active_workers, false /* concurrent */);

    CMRemarkTask remarkTask(this, active_workers, false /* is_serial */);
    g1h->set_par_threads(active_workers);
    g1h->workers()->run_task(&remarkTask);
    g1h->set_par_threads(0);
  } else {
    // 单线程标记
    G1CollectedHeap::StrongRootsScope srs(g1h);
    uint active_workers = 1;
    set_concurrency_and_phase(active_workers, false /* concurrent */);
    CMRemarkTask remarkTask(this, active_workers, true /* is_serial*/);
    remarkTask.work(0);
  }
  SATBMarkQueueSet& satb_mq_set = JavaThread::satb_mark_queue_set();
  guarantee(has_overflown() ||
            satb_mq_set.completed_buffers_num() == 0,
            err_msg("Invariant: has_overflown = %s, num buffers = %d",
                    BOOL_TO_STR(has_overflown()),
                    satb_mq_set.completed_buffers_num()));

  print_stats();
}

class CMRemarkTask: public AbstractGangTask {
public:
  void work(uint worker_id) {
    if (worker_id < _cm->active_tasks()) {
      CMTask* task = _cm->task(worker_id);
      task->record_start_time();
      {
        ResourceMark rm;
        HandleMark hm;
        // 再次处理所有线程的SATB
        G1RemarkThreadsClosure threads_f(G1CollectedHeap::heap(), task, !_is_serial);
        Threads::threads_do(&threads_f);
      }
      // 重新执行被终止的并发标记过程
      do {
        task->do_marking_step(1000000000.0,
                              true,
                              _is_serial);
      } while (task->has_aborted() && !_cm->has_overflown());
      task->record_end_time();
    }
  }
};
```

> jdk8u60-master\hotspot\src\share\vm\runtime\thread.cpp

```cpp
void Threads::threads_do(ThreadClosure* tc) {
  assert_locked_or_safepoint(Threads_lock);
  ALL_JAVA_THREADS(p) {
    tc->do_thread(p);
  }
  tc->do_thread(VMThread::vm_thread());
  Universe::heap()->gc_threads_do(tc);
  WatcherThread *wt = WatcherThread::watcher_thread();
  if (wt != NULL) {
    tc->do_thread(wt);
  }
}
```

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\concurrentMark.cpp

```cpp
class G1RemarkThreadsClosure : public ThreadClosure {
public:
  void do_thread(Thread* thread) {
    // CMSATBBufferClosure _cm_satb_cl;
    if (thread->is_Java_thread()) {
      // 处理每个Java线程自己的SATB
      if (thread->claim_oops_do(_is_par, _thread_parity)) {
        JavaThread* jt = (JavaThread*)thread;
        // 先对nmethods处理, 主要是为了标识正在运行的方法的栈对象, 以及弱引用的对象
        // 理论上并不需要进行这一步处理, 但实际上JVM很复杂, 
        // 在一些特殊的情况下通过类加载器访问到的对象都应该出现在SATB, 
        // 但是SATB可能存储的对象并不一致, 所以遍历nmenthod再次处理Java线程的SATB
        jt->nmethods_do(&_code_cl);
        // 处理SATB
        jt->satb_mark_queue().apply_closure_and_empty(&_cm_satb_cl);
      }
    } else if (thread->is_VM_thread()) {
      // 处理全局共享的SATB
      if (thread->claim_oops_do(_is_par, _thread_parity)) {
        JavaThread::satb_mark_queue_set().shared_satb_queue()->apply_closure_and_empty(&_cm_satb_cl);
      }
    }
  }
};
```
