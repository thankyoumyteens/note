# 清理子阶段

这个阶段也需要 STW。清理阶段的任务包括: 分区信息计数、额外处理、RSet 清理等。清理阶段通过 VMThread 最终会调用 ConcurrentMark::cleanup()。

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\concurrentMark.cpp

```cpp
void ConcurrentMark::cleanup() {
  assert(SafepointSynchronize::is_at_safepoint(),
         "world should be stopped");
  G1CollectedHeap* g1h = G1CollectedHeap::heap();

  if (has_aborted()) {
    g1h->set_marking_complete();
    return;
  }

  g1h->verify_region_sets_optional();

  g1h->check_bitmaps("Cleanup Start");

  G1CollectorPolicy* g1p = G1CollectedHeap::heap()->g1_policy();
  g1p->record_concurrent_mark_cleanup_start();

  HeapRegionRemSet::reset_for_cleanup_tasks();

  uint n_workers;

  // 对region进行计数
  G1ParFinalCountTask g1_par_count_task(g1h, &_region_bm, &_card_bm);

  if (G1CollectedHeap::use_parallel_gc_threads()) {
    g1h->set_par_threads();
    n_workers = g1h->n_par_threads();
    g1h->workers()->run_task(&g1_par_count_task);
    g1h->set_par_threads(0);
  } else {
    n_workers = 1;
    g1_par_count_task.work(0);
  }

  size_t start_used_bytes = g1h->used();
  g1h->set_marking_complete();

  // 把NextBitMap和PrevBitMap互换
  swapMarkBitMaps();

  g1h->reset_gc_time_stamp();

  // 对region做额外的信息处理
  G1ParNoteEndTask g1_par_note_end_task(g1h, &_cleanup_list);
  if (G1CollectedHeap::use_parallel_gc_threads()) {
    g1h->set_par_threads((int)n_workers);
    g1h->workers()->run_task(&g1_par_note_end_task);
    g1h->set_par_threads(0);
  } else {
    g1_par_note_end_task.work(0);
  }
  g1h->check_gc_time_stamps();

  if (!cleanup_list_is_empty()) {
    g1h->set_free_regions_coming();
  }
  // 通过G1ParScrubRemSetTask并行清理Rset, 这会影响CSet的选择
  // G1ScrubRemSets默认值为true, 这是一个开发选项, 
  // 发布版本不能更改, 只能为true
  if (G1ScrubRemSets) {
    double rs_scrub_start = os::elapsedTime();
    G1ParScrubRemSetTask g1_par_scrub_rs_task(g1h, &_region_bm, &_card_bm);
    if (G1CollectedHeap::use_parallel_gc_threads()) {
      g1h->set_par_threads((int)n_workers);
      g1h->workers()->run_task(&g1_par_scrub_rs_task);
      g1h->set_par_threads(0);
    } else {
      g1_par_scrub_rs_task.work(0);
    }
  }

  // 老年代回收集处理
  g1h->g1_policy()->record_concurrent_mark_cleanup_end((int)n_workers);

  Universe::update_heap_info_at_gc();

  g1h->check_bitmaps("Cleanup End");

  g1h->verify_region_sets_optional();

  g1h->increment_total_collections();

  // ClassUnloadingWithConcurrentMark默认值为true
  if (ClassUnloadingWithConcurrentMark) {
    // 卸载已经加载的类
    ClassLoaderDataGraph::purge();
  }
  MetaspaceGC::compute_new_size();

  // 因为可能回收了空的老年代region, 所以需要更新大小信息
  g1h->g1mm()->update_sizes();
  g1h->allocation_context_stats().update_after_mark();

  g1h->trace_heap_after_concurrent_cycle();
}
```
