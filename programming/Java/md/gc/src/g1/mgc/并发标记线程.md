# 并发标记线程

并发标记的代码在 concurrentMarkThread::run 中。

> jdk8u60-master\hotspot\src\share\vm\gc_implementation\g1\concurrentMarkThread.cpp

```cpp
void ConcurrentMarkThread::run() {

  while (!_should_terminate) {
    // 并发标记线程在创建后并不会立即启动，在一定的条件下才能启动
    sleepBeforeNextCycle();
    if (_should_terminate) {
      break;
    }

    {
      if (!cm()->has_aborted()) {
        // 并发标记启动之后，从Survivor region开始扫描
        _cm->scanRootRegions();
      }

      int iter = 0;
      do {
        iter++;
        if (!cm()->has_aborted()) {
          // 并发标记子阶段
          _cm->markFromRoots();
        }

        if (!cm()->has_aborted()) {
          // 再标记子阶段
          CMCheckpointRootsFinalClosure final_cl(_cm);
          VM_CGC_Operation op(&final_cl, "GC remark", true);
          VMThread::execute(&op);
        }
        // 并发标记时如果栈空间溢出则会继续循环
      } while (cm()->restart_for_overflow());

      if (!cm()->has_aborted()) {
        // 清理子阶段
        CMCleanUp cl_cl(_cm);
        VM_CGC_Operation op(&cl_cl, "GC cleanup", false);
        VMThread::execute(&op);
      } else {
        // 并发标记被终止，设置一些标志
        SuspendibleThreadSetJoiner sts;
        g1h->set_marking_complete();
      }

      {
        SuspendibleThreadSetJoiner sts;
        if (!cm()->has_aborted()) {
          // 通知下一次GC发生时，应该启动Mixed GC
          g1_policy->record_concurrent_mark_cleanup_completed();
        }
      }

      if (!cm()->has_aborted()) {
        // 清理工作之后交换MarkBitmap，
        // 重置nextMarkBitmap，便于下一次并发标记
        SuspendibleThreadSetJoiner sts;
        _cm->clearNextBitmap();
      }
    }
  }

  terminate();
}
```
