# Garbage-First 垃圾回收器

本节描述了 Garbage-First (G1) 垃圾回收器 (GC)。

## 简介

Garbage-First (G1) 垃圾回收器的目标是多处理器的大内存机器。它努力满足垃圾回收的目标暂停时间，同时在几乎不需要配置的情况下实现高吞吐量。G1 的目标是运行在以下类型的应用程序中时, 在延迟和吞吐量之间找到最好的平衡:

- 堆的大小是数十 GB 或更高, 并且 Java 堆的空间中有超过 50% 的存活对象
- 对象分配和晋升的比率可能会随时间显著变化
- 堆中存在大量碎片
- 可预测的暂停时间目标目标不超过几百毫秒，避免长时间的垃圾回收暂停

G1 在应用程序运行的同时执行其部分工作。它交换了本应可供应用程序使用的处理器资源，以换取更短的收集暂停时间。

这在应用程序运行时使用一个或多个处于活动状态的垃圾回收线程时最为明显。因此，与吞吐量回收器相比，虽然 G1 的暂停时间通常要短得多，但应用程序吞吐量也往往更低一些。

G1 是 JDK21 默认的垃圾回收器。

G1 收集器实现了高性能，并通过以下几节中描述的几种方式尽力满足暂停时间目标。

## 启用 G1

Garbage-First 垃圾收集器是默认收集器，因此您通常不必执行任何额外操作。您可以通过在命令行上提供 `-XX:+UseG1GC` 显式启用它。

## 基本概念

G1 是分代的(generational)、增量的(incremental)、并行的(parallel)、大部分是并发的(concurrent)、暂停应用程序线程的(stop-the-world)和采用疏散方式(evacuating)进行垃圾回收的垃圾回收器, 它在每次 stop-the-world 都会监测暂停目标时间。和其它回收器类似, G1 把堆分成了(虚拟的)新生代和老年代。空间回收工作(space-reclamation)主要集中在新生代，因为在那里进行回收最为高效，同时偶尔也会在老年代进行空间回收。

一部分操作总是在 stop-the-world 阶段执行以提高吞吐量。其它会使应用程序停顿更长时间的操作(比如全局标记)是并行执行的, 并且会和应用程序并发执行。为了使回收空间的 stop-the-world 阶段更短, G1 以增量的方式分步进行空间回收，并且是并行执行的。G1 通过跟踪以前的应用行为和垃圾回收停顿的信息来构建一个预计成本(associated costs)的模型，从而实现可预测性。G1 使用这些信息来确定在停顿期间需要完成的工作量。例如，G1 会首先回收那些回收效率最高的区域（即那些几乎全是垃圾的区域）。

G1 主要通过疏散来回收空间: 在选定的内存区域中找到的存活对象会被复制到新的内存区域，并在此过程中进行压缩。疏散完成后，之前被存活对象占用的空间将被应用程序重新用于分配。

Garbage-First 回收器并不是一个实时回收器。它试图在较长的一段时间内以高概率满足设定的停顿时间目标，但并不能总是以绝对确定性保证每一次停顿都能达到这些目标。

### 堆结构

G1 将堆划分为一组大小相等的堆分区(heap regions)，每个分区是一个连续的虚拟内存范围，如图所示。分区是内存分配和内存回收的基本单位。在任何时候，这些分区可以是空的(图中的浅灰色部分)，或者被分配给某个特定的代(新生代或老年代)。随着内存请求的到来，内存管理器会分配空闲的分区。内存管理器将这些分区分配给某个代，然后将其作为空闲空间返回给应用程序，应用程序可以在这些空间中进行分配。

![](../../../img/jsgct_dt_004_grbg_frst_hp.png)

新生代包含伊甸园分区（红色）和幸存者分区（带有 S 的红色）。这些分区提供了与其他回收器中相应连续空间相同的功能，不同之处在于在 G1 中，这些分区通常在内存中以非连续的方式布局。老年代由老年分区（浅蓝色）组成。老年代区域可能是巨大的（带有 H 的浅蓝色），用于存放跨越多个分区的对象。

应用程序总是将对象分配到新生代，即伊甸园分区，例外情况是巨大对象（humongous objects），这些对象会直接分配到老年代。

### 垃圾回收周期

从高层次上看，G1 在两个阶段之间交替进行。仅新生代阶段(young-only phase)包含垃圾回收，这些回收会逐渐将当前可用内存中的对象填满老年代。空间回收阶段(space-reclamation phase)是 G1 在处理新生代的同时，逐步(incrementally)回收老年代中的空间。然后，循环重新开始，进入一个新的仅新生代阶段。

图中概述了这一循环，并给出了可能发生的一系列垃圾回收停顿的示例：

![](../../../img/jsgct_dt_001_grbgcltncyl.png)

以下列表详细描述了 G1 垃圾回收周期的各个阶段、停顿以及阶段之间的转换：

1. young-only 阶段: 此阶段从几次正常的新生代回收(Normal young collection)开始，这些回收将对象晋升(promote)到老年代。当老年代的占用率达到某个阈值（Initiating Heap Occupancy threshold）时，young-only 阶段和 space-reclamation 阶段之间的转换开始。此时，G1 会调度一个并发启动的新生代回收(Concurrent Start young collection)，而不是正常的新生代回收
   - 并发启动(Concurrent Start)：这种类型的回收除了执行正常的新生代回收外，还会启动标记过程(the marking process)。并发标记确定老年代分区中所有当前可到达（存活）的对象，以便在随后的 space-reclamation 阶段保留这些对象。在标记过程完全结束之前，可能会发生正常的新生代回收。标记过程以两个特殊的停顿结束：重新标记（Remark）和清理（Cleanup）。并发启动的停顿还可能决定不需要继续进行标记：在这种情况下，会发生一个简短的并发标记撤销阶段，然后继续 young-only 阶段。在这种情况下，不会发生重新标记和清理的停顿
   - 重新标记（Remark）：这个停顿完成了标记过程本身，执行引用处理(reference processing)和类卸载(class unloading)，回收那些完全为空的分区，并清理内部数据结构。在重新标记和清理之间，G1 计算相关信息，以便后续能够在选定的老年代分区中并发地回收空闲空间，这些操作将在清理停顿中最终完成
   - 清理（Cleanup）：这个停顿确定后续是否会进入 space-reclamation 阶段。如果要进入 space-reclamation 阶段，young-only 阶段将以一次准备混合的新生代回收（Prepare Mixed young collection）结束
2. space-reclamation 阶段：这个阶段由多次新生代回收组成，这些回收不仅处理新生代分区，还疏散老年代分区中的存活对象。这些回收也被称为混合回收（Mixed collections）。space-reclamation 阶段在 G1 确定即使疏散更多的老年代分区也无法获得足够的空闲空间时结束

space-reclamation 之后，回收周期重新开始另一个 young-only 阶段。作为后备，如果应用程序在收集存活信息时耗尽内存，G1 会执行一次原地的 Full GC(in-place stop-the-world full heap compaction)，类似于其他回收器的做法。

### 垃圾回收暂停和回收集

G1 在 stop-the-world 的停顿期间执行垃圾回收和空间回收。存活对象通常从原来的分区复制到堆中的一个或多个目标分区，并且对这些移动过的对象的引用也会被调整。

对于非巨大对象分区，对象的目标分区是根据该对象的原来所在的分区确定的:

- 新生代对象（eden 和 survivor 分区）根据其年龄被复制到 survivor 分区或老年代分区
- 老年代分区中的对象被复制到其他老年代分区

巨大对象分区中的对象则有所不同。G1 只确定它们的存活状态，如果它们是非存活的，则回收它们占用的空间。G1 只有在非常慢的最后手段回收(last-resort collection)过程中才会移动巨大对象。

#### 记忆集

为了疏散回收集，G1 管理一个记忆集（Remembered Set）：这是一个包含从回收集外部指向回收集内部的引用的位置集合。当回收集中的对象在垃圾回收过程中移动时，来自回收集外部对该对象的任何引用都需要更改，以指向该对象的新位置。

记忆集条目(entries)表示的是近似位置，以节省内存: 通常相邻的引用指向相邻的对象。G1 逻辑上将堆划分为卡片（cards），默认每个卡片的大小为 512 字节。记忆集条目是这些卡片的压缩索引。

G1 最初以每个分区为基础管理记忆集：每个分区都包含一个分区记忆集(per-region remembered set)，即包含可能指向该分区的引用的位置集合。在垃圾回收过程中，整个回收集的记忆集是从这些分区记忆集中生成的。

记忆集主要是懒惰地创建的：在重新标记（Remark）和清理（Cleanup）停顿之间，G1 重建所有回收集候选分区的记忆集。除此之外，G1 始终维护新生代分区的记忆集，因为这些分区在每次垃圾回收时都会被处理，默认情况下还包括一些巨大对象以实现急切回收(eager reclaim)。

#### 回收集

回收集是需要从中回收空间的源分区集合。根据垃圾回收的类型，回收集由不同种类的分区组成。

- 在 young-only 阶段，回收集仅包含新生代的分区，以及可能被回收的巨大对象所在的分区
- 在 space-reclamation 阶段，回收集包含新生代的分区、可能被回收的巨大对象所在的分区，以及回收集候选分区中的某些老年代分区

回收集候选分区是那些在 space-reclamation 阶段极有可能被回收的分区。G1 在重新标记（Remark）停顿期间根据这些分区包含的存活数据量及其与其他分区的连接性来选择它们。存活数据较少（大量空闲空间）的分区比大部分为存活数据的分区更受青睐，连接性较低的分区比连接性较高的分区更受青睐，因为回收这些更“高效”的分区所需的精力更小。G1 会从回收集候选分区中剔除那些对空闲内存增益贡献不大的分区。这包括所有可回收空间小于当前堆大小的 `-XX:G1HeapWastePercent` 百分比的分区。G1 在此次 space-reclamation 阶段将不会回收这些分区。

在重新标记（Remark）和清理（Cleanup）停顿之间，G1 会准备这些分区以备后续回收，在清理阶段完成这项工作并根据回收效率对它们进行排序。效率更高的分区，即回收时间较短且包含更多空闲空间的分区，会在后续的混合回收（Mixed collections）中优先被回收。

#### 垃圾回收过程

一次垃圾回收由四个阶段组成:

- 预备疏散回收集(Pre Evacuate Collection Set)阶段执行一些垃圾回收的准备工作: 断开 mutator 线程与 TLAB 的连接，选择本次垃圾回收的回收集（在后文"调整堆大小"中说明），以及其他一些小的准备工作
- 在合并堆根(Merge Heap Roots)阶段，G1 从回收集分区中创建一个统一的记忆集，以便后续进行并行处理。这一步骤从记忆集中去除了许多原本需要在后续以更高代价过滤掉的重复项
- 疏散回收集(Evacuate Collection Set)阶段包含了大部分的工作: G1 从根开始移动对象。根的引用是指从回收集外部指向回收集内的引用，这些引用可能来自某些虚拟机内部的数据结构（外部根）、代码（代码根）或 Java 堆的其余部分（堆根）。对于所有根，G1 将它所引用的回收集中的对象复制到其目标位置，并将这些对象的引用作为新的根进行处理，直到没有更多的根为止。这些阶段各自的时间可以通过使用 `-Xlog:gc+phases=debug` 日志记录选项来观察，分别在扩展根扫描（Ext Root Scanning）、代码根扫描（Code Root Scan）、堆根扫描（Scan Heap Roots）和对象复制（Object Copy）子阶段中查看。G1 可能会根据需要重复主要疏散阶段，以处理可选的回收集
- 疏散回收集后(Post Evacuate Collection Set)阶段包括清理工作，如引用处理和为接下来的 mutator 阶段做准备

这些阶段对应于使用 `-Xlog:gc+phases=info` 日志记录选项打印的阶段。

## Garbage-First 内部

本节描述了 Garbage-First (G1) 垃圾回收器的一些重要细节。

### 调整堆大小
