# Garbage-First 垃圾回收器

本节描述了 Garbage-First (G1) 垃圾回收器 (GC)。

## 简介

Garbage-First (G1) 垃圾回收器的目标是多处理器的大内存机器。它努力满足垃圾回收的目标暂停时间，同时在几乎不需要配置的情况下实现高吞吐量。G1 的目标是运行在以下类型的应用程序中时, 在延迟和吞吐量之间找到最好的平衡:

- 堆的大小是数十 GB 或更高, 并且 Java 堆的空间中有超过 50% 的存活对象
- 对象分配和晋升的比率可能会随时间显著变化
- 堆中存在大量碎片
- 可预测的暂停时间目标目标不超过几百毫秒，避免长时间的垃圾回收暂停

G1 在应用程序运行的同时执行其部分工作。它交换了本应可供应用程序使用的处理器资源，以换取更短的收集暂停时间。

这在应用程序运行时使用一个或多个处于活动状态的垃圾回收线程时最为明显。因此，与吞吐量回收器相比，虽然 G1 的暂停时间通常要短得多，但应用程序吞吐量也往往更低一些。

G1 是 JDK21 默认的垃圾回收器。

G1 收集器实现了高性能，并通过以下几节中描述的几种方式尽力满足暂停时间目标。

## 启用 G1

Garbage-First 垃圾收集器是默认收集器，因此您通常不必执行任何额外操作。您可以通过在命令行上提供 `-XX:+UseG1GC` 显式启用它。

## 基本概念

G1 是分代的(generational)、增量的(incremental)、并行的(parallel)、大部分是并发的(concurrent)、暂停应用程序线程的(stop-the-world)和采用疏散方式(evacuating)进行垃圾回收的垃圾回收器, 它在每次 stop-the-world 都会监测暂停目标时间。和其它回收器类似, G1 把堆分成了(虚拟的)新生代和老年代。空间回收工作(space-reclamation)主要集中在新生代，因为在那里进行回收最为高效，同时偶尔也会在老年代进行空间回收。

一部分操作总是在 stop-the-world 阶段执行以提高吞吐量。其它会使应用程序停顿更长时间的操作(比如全局标记)是并行执行的, 并且会和应用程序并发执行。为了使回收空间的 stop-the-world 阶段更短, G1 以增量的方式分步进行空间回收，并且是并行执行的。G1 通过跟踪以前的应用行为和垃圾回收停顿的信息来构建一个预计成本(associated costs)的模型，从而实现可预测性。G1 使用这些信息来确定在停顿期间需要完成的工作量。例如，G1 会首先回收那些回收效率最高的区域（即那些几乎全是垃圾的区域）。

G1 主要通过疏散来回收空间: 在选定的内存区域中找到的存活对象会被复制到新的内存区域，并在此过程中进行压缩。疏散完成后，之前被存活对象占用的空间将被应用程序重新用于分配。

Garbage-First 回收器并不是一个实时回收器。它试图在较长的一段时间内以高概率满足设定的停顿时间目标，但并不能总是以绝对确定性保证每一次停顿都能达到这些目标。

### 堆结构

G1 将堆划分为一组大小相等的堆分区(heap regions)，每个分区是一个连续的虚拟内存范围，如图所示。分区是内存分配和内存回收的基本单位。在任何时候，这些分区可以是空的(图中的浅灰色部分)，或者被分配给某个特定的代(新生代或老年代)。随着内存请求的到来，内存管理器会分配空闲的分区。内存管理器将这些分区分配给某个代，然后将其作为空闲空间返回给应用程序，应用程序可以在这些空间中进行分配。

![](../../../img/jsgct_dt_004_grbg_frst_hp.png)

新生代包含伊甸园分区（红色）和幸存者分区（带有 S 的红色）。这些分区提供了与其他回收器中相应连续空间相同的功能，不同之处在于在 G1 中，这些分区通常在内存中以非连续的方式布局。老年代由老年分区（浅蓝色）组成。老年代区域可能是巨大的（带有 H 的浅蓝色），用于存放跨越多个分区的对象。

应用程序总是将对象分配到新生代，即伊甸园分区，例外情况是巨大对象（humongous objects），这些对象会直接分配到老年代。

### 垃圾回收周期

从高层次上看，G1 在两个阶段之间交替进行。仅新生代阶段(young-only phase)包含垃圾回收，这些回收会逐渐将当前可用内存中的对象填满老年代。空间回收阶段(space-reclamation phase)是 G1 在处理新生代的同时，逐步(incrementally)回收老年代中的空间。然后，循环重新开始，进入一个新的仅新生代阶段。

图中概述了这一循环，并给出了可能发生的一系列垃圾回收停顿的示例：

![](../../../img/jsgct_dt_001_grbgcltncyl.png)

以下列表详细描述了 G1 垃圾回收周期的各个阶段、停顿以及阶段之间的转换：

1. young-only 阶段: 此阶段从几次正常的新生代回收(Normal young collection)开始，这些回收将对象晋升(promote)到老年代。当老年代的占用率达到某个阈值（Initiating Heap Occupancy threshold）时，young-only 阶段和 space-reclamation 阶段之间的转换开始。此时，G1 会调度一个并发启动的新生代回收(Concurrent Start young collection)，而不是正常的新生代回收
   - 并发启动(Concurrent Start)：这种类型的回收除了执行正常的新生代回收外，还会启动标记过程(the marking process)。并发标记确定老年代分区中所有当前可到达（存活）的对象，以便在随后的 space-reclamation 阶段保留这些对象。在标记过程完全结束之前，可能会发生正常的新生代回收。标记过程以两个特殊的停顿结束：重新标记（Remark）和清理（Cleanup）。并发启动的停顿还可能决定不需要继续进行标记：在这种情况下，会发生一个简短的并发标记撤销阶段，然后继续 young-only 阶段。在这种情况下，不会发生重新标记和清理的停顿
   - 重新标记（Remark）：这个停顿完成了标记过程本身，执行引用处理(reference processing)和类卸载(class unloading)，回收那些完全为空的分区，并清理内部数据结构。在重新标记和清理之间，G1 计算相关信息，以便后续能够在选定的老年代分区中并发地回收空闲空间，这些操作将在清理停顿中最终完成
   - 清理（Cleanup）：这个停顿确定后续是否会进入 space-reclamation 阶段。如果要进入 space-reclamation 阶段，young-only 阶段将以一次准备混合的新生代回收（Prepare Mixed young collection）结束
2. space-reclamation 阶段：这个阶段由多次新生代回收组成，这些回收不仅处理新生代分区，还疏散老年代分区中的存活对象。这些回收也被称为混合回收（Mixed collections）。space-reclamation 阶段在 G1 确定即使疏散更多的老年代分区也无法获得足够的空闲空间时结束

space-reclamation 之后，回收周期重新开始另一个 young-only 阶段。作为后备，如果应用程序在收集存活信息时耗尽内存，G1 会执行一次原地的 Full GC(in-place stop-the-world full heap compaction)，类似于其他回收器的做法。

### 垃圾回收暂停和回收集

G1 在 stop-the-world 的停顿期间执行垃圾回收和空间回收。存活对象通常从原来的分区复制到堆中的一个或多个目标分区，并且对这些移动过的对象的引用也会被调整。

对于非巨大对象分区，对象的目标分区是根据该对象的原来所在的分区确定的:

- 新生代对象（eden 和 survivor 分区）根据其年龄被复制到 survivor 分区或老年代分区
- 老年代分区中的对象被复制到其他老年代分区

巨大对象分区中的对象则有所不同。G1 只确定它们的存活状态，如果它们是非存活的，则回收它们占用的空间。G1 只有在非常慢的最后手段回收(last-resort collection)过程中才会移动巨大对象。

#### 记忆集

为了疏散回收集，G1 管理一个记忆集（Remembered Set）：这是一个包含从回收集外部指向回收集内部的引用的位置集合。当回收集中的对象在垃圾回收过程中移动时，来自回收集外部对该对象的任何引用都需要更改，以指向该对象的新位置。

记忆集条目(entries)表示的是近似位置，以节省内存: 通常相邻的引用指向相邻的对象。G1 逻辑上将堆划分为卡片（cards），默认每个卡片的大小为 512 字节。记忆集条目是这些卡片的压缩索引。

G1 最初以每个分区为基础管理记忆集：每个分区都包含一个分区记忆集(per-region remembered set)，即包含可能指向该分区的引用的位置集合。在垃圾回收过程中，整个回收集的记忆集是从这些分区记忆集中生成的。

记忆集主要是懒惰地创建的：在重新标记（Remark）和清理（Cleanup）停顿之间，G1 重建所有回收集候选分区的记忆集。除此之外，G1 始终维护新生代分区的记忆集，因为这些分区在每次垃圾回收时都会被处理，默认情况下还包括一些巨大对象以实现急切回收(eager reclaim)。

#### 回收集

回收集是需要从中回收空间的源分区集合。根据垃圾回收的类型，回收集由不同种类的分区组成。

- 在 young-only 阶段，回收集仅包含新生代的分区，以及可能被回收的巨大对象所在的分区
- 在 space-reclamation 阶段，回收集包含新生代的分区、可能被回收的巨大对象所在的分区，以及回收集候选分区中的某些老年代分区

回收集候选分区是那些在 space-reclamation 阶段极有可能被回收的分区。G1 在重新标记（Remark）停顿期间根据这些分区包含的存活数据量及其与其他分区的连接性来选择它们。存活数据较少（大量空闲空间）的分区比大部分为存活数据的分区更受青睐，连接性较低的分区比连接性较高的分区更受青睐，因为回收这些更“高效”的分区所需的精力更小。G1 会从回收集候选分区中剔除那些对空闲内存增益贡献不大的分区。这包括所有可回收空间小于当前堆大小的 `-XX:G1HeapWastePercent` 百分比的分区。G1 在此次 space-reclamation 阶段将不会回收这些分区。

在重新标记（Remark）和清理（Cleanup）停顿之间，G1 会准备这些分区以备后续回收，在清理阶段完成这项工作并根据回收效率对它们进行排序。效率更高的分区，即回收时间较短且包含更多空闲空间的分区，会在后续的混合回收（Mixed collections）中优先被回收。

#### 垃圾回收过程

一次垃圾回收由四个阶段组成:

- 预备疏散回收集(Pre Evacuate Collection Set)阶段执行一些垃圾回收的准备工作: 断开 mutator 线程与 TLAB 的连接，选择本次垃圾回收的回收集（在后文"调整堆大小"中说明），以及其他一些小的准备工作
- 在合并堆根(Merge Heap Roots)阶段，G1 从回收集分区中创建一个统一的记忆集，以便后续进行并行处理。这一步骤从记忆集中去除了许多原本需要在后续以更高代价过滤掉的重复项
- 疏散回收集(Evacuate Collection Set)阶段包含了大部分的工作: G1 从根开始移动对象。根的引用是指从回收集外部指向回收集内的引用，这些引用可能来自某些虚拟机内部的数据结构（外部根）、代码（代码根）或 Java 堆的其余部分（堆根）。对于所有根，G1 将它所引用的回收集中的对象复制到其目标位置，并将这些对象的引用作为新的根进行处理，直到没有更多的根为止。这些阶段各自的时间可以通过使用 `-Xlog:gc+phases=debug` 日志记录选项来观察，分别在扩展根扫描（Ext Root Scanning）、代码根扫描（Code Root Scan）、堆根扫描（Scan Heap Roots）和对象复制（Object Copy）子阶段中查看。G1 可能会根据需要重复主要疏散阶段，以处理可选的回收集
- 疏散回收集后(Post Evacuate Collection Set)阶段包括清理工作，如引用处理和为接下来的 mutator 阶段做准备

这些阶段对应于使用 `-Xlog:gc+phases=info` 日志记录选项打印的阶段。

## Garbage-First 内部

本节描述了 Garbage-First (G1) 垃圾回收器的一些重要细节。

### 调整堆大小

G1 在调整 Java 堆大小时遵循标准规则，使用 `-XX:InitialHeapSize` 作为初始 Java 堆大小，`-XX:MaxHeapSize` 作为最大 Java 堆大小，`-XX:MinHeapFreeRatio` 作为最小空闲内存百分比，`-XX:MaxHeapFreeRatio` 用于确定调整大小后的最大空闲内存百分比。G1 仅在重新标记（Remark）和 Full GC 的停顿期间根据这些选项考虑调整 Java 堆大小。此过程可能会向操作系统释放内存或从操作系统申请内存。

堆扩展在回收停顿期间发生，而内存释放则在停顿之后与应用程序并发进行。

#### Young-Only 阶段调整分代的大小

G1 总是在正常新生代回收结束时为下一个 mutator 阶段调整新生代的大小。这样，G1 可以根据实际停顿时间的长期观察来满足使用 `-XX:MaxGCPauseTimeMillis` 和 `-XX:GCPauseIntervalMillis` 设置的目标停顿时间。这个计算考虑了类似大小的新生代疏散所需的时间，包括在回收过程中需要复制的对象数量以及这些对象的互连程度。

`-XX:GCPauseIntervalMillis` 和 `-XX:MaxGCPauseTimeMillis` 选项定义了一个最小的 mutator 利用率(minimum
mutator utilization, MMU)。G1 将尝试在每一个可能的 `-XX:GCPauseIntervalMillis` 时间范围内，最多使用 `-XX:MaxGCPauseTimeMillis` 毫秒来进行垃圾回收停顿。

如果不受到其他限制，G1 会根据 `-XX:G1NewSizePercent` 和 `-XX:G1MaxNewSizePercent` 确定的值之间自适应地调整新生代的大小，以满足目标停顿时间。有关如何解决长时间停顿的更多信息，请参见《Garbage-First 垃圾回收器调优》。

或者，可以使用 `-XX:NewSize` 结合 `-XX:MaxNewSize` 分别设置新生代的最小和最大大小。注意: 只指定这两个选项中的一个会将新生代的大小固定为通过 `-XX:NewSize` 和 `-XX:MaxNewSize` 分别指定的值。这将禁用停顿时间控制。

#### Space-Reclamation 阶段调整分代的大小

在 space-reclamation 阶段，G1 试图在单次垃圾回收停顿中最大化老年代中回收的空间。新生代的大小通常被设置为允许的最小值，通常由 `-XX:G1NewSizePercent` 确定，但也会考虑到最小 mutator 利用率（MMU）的要求。

在这一阶段的每次混合回收开始时，G1 会选择一组回收集候选分区添加到回收集中。这组额外的老年代分区由三部分组成:

- 使用最小老年代分区集合来确保疏散进度。这个老年代分区集合由回收集候选分区的数量除以 space-reclamation 阶段长度来决定, space-reclamation 阶段长度的由 `-XX:G1MixedGCCountTarget` 确定
- 如果 G1 预测在回收最小老年代分区集合后仍有剩余时间，则会从回收集候选分区中添加额外的老年代分区。老年代分区会持续添加，直到预测使用的时间达到剩余时间的 80%
- G1 在疏散了前两部分的分区后，如果此次停顿中仍有剩余时间，还会增量地疏散一组可选的回收集分区

前两组分区在初始回收过程中被回收，而可选回收集中的额外分区则在剩余的停顿时间内进行回收。这种方法确保了空间回收的进度，同时提高了保持停顿时间最短和管理可选回收集的开销最小化的概率。

space-reclamation 阶段在回收集候选分区集合中没有更多分区时结束。

有关 G1 将使用多少个老年代分区以及如何避免长时间的混合回收停顿的更多信息，请参见《Garbage-First 垃圾回收器调优》。

### 周期性的垃圾回收

如果由于应用程序不活跃而导致长时间没有进行垃圾回收，虚拟机可能会长时间持有大量未使用的内存，而这些内存本可以用于其他地方。为了避免这种情况，可以使用 `-XX:G1PeriodicGCInterval` 选项强制 G1 定期进行垃圾回收。此选项决定 G1 考虑执行垃圾回收的最小间隔时间（以毫秒为单位）。如果自上次任何垃圾回收停顿以来已经过去了这个时间间隔，并且没有正在进行的并发周期，G1 会触发额外的垃圾回收，可能的影响包括:

- 在 young-only 阶段: G1 通过并发启动（Concurrent Start）阶段开始并发标记，或者如果指定了 `-XX:-G1PeriodicGCInvokesConcurrent`，则执行一次 Full GC
- 在 space-reclamation 阶段: G1 继续这个阶段，并触发适合当前进度的垃圾回收停顿类型

`-XX:G1PeriodicGCSystemLoadThreshold` 选项可用于细化是否触发垃圾回收：如果 JVM 的宿主系统（例如，容器）上通过 `getloadavg()` 调用返回的平均一分钟系统负载值高于此阈值，则不会运行定期垃圾回收。

有关定期垃圾收集的更多信息，请参见 [JEP 346: Promptly Return Unused Committed Memory from G1](https://openjdk.org/jeps/346)。

### 确定堆的初始占用

初始堆占用百分比(Initiating Heap Occupancy Percent, IHOP)是触发 并发启动回收(Concurrent Start collection)的阈值，它被定义为老年代大小的百分比。

G1 默认情况下通过观察标记过程花费多少时间以及在标记周期中老年代通常分配多少内存，来自动确定一个最优的 IHOP。这一功能被称为自适应 IHOP。如果此功能处于激活状态，则 `-XX:InitiatingHeapOccupancyPercent` 选项会确定初始值，该值为当前老年代大小的百分比，直到有足够的观察数据来预测出更好的 IHOP 阈值。使用 `-XX:-G1UseAdaptiveIHOP` 选项可以关闭 G1 的这一行为。在这种情况下，IHOP 的阈值始终是 `-XX:InitiatingHeapOccupancyPercent` 设置的值。

在内部，自适应的 IHOP 试图设置堆的初始占用，使得 space-reclamation 阶段的第一次混合垃圾回收在老年代的内存占用达到当前最大老年代大小减去 `-XX:G1HeapReservePercent` 的值作为额外的缓冲区。

### 标记

G1 标记使用了一种称为原始快照（Snapshot-At-The-Beginning, SATB）的算法。该算法在初始标记的停顿时对堆进行虚拟快照，此时所有在标记开始时为存活的对象在整个标记过程中都被视为存活的。这意味着在标记过程中变得死亡（不可达）的对象仍然被认为是存活的，无法被空间回收（有一些例外）。这可能导致与其它回收器相比，一些额外的内存被错误地保留。然而，SATB 在重新标记的停顿期间可能提供更低的延迟。在上次标记过程中过于保守地被视为存活的对象将在下一次标记中被回收。有关标记问题的更多信息，请参见《Garbage-First 垃圾回收器调优》。

### 堆内存紧张时的行为

当应用程序存活对象占用了很多的内存，以至于疏散过程无法找到足够的空间来复制对象时，就会发生疏散失败。疏散失败表示 G1 尝试通过保持已移动对象的新位置不变，并且不复制尚未移动的对象，仅调整对象之间的引用，来完成当前的垃圾回收过程。疏散失败可能会带来一些额外的开销，但通常应该和其他新生代回收的速度相当。在发生疏散失败的垃圾回收之后，G1 会恢复应用程序的正常运行，不会采取其他措施。G1 会假设疏散失败发生在垃圾回收接近结束时；也就是说，大多数对象已经移动，并且有足够的空间剩余，可以继续运行应用程序直到标记完成并开始 space-reclamation 阶段。

如果这一假设不成立，那么 G1 最终会调度一次 Full GC。这种类型的回收会对整个堆进行原地整理。这可能会非常慢。

有关分配失败或在报告内存不足之前发生全垃圾收集的问题的更多信息，请参见《Garbage-First 垃圾收集器调优》。

### 大对象

巨大对象是指大小等于或超过半个分区大小的对象。当前的分区大小是根据"G1 GC 的自适应默认值"部分描述的方式自动确定的，除非使用 `-XX:G1HeapRegionSize` 选项进行了设置。

这些巨大对象有时会被特殊处理:

- 每个巨大对象都会在老年代中作为一个连续的分区序列进行分配。对象本身总是位于该序列中第一个分区的起始位置。序列中最后一个分区的任何剩余空间将在整个对象被回收之前都无法用于分配
- 一般来说，巨大对象只能在标记结束时的清理阶段（Cleanup），或 Full GC 中(在它们变得不可达时)被回收。然而，对于基本类型数组（例如，布尔型、各种整数类型和浮点数值）的巨大对象，G1 提供了一个特殊的处理方式。如果这些巨大对象没有被很多对象引用，G1 会在任何类型的垃圾回收停顿期间都会尝试回收它们。这种行为默认是启用的，但你可以使用 `-XX:G1EagerReclaimHumongousObjects` 选项来禁用它
- 巨大对象的分配可能会导致垃圾回收停顿提前发生。G1 在每次巨大对象分配时都会检查初始化堆占用阈值（Initiating Heap Occupancy threshold），如果当前堆占用超过了该阈值，G1 可能会立即强制进行一次带初始标记的新生代回收(initial mark young collection)
- 巨大对象只有在首次 Full GC 未能释放足够连续的内存以供巨大对象分配时，才会在同一个停顿中的第二次 Full GC 过程中尝试移动。这一过程非常缓慢。由于包含巨大对象末尾的堆分区中有不可用的空间，G1 仍有可能因内存不足(out-of-memory)终止虚拟机运行

## G1 GC 的自适应默认值

本主题提供了关于 G1 最重要的默认设置及其默认值的概述。这些默认设置大致说明了在不使用任何额外选项的情况下，使用 G1 时预期的行为和资源使用情况。

| 配置和默认值                                                    | 说明                                                                                                                                                                                                                                                                                                                                                   |
| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| -XX:MaxGCPauseMillis=200                                        | 最大停顿时间目标                                                                                                                                                                                                                                                                                                                                       |
| -XX:GCPauseTimeInterval=`<ergo>`                                | 最大停顿时间间隔的目标。默认情况下，G1 不设置任何目标，以允许 G1 在极端情况下连续进行垃圾回收                                                                                                                                                                                                                                                          |
| -XX:ParallelGCThreads=`<ergo>`                                  | 垃圾回收停顿期间用于并行工作的最大线程数。这一数值根据虚拟机运行的机器上可用的线程数按以下方式得出：如果进程可用的 CPU 线程数少于或等于 8，则使用该数值。否则，将超过 8 的部分线程数的五分之八加到最终的线程数中。在每次停顿开始时，使用的最大线程数还会受到最大总堆大小的限制：G1 使用的线程数不会超过每 `-XX:HeapSizePerGCThread` 大小的内存一个线程 |
| -XX:ConcGCThreads=`<ergo>`                                      | 用于并发工作的最大线程数。默认情况下，这个值是 `-XX:ParallelGCThreads` 的四分之一                                                                                                                                                                                                                                                                      |
| -XX:+G1UseAdaptiveIHOP 和 -XX:InitiatingHeapOccupancyPercent=45 | 开启自适应初始堆占用百分比，并且在最初的几次回收周期中，G1 将使用老年代占用率的 45% 作为标记开始的阈值                                                                                                                                                                                                                                                 |
| -XX:G1HeapRegionSize=`<ergo>`                                   | 堆分区的大小。默认值基于最大堆大小，按大约分成 2048 个分区计算，最大自适应确定的值为 32 MB。用户提供的大小必须是 2 的幂，有效值范围从 1 MB 到 512 MB                                                                                                                                                                                                   |
| -XX:G1NewSizePercent=5 和 -XX:G1MaxNewSizePercent=60            | 新生代的总大小，该大小在这两个值之间变化，作为当前使用中的 Java 堆大小的百分比                                                                                                                                                                                                                                                                         |
| -XX:G1HeapWastePercent=5                                        | 回收集候选分区中允许的不回收的空间的百分比。如果回收集候选分区中的空闲空间低于该值，G1 会停止 space-reclamation 阶段                                                                                                                                                                                                                                   |
| -XX:G1MixedGCCountTarget=8                                      | space-reclamation 阶段预期的持续时间，以回收次数表示                                                                                                                                                                                                                                                                                                   |
| -XX:G1MixedGCLiveThresholdPercent=85                            | 老年代分区中，存活对象占用率高于此百分比的分区在此次 space-reclamation 阶段中不会被回收                                                                                                                                                                                                                                                                |

注意：`<ergo>` 表示实际值是根据环境自适应确定的。

## 和其它回收器对比
