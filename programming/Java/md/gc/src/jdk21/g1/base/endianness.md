# 大端和小端

大端（Big-Endian）和小端（Little-Endian）存储是指计算机中多字节数据类型（如整数、浮点数等）的字节序（byte order）。这两种存储方式定义了在内存中如何排列这些多字节数据的字节。注意: 一个字节的数据不存在大端和小端的问题。

内存由存储单元构成, 存储单元（Memory Cell）是是内存中用于数据存储的最小可寻址空间。每个存储单元可以存储 1 个字节的数据(8 bit), 每一个内存地址对应一个存储单元。

例如一个值为 `0xCAFEBABE` 的 int 数据写入地址为 `0x00000001` 的内存位置, 由于该整数占 4 字节, 因此需要连续使用 4 个存储单元来存储这个整数, 即 `0x00000001`, `0x00000002`, `0x00000003`, `0x00000004`。

## 大端存储（Big-Endian）

在大端存储模式中, 一个多字节值的最高位字节（即“大端”）存储在最低的内存地址处, 而最低位字节（即“小端”）存储在最高的内存地址处。`0xCAFEBABE` (这个数字的最高位是 `0xCA`, 最地位是 `0xBE`)的存储方式为:

| 地址(由高到低) | 数据   |
| -------------- | ------ |
| `0x00000004`   | `0xBE` |
| `0x00000003`   | `0xBA` |
| `0x00000002`   | `0xFE` |
| `0x00000001`   | `0xCA` |

## 小端存储（Little-Endian）

在小端存储模式中, 一个多字节值的最低位字节（即“小端”）存储在最低的内存地址处, 而最高位字节（即“大端”）存储在最高的内存地址处。`0xCAFEBABE` 的存储方式为:

| 地址(由高到低) | 数据   |
| -------------- | ------ |
| `0x00000004`   | `0xCA` |
| `0x00000003`   | `0xFE` |
| `0x00000002`   | `0xBA` |
| `0x00000001`   | `0xBE` |

由于从一个地址取 n 个字节是从低地址向高地址取数据, 因此小端模式取出的数据看起来是倒着的, 例如, 从 `0x00000001` 地址连续取 4 个字节, 会取到 `0xBEBAFECA`。

## 大小端问题产生的原因

大小端问题是由寄存器引起的。

每个存储单元都只能够存储 1 字节的数据。但是现代计算机总线线宽和寄存器的宽度往往都大于 1 个字节, 对于位数大于 8 位的处理器, 例如 32 位或者 64 位的处理器, 寄存器的宽度都是大于一个字节的, 这就造成寄存器宽度与内存的存储单元宽度之间的不一致。

在计算机中, 并不支持直接将数据在不同的内存地址之间传送。CPU 唯一支持不同部件之间的直接数据传送只有寄存器到寄存器。例如, 如果对于 `int x = 10` 这样的代码, 那么最终 CPU 需要先为 x 分配栈空间, 然后将 10 这个立即数传入寄存器, 再通过寄存器吧 10 传送到 x 所在的内存位置。

对于一个占两个字节的整数, 例如 `0x1122`, 数据本身是区分高字节和低字节的, 靠近左侧的字节 `0x11` 为高字节, 靠近右侧的 `0x22` 则为低字节。而一个双字节的寄存器也会区分高低位, 不同的 CPU 对高低位的定位也不同。假设双字节(16 位)的寄存器中从左到右所存储的字节分别是 `0x11` 和 `0x22`, 如果将寄存器的左端定位为高字节端, 则寄存器所存储的数值就是 `0x1122`, 而如果将寄存器的右端定位为高字节端, 那么寄存器所存储的值就是 `0x2211`。

对于代码 `int x = 0x1122`, 在大端 CPU 上运行时, CPU 首先将立即数 `0x1122` 保存到双字节的寄存器中, 由于以大端的方式存储, 因此寄存器中从低位到高位所存储的字节分别是 `0x11` 和 `0x22`。接着 CPU 将寄存器中的数据传送到 x 变量所在的内存位置, 传送后, x 变量所在的 2 个连续的存储单元中的值从低位到高位也分别是 `0x11` 和 `0x22`。

而对于同样的程序, 如果运行在小端 CPU 上, 则寄存器从低位到高位所存储的字节分别是 `0x22` 和 `0x11`, 将其拼接起来得到的数据是 `0x2211`, 于是最终保存到内存中, 在内存中从低位到高位所保存的数值就是 `0x22` 和 `0x11`。

## 验证 CPU 是大端还是小端

```cpp
#include <cstdio>

int main() {
    // 一次性存储4字节
    int magic = 0xCAFEBABE;
    // 按1字节读取
    unsigned char *bytes = (unsigned char *) &magic;
    // 内存地址由低到高输出
    printf("result: 0x%X", bytes[0]);
    printf("%X", bytes[1]);
    printf("%X", bytes[2]);
    printf("%X", bytes[3]);
    return 0;
}
// 输出 result: 0xBEBAFECA 表示是小端存储模式
// 输出 result: 0xCAFEBABE 表示是大端存储模式
```
