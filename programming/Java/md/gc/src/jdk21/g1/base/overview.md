# 总览

## 对象分配

G1 的分配策略: 开启 TLAB 时, JVM 会优先在 TLAB 中分配内存, 当对象在 TLAB 空间分配内存失败时, JVM 会通过 CAS 或加锁直接在堆中分配内存。

## 回收集

回收集(CSet)用来表示那些将要被收集器回收的 Region 集合。

## 记忆集

G1 使用记忆集(RSet)记录对象在不同分区之间的引用关系，目的是为了加速垃圾回收的速度。比如一条赋值语句: `objA.field = objB;` G1 会在 objB 的 RSet 中记录 objA 的地址。

在 G1 中提供了 3 种回收算法: Yong GC, Mixed GC 和 Full GC。这三种算法都会回收新生代分区, 所以新生代分区中只要被根直接/间接引用的对象都会被扫描到, 但在 Mixed GC 中, 老年代只会有某些分区被加入到回收集中, 其余没被选中的老年代分区都被看作是根, 那么需要记录 RSet 的情况就只有两种:

1. 老年代 Region 到新生代 Region 之间有引用关系
2. 老年代 Region 到老年代 Region 之间有引用关系

在线程运行过程中, 如果对象的引用发生了变化(通常就是赋值操作), 就必须要通知 RSet, 更改其中的记录, 但对于一个 Region 来说, 里面的对象有可能被很多 Region 所引用, 这就要求这个 Region 记录所有引用者的信息, 占用大量的空间。

G1 提供了 3 种 RSet 的粒度:

1. 稀疏 PRT(Per Region Table): 通过哈希表方式来存储每个 region 的引用关系, key 是 region index，value 是 card 数组
2. 细粒度 PRT: 当稀疏 PRT 指定 region 的 card 数量超过阈值时，则在细粒度 PRT 中创建一个对应的 PerRegionTable 对象。每个 PRT 包含一个 Region 的起始地址和一个位图, 位图的每一位对应 Region 的 512 字节
3. 粗粒度位图: 当细粒度 PRT size 超过阈值时，所有 region 形成一个位图。位图中的每一位对应一个 Region

## Refine 线程

Refine 线程是的功能:

1. 处理新生代 region 的抽样, 并且在满足响应时间的这个指标下, 控制新生代 region 的数量。通常有一个线程来处理
2. 管理 RSet, 这是 Refine 最主要的功能。RSet 的更新并不是同步完成的, G1 会把所有的引用关系的变化都先放入到一个队列中, 称为 Dirty Card Queue (DCQ), 然后使用线程来消费这个队列以完成 RSet 的更新。DCQ 通过 Dirty Card Queue Set(DCQS) 来管理, 为了能够并发地处理, 每个 Refine 线程只负责 DCQS 中的某几个 DCQ

JVM 在每次给引用类型的字段赋值时, 会插入一个写后屏障(post-write barrier), 在写后屏障中会做下面的处理:

1. 在全局卡表中找到该字段所在的 card, 并设置为 dirty_card(G1 有一个全局卡表, 它的每个 card 都对应某个 Region 中的 512 字节内存, 如果一个 card 变脏, 就说明对应的 region 存在跨分区的引用)
2. 如果当前线程是 Java 线程(每个 Java 线程都有一个自己的 DCQ), 把该 card 插入线程内部的 DCQ。否则把该 card 插入所有线程共享的全局 DCQ

## Young GC

在创建对象的时候, 如果内存空间不足, 会优先触发新生代回收(Young GC, YGC)。

Young GC 的回收过程:

1. 暂停其他线程(STW)
2. 选择回收集(CSet): 对于 YGC 来说是所有的新生代分区
3. 根处理: 把 GC Roots 直接引用的对象复制到新的分区, 然后把这些对象的所有字段加入队列等待后续的处理
4. RSet 处理: 把 RSet 当成根, 把直接引用的对象复制到新的分区, 然后把这些对象的所有字段加入队列等待后续的处理
5. 复制: 把队列中的字段引用的对象递归复制到新的分区(或者晋升到老年代)
6. Redirty: 重构 RSet, 因为对象已经移动到新的分区, 需要更新老年代分区到新分区的指针
7. 释放空间: 把新的分区设置为 Survivor, 清空原来的分区
8. 调整新生代分区的数量以匹配目标停顿时间
9. 恢复其他线程(STW 结束)

## Mixed GC

混合回收(Mixed GC)分为两个阶段: 并发标记和垃圾回收。

### 并发标记

1. 初始标记: 标记由根集合直接可达的所有对象, 初始标记需要 STW。实际上, 初始标记借用了 Young GC 的结果, 将 Young GC 后的 Survivor 分区和老年代中的 GC Roots 作为根, 所以 Mixed GC 一定发生在 Young GC 之后, 且不需要再进行一次初始标记
2. 并发标记: 当 Young GC 执行结束之后, 如果发现满足并发标记的条件, 并发线程就会根据新生代的 Survivor 分区以及老年代分区中的 RSet 开始并发标记。并发标记会对所有的分区进行标记。这个阶段并不需要 STW, 标记线程和 Java 线程并发运行
3. 再标记: 需要 STW。处理并发标记期间产生的引用变更
4. 清理: 需要 STW。清除空闲分区, 空闲分区是指全都是垃圾对象的 region, 清除只是把空闲分区加入到空闲列表, G1 在后续申请新分区时可以直接从空闲列表中拿一个分区来用, 这个阶段不会真的清理空闲分区内的数据, 因为分区内都是垃圾, 使用的时候直接用新数据覆盖旧数据即可。如果 region 中还有存活对象则不会在这个阶段清理, 而是在垃圾回收阶段处理

### 垃圾回收

Mixed GC 的垃圾回收会复用 Young GC 的代码(只是 CSet 有区别):

1. 从所有 region 中选出若干个 region 进行回收组成 CSet
2. 把这些 region 中存活的对象复制到空闲的 region 中

由于复用 Young GC 的代码, 所以 Mixed GC 的垃圾回收总是要在下一次 Young GC 开始后才会发生。

## 三色标记过程

在三色标记算法中, 对象被标记为三个不同的颜色:

1. 白色: 表示对象尚未被垃圾回收器扫描过。在刚刚开始的阶段, 所有的对象都是白色的, 若在标记结束后, 仍然是白色, 即代表这个对象可以回收
2. 灰色: 表示对象已经被垃圾回收器扫描过, 但这个对象上至少存在一个引用还没有被扫描过
3. 黑色: 表示对象已经被垃圾回收器扫描过, 且这个对象的所有引用都已经被扫描过

从根集合开始, 将其标记为灰色, 并将其放入待处理队列中。然后从待处理队列中取出对象, 将其标记为黑色, 并扫描其引用的所有对象。如果发现新的未被扫描的对象, 将其标记为灰色并放入待处理队列中。这个过程一直重复, 直到待处理队列为空。

## 原始快照(SATB)

如果用户线程在标记进行时并发修改了引用关系, 就可能导致漏标。当扫描到灰色对象的引用变更时, 会将这个引用变更前的对象保存到一个集合里。等到再标记阶段, 会扫描这个集合, 把里面的对象标记为灰色。
