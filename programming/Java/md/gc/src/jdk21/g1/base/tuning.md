# Garbage-First 垃圾回收器调优

本节描述了如何在 G1 垃圾回收器（G1 GC）不符合您的要求时调整其行为。

## 推荐设置

一般的建议是使用 G1 的默认设置，如果需要，可以指定不同的停顿时间目标, 或者通过设置 `-Xmx` 来指定最大 Java 堆大小。

G1 的默认设置与其他回收器有所不同。G1 在默认配置下的目标既不是最大化吞吐量，也不是最低延迟，而是以较高的吞吐量提供相对较小且均匀的停顿时间。然而，G1 用于增量回收堆空间和控制停顿时间的机制会在应用程序线程和空间回收效率方面产生一些开销。

如果你偏好高吞吐量，可以通过使用 `-XX:MaxGCPauseMillis` 放宽停顿时间目标，或者提供更大的堆。如果延迟是主要要求，则修改停顿时间目标。避免使用 `-Xmn`、`-XX:NewRatio` 等选项将新生代大小限制为特定值，因为新生代大小是 G1 满足停顿时间目标的主要手段。将新生代大小设置为单一值会覆盖并实际上禁用停顿时间控制。

## 从其它回收器迁移到 G1

通常，从其他回收器（特别是并发标记清除回收器）切换到 G1 时，首先应移除所有影响垃圾回收的选项，仅设置停顿时间目标和使用 `-Xmx` 设置总体堆大小，必要时可以使用 `-Xms`。

许多对其他回收器用于以某种特定方式响应的有用的选项，对 G1 要么完全没有效果，要么甚至会降低吞吐量和满足停顿时间目标的可能性。一个例子是设置新生代大小，这会完全阻止 G1 调整新生代大小以满足停顿时间目标。

## 提高 G1 性能

G1 被设计为在不需要指定额外选项的情况下提供良好的整体性能。然而，有时候默认的启发式方法(heuristics)或默认配置可能会导致次优的结果。本节提供了一些关于诊断和改进这些情况的指南。本指南仅描述了在给定的应用程序中，G1 提供的改进垃圾回收器性能的方法，这些方法针对的是某个选定的度量指标。在具体情况下，应用程序级别的优化可能比尝试调整虚拟机以获得更好的性能更为有效，例如，通过减少长生命周期对象的使用来避免某些问题。

为了诊断，G1 提供了全面的日志记录。一个好的起点是使用 `-Xlog:gc*=debug` 选项，然后根据需要细化输出。日志提供了在停顿期间及之外关于垃圾回收活动的详细概览，包括回收的类型以及在各个停顿阶段所花费时间的细分。

以下小节探讨了一些常见的性能问题。

## 观察 Full GC

全堆垃圾回收（Full GC）通常非常耗时。由老年代堆占用率过高引起的 Full GC 可以通过在日志中查找 _Pause Full (G1 Compaction Pause)_ 字样来检测。通常，Full GC 之前会有标记为 _(Evacuation Failure)_ 的垃圾回收，这表明发生了疏散失败。

Full GC 发生的原因是应用程序分配了太多无法被及时回收的对象。通常，这是因为并发标记未能及时完成，导致无法开始 space-reclamation 阶段。发生 Full GC 的概率可能会因为大量巨大对象的分配而增加。由于这些对象在 G1 中的分配方式，它们可能会占用比预期更多的内存。

应该确保并发标记能够按时完成。这可以通过降低老年代的分配速率，或者给予并发标记更多的时间来实现。

G1 提供了多个选项来更好地处理这种情况:

- 你可以通过 `gc+heap=info` 日志来确定 Java 堆中被巨大对象占用的分区数量。在日志行 _Humongous regions: X->Y_ 中，Y 表示被巨大对象占用的分区数量。如果这个数字相对于老年代分区的数量较高，最佳选项是尝试减少这些对象的数量。你可以通过增大分区大小（使用 `-XX:G1HeapRegionSize` 选项）来实现这一目标。当前选择的堆分区大小会在日志开始处打印出来
- 增加 Java 堆的大小。这通常会增加标记过程完成所需的时间，因为更大的堆意味着有更多的空间需要被标记和处理
- 通过显式设置 `-XX:ConcGCThreads` 来增加并发标记线程的数量
- 强制 G1 更早开始标记。G1 会根据之前的应用程序行为自动确定初始化堆占用百分比（IHOP）阈值。如果应用程序行为发生变化，这些预测可能会不准确。有两种选择: 通过修改 `-XX:G1ReservePercent` 来增加自适应 IHOP 计算中使用的缓冲区，从而降低开始 space-reclamation 的目标占用率。或者，通过使用 `-XX:-G1UseAdaptiveIHOP` 禁用 IHOP 的自适应计算，并通过 `-XX:InitiatingHeapOccupancyPercent` 手动设置 IHOP。这样可以确保 G1 在更早的时间点开始标记过程，以适应新的应用程序行为或避免 Full GC

除了分配失败（Allocation Failure）之外的原因导致的 Full GC 通常表明，可能是应用程序或某些外部工具触发了整个堆的回收。如果原因是 `System.gc()`，并且没有方法修改应用程序源代码，可以通过使用 `-XX:+ExplicitGCInvokesConcurrent` 来缓解 Full GC 的影响，或者通过设置 `-XX:+DisableExplicitGC` 让虚拟机完全忽略这些 Full GC 请求。外部工具仍可能强制执行 Full GC, 要避免这种情况，只能通过不发起 Full GC 请求来解决。

## 巨大对象碎片化

由于需要为巨大对象找到一组连续的分区，即使并非所有的 Java 堆内存已被耗尽，也可能发生 Full GC。在这种情况下，可以考虑以下选项：

- 使用 `-XX:G1HeapRegionSize` 选项增大堆分区大小，以减少巨大对象的数量
- 增大堆的大小

在极端情况下，即使可用内存显示还有剩余，G1 也可能因为找不到足够的连续空间而无法分配巨大对象。如果这次 Full GC 不能回收足够的连续空间，将会导致虚拟机退出。因此，除了减少巨大对象的分配量或增大堆大小之外，没有其他的解决方案。

## 优化延迟

本节提供了在遇到常见延迟问题(即当停顿时间过长时)时改善 G1 行为的提示。

### 非常规系统或实时使用情况
