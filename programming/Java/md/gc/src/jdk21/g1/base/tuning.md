# Garbage-First 垃圾回收器调优

本节描述了如何在 G1 垃圾回收器（G1 GC）不符合您的要求时调整其行为。

## 推荐设置

一般的建议是使用 G1 的默认设置，如果需要，可以指定不同的停顿时间目标, 或者通过设置 `-Xmx` 来指定最大 Java 堆大小。

G1 的默认设置与其他回收器有所不同。G1 在默认配置下的目标既不是最大化吞吐量，也不是最低延迟，而是以较高的吞吐量提供相对较小且均匀的停顿时间。然而，G1 用于增量回收堆空间和控制停顿时间的机制会在应用程序线程和空间回收效率方面产生一些开销。

如果你偏好高吞吐量，可以通过使用 `-XX:MaxGCPauseMillis` 放宽停顿时间目标，或者提供更大的堆。如果延迟是主要要求，则修改停顿时间目标。避免使用 `-Xmn`、`-XX:NewRatio` 等选项将新生代大小限制为特定值，因为新生代大小是 G1 满足停顿时间目标的主要手段。将新生代大小设置为单一值会覆盖并实际上禁用停顿时间控制。

## 从其它回收器迁移到 G1

通常，从其他回收器（特别是并发标记清除回收器）切换到 G1 时，首先应移除所有影响垃圾回收的选项，仅设置停顿时间目标和使用 `-Xmx` 设置总体堆大小，必要时可以使用 `-Xms`。

许多对其他回收器用于以某种特定方式响应的有用的选项，对 G1 要么完全没有效果，要么甚至会降低吞吐量和满足停顿时间目标的可能性。一个例子是设置新生代大小，这会完全阻止 G1 调整新生代大小以满足停顿时间目标。

## 提高 G1 性能

G1 被设计为在不需要指定额外选项的情况下提供良好的整体性能。然而，有时候默认的启发式方法(heuristics)或默认配置可能会导致次优的结果。本节提供了一些关于诊断和改进这些情况的指南。本指南仅描述了在给定的应用程序中，G1 提供的改进垃圾回收器性能的方法，这些方法针对的是某个选定的度量指标。在具体情况下，应用程序级别的优化可能比尝试调整虚拟机以获得更好的性能更为有效，例如，通过减少长生命周期对象的使用来避免某些问题。

为了诊断，G1 提供了全面的日志记录。一个好的起点是使用 `-Xlog:gc*=debug` 选项，然后根据需要细化输出。日志提供了在停顿期间及之外关于垃圾回收活动的详细概览，包括回收的类型以及在各个停顿阶段所花费时间的细分。

以下小节探讨了一些常见的性能问题。

## 观察 Full GC

全堆垃圾回收（Full GC）通常非常耗时。由老年代堆占用率过高引起的 Full GC 可以通过在日志中查找 _Pause Full (G1 Compaction Pause)_ 字样来检测。通常，Full GC 之前会有标记为 _(Evacuation Failure)_ 的垃圾回收，这表明发生了疏散失败。

Full GC 发生的原因是应用程序分配了太多无法被及时回收的对象。通常，这是因为并发标记未能及时完成，导致无法开始 space-reclamation 阶段。发生 Full GC 的概率可能会因为大量巨大对象的分配而增加。由于这些对象在 G1 中的分配方式，它们可能会占用比预期更多的内存。

应该确保并发标记能够按时完成。这可以通过降低老年代的分配速率，或者给予并发标记更多的时间来实现。

G1 提供了多个选项来更好地处理这种情况:

- 你可以通过 `gc+heap=info` 日志来确定 Java 堆中被巨大对象占用的分区数量。在日志行 _Humongous regions: X->Y_ 中，Y 表示被巨大对象占用的分区数量。如果这个数字相对于老年代分区的数量较高，最佳选项是尝试减少这些对象的数量。你可以通过增大分区大小（使用 `-XX:G1HeapRegionSize` 选项）来实现这一目标。当前选择的堆分区大小会在日志开始处打印出来
- 增加 Java 堆的大小。这通常会增加标记过程完成所需的时间，因为更大的堆意味着有更多的空间需要被标记和处理
- 通过显式设置 `-XX:ConcGCThreads` 来增加并发标记线程的数量
- 强制 G1 更早开始标记。G1 会根据之前的应用程序行为自动确定初始化堆占用百分比（IHOP）阈值。如果应用程序行为发生变化，这些预测可能会不准确。有两种选择: 通过修改 `-XX:G1ReservePercent` 来增加自适应 IHOP 计算中使用的缓冲区，从而降低开始 space-reclamation 的目标占用率。或者，通过使用 `-XX:-G1UseAdaptiveIHOP` 禁用 IHOP 的自适应计算，并通过 `-XX:InitiatingHeapOccupancyPercent` 手动设置 IHOP。这样可以确保 G1 在更早的时间点开始标记过程，以适应新的应用程序行为或避免 Full GC

除了分配失败（Allocation Failure）之外的原因导致的 Full GC 通常表明，可能是应用程序或某些外部工具触发了整个堆的回收。如果原因是 `System.gc()`，并且没有方法修改应用程序源代码，可以通过使用 `-XX:+ExplicitGCInvokesConcurrent` 来缓解 Full GC 的影响，或者通过设置 `-XX:+DisableExplicitGC` 让虚拟机完全忽略这些 Full GC 请求。外部工具仍可能强制执行 Full GC, 要避免这种情况，只能通过不发起 Full GC 请求来解决。

## 巨大对象碎片化

由于需要为巨大对象找到一组连续的分区，即使并非所有的 Java 堆内存已被耗尽，也可能发生 Full GC。在这种情况下，可以考虑以下选项：

- 使用 `-XX:G1HeapRegionSize` 选项增大堆分区大小，以减少巨大对象的数量
- 增大堆的大小

在极端情况下，即使可用内存显示还有剩余，G1 也可能因为找不到足够的连续空间而无法分配巨大对象。如果这次 Full GC 不能回收足够的连续空间，将会导致虚拟机退出。因此，除了减少巨大对象的分配量或增大堆大小之外，没有其他的解决方案。

## 优化延迟

本节提供了在遇到常见延迟问题(即当停顿时间过长时)时改善 G1 行为的提示。

### 非常规系统或实时使用情况

对于每一次垃圾回收停顿，`gc+cpu=info` 日志输出中都包含一行来自操作系统的详细信息，显示了停顿时间内的时间是如何花费的。这样的输出示例为 `User=0.19s Sys=0.00s Real=0.01s`。

用户时间(`User`)是指花费在虚拟机代码中的时间，系统时间(`Sys`)是指花费在操作系统中的时间，而实际时间(`Real`)是指停顿期间经过的绝对时间。如果系统时间相对较高，则通常说明环境是导致这种情况的原因。

常见的导致高系统时间的问题包括:

- 虚拟机从操作系统分配或释放内存可能会造成不必要的延迟。可以通过使用 `-Xms` 和 `-Xmx` 选项将最小和最大堆大小设置为相同的值，并使用 `-XX:+AlwaysPreTouch` 选项预触(pre-touching)所有内存，以避免这些延迟，这样可以将这项工作移到虚拟机启动阶段
- 特别是在 Linux 中，透明大页面（Transparent Huge Pages, THP）特性将小页面合并为大页面的过程往往会随机使进程停滞，而不仅仅是在停顿期间。因为虚拟机分配和管理大量内存，所以存在比平时更高的风险，即虚拟机可能成为长时间停滞的进程。建议参考操作系统的文档，了解如何禁用 THP 特性
- 输出日志可能会由于某些后台任务间歇性地占用所有写入日志的硬盘的 I/O 带宽而暂时停滞。建议为日志使用单独的磁盘或其它存储方式，比如基于内存的文件系统，以避免此类问题

pre-touching 是指在程序启动时，主动访问（即触摸）分配给应用程序的内存页面，从而触发操作系统加载这些页面到物理内存中。这个过程通常发生在虚拟机启动阶段或应用程序初始化期间。

另一种需要注意的情况是，如果实际时间（Real time）比用户时间和系统时间的总和大很多，这可能表明虚拟机在可能过载的机器上没有获得足够的 CPU 时间。

### 引用对象处理耗时过长

处理关于引用对象所花费的时间信息会在 引用处理阶段(Reference Processing phase) 显示。在此阶段，G1 根据特定类型引用对象的要求更新其引用目标。默认情况下，G1 使用以下启发式规则尝试并行化引用处理的子阶段：对于每 `-XX:ReferencesPerThread` 个引用对象启动一个线程，但最多不会超过 `-XX:ParallelGCThreads` 所指定的数量。可以将 `-XX:ReferencesPerThread` 设置为 0 来禁用该启发式规则，默认使用所有可用线程，或者通过 `-XX:-ParallelRefProcEnabled` 完全禁用并行化。

### young-only 阶段中的新生代回收耗时过长

正常的新生代回收，以及一般而言任何针对新生代的回收，大致上所花费的时间与新生代的大小成正比，或者更具体地说，与回收集中需要复制的存活对象数量成正比。如果 疏散回收集阶段（Evacuate Collection Set phase）耗时过长，特别是对象复制子阶段（Object Copy sub-phase）耗时过长，可以减小 `-XX:G1NewSizePercent` 的值。这会减少新生代的最小大小，允许有更短的停顿时间。

如果应用程序性能突然变化，特别是每次回收后存活对象的数量发生变化，可能会导致垃圾回收停顿时间的骤增。这时可以考虑使用 `-XX:G1MaxNewSizePercent` 减小新生代的最大大小，进而减少停顿期间需要处理的对象数量，有助于避免垃圾回收停顿时间的突然增加。

### 混合回收耗时过长

混合新生代回收用于回收老年代中的空间。混合回收的回收集包含新生代和老年代的分区。您可以通过启用 `gc+ergo+cset=debug` 日志来获取关于疏散新生代或老年代分区各自对停顿时间影响的信息。查找类似如下的日志消息:

```
Added young regions to CSet. [...] predicted eden time: 4.86ms, predicted base time: 9.98ms, target pause time: 200.00ms, [...]
```

eden time 和 base time 一起给出了预测的新生代分区时间，也就是 G1 预期疏散新生代所需的时间。

预测老年代分区时间的日志消息看起来如下:

```
Finish choosing collection set old regions. [...] predicted initial time: 147.70ms, predicted optional time: 15.45ms, [...]
```

其中 predicted initial time 表示预测的老年代分区时间，也就是 G1 预期疏散最小集合的老年代分区所需的时间。

如果预测的新生代分区时间过长，请参阅“young-only 阶段中的新生代回收耗时过长”中的配置项。否则，为了减少老年代分区对停顿时间的影响，G1 提供了以下三个选项:

- 通过增加 `-XX:G1MixedGCCountTarget`，可以将老年代分区的回收工作分散到更多的垃圾回收周期中，以此来减少每次垃圾回收时的老年代回收压力
- 通过设置 `-XX:G1MixedGCLiveThresholdPercent`，可以避免将回收耗时比例较大的分区加入候选回收集，从而不对其进行回收。在很多情况下，高度占用的分区（即包含大量存活对象的分区）会需要较多的时间来回收
- 提前结束老年代的空间回收，以避免 G1 回收过多的高度占用分区。在这种情况下，可以通过增加 `-XX:G1HeapWastePercent` 来实现。这允许堆中有更多的“浪费”空间，从而减少对高度占用分区的回收，有助于缩短垃圾回收的停顿时间

请注意，最后两个选项会减少当前 space-reclamation 阶段中可以回收空间的回收集候选分区的数量。这意味着 G1 可能无法在老年代中回收足够的空间以支持持续操作。不过，后续的 space-reclamation 阶段可能能够对这些分区进行垃圾回收。

### 垃圾回收连续发生

G1 默认的 MMU 设置允许垃圾回收连续发生。`-XX:GCPauseIntervalMillis` 的默认值仅略高于 `-XX:MaxGCPauseMillis`。如果观察到垃圾回收连续不断进行，导致应用程序无法正常推进，应将 `-XX:GCPauseIntervalMillis` 的值增加到一个合适的数值。这样，G1 将会尝试更加分散地安排垃圾回收，以避免连续的垃圾回收事件。

### 较高的合并堆根（Merge Heap Roots）和扫描堆根（Scan Heap Roots）时间

减少这些阶段耗时的一种方法是减少合并后记忆集中的条目数量。通过使用 `-XX:G1HeapRegionSize` 选项调整堆分区的大小，可以降低跨分区引用的数量，从而减少记忆集的大小。较大的分区通常会有更少的跨分区引用，因此在处理这些引用时所花费的相对工作量会减少。然而，这也可能导致每个分区中有更多的存活对象需要疏散，进而可能增加其他阶段所需的时间。

如果垃圾回收过程中的大量时间(超过 60%)被花费在合并堆根和扫描堆根这两个阶段，可以通过减小 `-XX:GCCardSizeInBytes` 选项的值来降低记忆集条目的粒度。更细的粒度能够减少查找引用所需的工作量，不过这将以增加一些额外内存使用为代价。

与应用程序分配大型对象相关的异常高的扫描堆根时间，可能是由一个旨在通过批处理减少并发记忆集更新工作量的优化所导致的。如果这种批处理恰好发生在垃圾回收之前，可能会对合并堆根的时间产生负面影响。可以通过使用 `-XX:-ReduceInitialCardMarks` 禁用该优化，以潜在地避免这种情况。

## 优化吞吐量

G1 的默认策略尝试在吞吐量和延迟之间保持平衡；然而，在某些情况下，更高的吞吐量是更为理想的。除了按照前几节描述的方法减少总的停顿时间外，还可以通过减少停顿的频率来提高吞吐量。主要的方法是通过 `-XX:MaxGCPauseMillis` 增加最大停顿时间。G1 会根据这个设置自动调整新生代的大小，而新生代的大小直接决定了停顿发生的频率。如果这一调整未能带来预期的行为，尤其是在 space-reclamation 阶段，可以使用 `-XX:G1NewSizePercent` 增加最小新生代大小，以强制 G1 调整新生代的大小，进而减少停顿的频率。

在某些情况下，`-XX:G1MaxNewSizePercent`（即最大允许的新生代大小）可能会因为限制了新生代的大小而影响吞吐量。这种情况可以通过检查 `gc+heap=info` 日志中的分区摘要输出来诊断。如果 eden 区和 survivor 区的合计百分比接近于总分区数的 `-XX:G1MaxNewSizePercent` 百分比，则可以考虑增加 `-XX:G1MaxNewSizePercent` 的值，以放宽对新生代大小的限制，从而可能提高吞吐量。

另一种增加吞吐量的方法是减少并发工作的量。特别是，并发记忆集更新常常需要大量的 CPU 资源。通过使用 `-XX:G1RSetUpdatingPauseTimePercent` 选项，可以将一部分工作从并发操作转移到垃圾回收的停顿期间完成。这可以在一定程度上减轻并发阶段对 CPU 的压力，从而可能提高整体吞吐量。

增加这个值可能会减少与应用程序并发执行的优化工作量，相反，减少这个值可能会增加与应用程序并发执行的优化工作量。

当启用 `gc+phases=debug` 日志记录时，垃圾回收停顿期间的细化工作会在“合并堆根”（Merge Heap Roots）阶段的“日志缓冲区”（Log Buffers）部分被跟踪。这允许更详细地监控和分析在垃圾回收暂停期间执行的细化工作的量和效率。

通过使用 `-XX:+UseLargePages` 启用大页面的使用也可能提高吞吐量。请参阅您的操作系统文档，了解如何设置大页面。

您可以通过禁用堆大小调整来最小化与此相关的工作，方法是将 `-Xms` 和 `-Xmx` 选项设置为相同的值。此外，使用 `-XX:+AlwaysPreTouch` 可以在虚拟机启动时就将所有分配的内存页面预加载到物理内存中，即将操作系统分配虚拟内存的工作提前到虚拟机启动阶段。这两项措施可以特别有助于使停顿时间更加一致。

## 调整堆大小

与其他垃圾回收器一样，G1 也旨在根据 `-XX:GCTimeRatio` 选项确定的比例来调整堆的大小，从而确保用于垃圾回收的时间占比保持在这个比例之下。您可以调整这个选项，使 G1 的行为符合您的具体要求。例如，减少 `-XX:GCTimeRatio` 的值可以要求 G1 将更少的时间用于垃圾回收，反之亦然。

## 可调整的默认值
