# Garbage-First 垃圾回收器调优

本节描述了如何在 G1 垃圾回收器（G1 GC）不符合您的要求时调整其行为。

## 推荐设置

一般的建议是使用 G1 的默认设置，如果需要，可以指定不同的停顿时间目标, 或者通过设置 `-Xmx` 来指定最大 Java 堆大小。

G1 的默认设置与其他回收器有所不同。G1 在默认配置下的目标既不是最大化吞吐量，也不是最低延迟，而是以较高的吞吐量提供相对较小且均匀的停顿时间。然而，G1 用于增量回收堆空间和控制停顿时间的机制会在应用程序线程和空间回收效率方面产生一些开销。

如果你偏好高吞吐量，可以通过使用 `-XX:MaxGCPauseMillis` 放宽停顿时间目标，或者提供更大的堆。如果延迟是主要要求，则修改停顿时间目标。避免使用 `-Xmn`、`-XX:NewRatio` 等选项将新生代大小限制为特定值，因为新生代大小是 G1 满足停顿时间目标的主要手段。将新生代大小设置为单一值会覆盖并实际上禁用停顿时间控制。

## 从其它回收器迁移到 G1

通常，从其他回收器（特别是并发标记清除回收器）切换到 G1 时，首先应移除所有影响垃圾回收的选项，仅设置停顿时间目标和使用 `-Xmx` 设置总体堆大小，必要时可以使用 `-Xms`。

许多对其他回收器用于以某种特定方式响应的有用的选项，对 G1 要么完全没有效果，要么甚至会降低吞吐量和满足停顿时间目标的可能性。一个例子是设置新生代大小，这会完全阻止 G1 调整新生代大小以满足停顿时间目标。

## 提高 G1 性能

G1 被设计为在不需要指定额外选项的情况下提供良好的整体性能。然而，有时候默认的启发式方法(heuristics)或默认配置可能会导致次优的结果。本节提供了一些关于诊断和改进这些情况的指南。本指南仅描述了在给定的应用程序中，G1 提供的改进垃圾回收器性能的方法，这些方法针对的是某个选定的度量指标。在具体情况下，应用程序级别的优化可能比尝试调整虚拟机以获得更好的性能更为有效，例如，通过减少长生命周期对象的使用来避免某些问题。

为了诊断，G1 提供了全面的日志记录。一个好的起点是使用 `-Xlog:gc*=debug` 选项，然后根据需要细化输出。日志提供了在停顿期间及之外关于垃圾回收活动的详细概览，包括回收的类型以及在各个停顿阶段所花费时间的细分。

以下小节探讨了一些常见的性能问题。

## 观察 Full GC

全堆垃圾回收（Full GC）通常非常耗时。由老年代堆占用率过高引起的 Full GC 可以通过在日志中查找 _Pause Full (G1 Compaction Pause)_ 字样来检测。通常，Full GC 之前会有标记为 _(Evacuation Failure)_ 的垃圾回收，这表明发生了疏散失败。

Full GC 发生的原因是应用程序分配了太多无法被及时回收的对象。通常，这是因为并发标记未能及时完成，导致无法开始 space-reclamation 阶段。发生 Full GC 的概率可能会因为大量巨大对象的分配而增加。由于这些对象在 G1 中的分配方式，它们可能会占用比预期更多的内存。

应该确保并发标记能够按时完成。这可以通过降低老年代的分配速率，或者给予并发标记更多的时间来实现。

G1 提供了多个选项来更好地处理这种情况:

- 你可以通过 `gc+heap=info` 日志来确定 Java 堆中被巨大对象占用的分区数量。在日志行 _Humongous regions: X->Y_ 中，Y 表示被巨大对象占用的分区数量。如果这个数字相对于老年代分区的数量较高，最佳选项是尝试减少这些对象的数量。你可以通过增大分区大小（使用 `-XX:G1HeapRegionSize` 选项）来实现这一目标。当前选择的堆分区大小会在日志开始处打印出来
- 增加 Java 堆的大小。这通常会增加标记过程完成所需的时间，因为更大的堆意味着有更多的空间需要被标记和处理
- 通过显式设置 `-XX:ConcGCThreads` 来增加并发标记线程的数量
- 强制 G1 更早开始标记。G1 会根据之前的应用程序行为自动确定初始化堆占用百分比（IHOP）阈值。如果应用程序行为发生变化，这些预测可能会不准确。有两种选择: 通过修改 `-XX:G1ReservePercent` 来增加自适应 IHOP 计算中使用的缓冲区，从而降低开始 space-reclamation 的目标占用率。或者，通过使用 `-XX:-G1UseAdaptiveIHOP` 禁用 IHOP 的自适应计算，并通过 `-XX:InitiatingHeapOccupancyPercent` 手动设置 IHOP。这样可以确保 G1 在更早的时间点开始标记过程，以适应新的应用程序行为或避免 Full GC

除了分配失败（Allocation Failure）之外的原因导致的 Full GC 通常表明，可能是应用程序或某些外部工具触发了整个堆的回收。如果原因是 `System.gc()`，并且没有方法修改应用程序源代码，可以通过使用 `-XX:+ExplicitGCInvokesConcurrent` 来缓解 Full GC 的影响，或者通过设置 `-XX:+DisableExplicitGC` 让虚拟机完全忽略这些 Full GC 请求。外部工具仍可能强制执行 Full GC, 要避免这种情况，只能通过不发起 Full GC 请求来解决。

## 巨大对象碎片化

由于需要为巨大对象找到一组连续的分区，即使并非所有的 Java 堆内存已被耗尽，也可能发生 Full GC。在这种情况下，可以考虑以下选项：

- 使用 `-XX:G1HeapRegionSize` 选项增大堆分区大小，以减少巨大对象的数量
- 增大堆的大小

在极端情况下，即使可用内存显示还有剩余，G1 也可能因为找不到足够的连续空间而无法分配巨大对象。如果这次 Full GC 不能回收足够的连续空间，将会导致虚拟机退出。因此，除了减少巨大对象的分配量或增大堆大小之外，没有其他的解决方案。

## 优化延迟

本节提供了在遇到常见延迟问题(即当停顿时间过长时)时改善 G1 行为的提示。

### 非常规系统或实时使用情况

对于每一次垃圾回收停顿，`gc+cpu=info` 日志输出中都包含一行来自操作系统的详细信息，显示了停顿时间内的时间是如何花费的。这样的输出示例为 `User=0.19s Sys=0.00s Real=0.01s`。

用户时间(`User`)是指花费在虚拟机代码中的时间，系统时间(`Sys`)是指花费在操作系统中的时间，而实际时间(`Real`)是指停顿期间经过的绝对时间。如果系统时间相对较高，则通常说明环境是导致这种情况的原因。

常见的导致高系统时间的问题包括:

- 虚拟机从操作系统分配或释放内存可能会造成不必要的延迟。可以通过使用 `-Xms` 和 `-Xmx` 选项将最小和最大堆大小设置为相同的值，并使用 `-XX:+AlwaysPreTouch` 选项预触(pre-touching)所有内存，以避免这些延迟，这样可以将这项工作移到虚拟机启动阶段
- 特别是在 Linux 中，透明大页面（Transparent Huge Pages, THP）特性将小页面合并为大页面的过程往往会随机使进程停滞，而不仅仅是在停顿期间。因为虚拟机分配和管理大量内存，所以存在比平时更高的风险，即虚拟机可能成为长时间停滞的进程。建议参考操作系统的文档，了解如何禁用 THP 特性
- 输出日志可能会由于某些后台任务间歇性地占用所有写入日志的硬盘的 I/O 带宽而暂时停滞。建议为日志使用单独的磁盘或其它存储方式，比如基于内存的文件系统，以避免此类问题

pre-touching 是指在程序启动时，主动访问（即触摸）分配给应用程序的内存页面，从而触发操作系统加载这些页面到物理内存中。这个过程通常发生在虚拟机启动阶段或应用程序初始化期间。

另一种需要注意的情况是，如果实际时间（Real time）比用户时间和系统时间的总和大很多，这可能表明虚拟机在可能过载的机器上没有获得足够的 CPU 时间。

### 引用对象处理耗时过长

处理关于引用对象所花费的时间信息会在 引用处理阶段(Reference Processing phase) 显示。在此阶段，G1 根据特定类型引用对象的要求更新其引用目标。默认情况下，G1 使用以下启发式规则尝试并行化引用处理的子阶段：对于每 `-XX:ReferencesPerThread` 个引用对象启动一个线程，但最多不会超过 `-XX:ParallelGCThreads` 所指定的数量。可以将 `-XX:ReferencesPerThread` 设置为 0 来禁用该启发式规则，默认使用所有可用线程，或者通过 `-XX:-ParallelRefProcEnabled` 完全禁用并行化。

## young-only 阶段中的新生代回收耗时过长

正常的新生代回收，以及一般而言任何针对新生代的回收，大致上所花费的时间与新生代的大小成正比，或者更具体地说，与回收集中需要复制的存活对象数量成正比。如果 疏散回收集阶段（Evacuate Collection Set phase）耗时过长，特别是对象复制子阶段（Object Copy sub-phase）耗时过长，可以减小 `-XX:G1NewSizePercent` 的值。这会减少新生代的最小大小，允许有更短的停顿时间。

如果应用程序性能突然变化，特别是每次回收后存活对象的数量发生变化，可能会导致垃圾回收停顿时间的骤增。这时可以考虑使用 `-XX:G1MaxNewSizePercent` 减小新生代的最大大小，进而减少停顿期间需要处理的对象数量，有助于避免垃圾回收停顿时间的突然增加。

## 混合回收耗时过长
