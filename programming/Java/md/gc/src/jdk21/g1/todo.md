# todo

## 空闲 region

是什么, 有什么用

## MSB

**MSB(Most Significant Bit)**：最高有效位。在一个二进制数字表示中，MSB 是最左边的位，它对数字的数值大小贡献最大。例如，在 8 位二进制数 10000000 中，最左边的“1”就是 MSB。如果这个二进制数表示无符号整数，MSB 为 1 时，其对应的十进制数是 128；如果表示有符号整数(补码表示法)，它对应的十进制数是 - 128。

## LSB

**LSB(Least Significant Bit)**：最低有效位。它是二进制数字表示中最右边的位，对数字的数值大小贡献最小。在 8 位二进制数 10000000 中，最右边的“0”就是 LSB。在很多操作中，比如从右向左逐位读取数据，或者对数据进行最低位的修改等操作时，LSB 就会被重点关注。

## pending cards

在 Java 虚拟机(JVM)中，`_pending_cards`通常与垃圾收集(Garbage Collection, GC)相关，特别是在使用分代垃圾收集算法时。这个术语一般出现在 HotSpot JVM 的实现细节中。

具体来说，`_pending_cards`可能是指那些已经被标记为脏(dirty)但还未被处理的卡片(card)。在 Card Table 等数据结构中，每个卡片代表了一块固定大小的内存区域(通常是 512 字节或更大)。当一个对象引用从一个代指向另一个代时(比如从年轻代指向老年代)，对应的卡片会被标记为脏，表示该区域内有跨代引用发生改变。这些脏卡片的信息将被保存在一个队列或者列表里，即所谓的`_pending_cards`。随后，在适当的时机，如安全点(safepoint)期间，垃圾收集器会处理这些待处理卡片，更新相应的记忆集(Remembered Set)，从而保证 GC 过程中可以正确追踪到所有存活对象及其引用链。

在 Java 虚拟机(JVM)中，`_pending_cards`是一个与垃圾收集相关的内部数据结构，它特别关联于使用了卡表(Card Table)和写屏障(Write Barrier)技术的垃圾收集器，比如 CMS(Concurrent Mark Sweep)或 G1(Garbage First)垃圾收集器。这个术语用来指代那些已经被标记为脏(dirty)但尚未被处理的卡片集合。

当老年代的对象引用到了新生代中的对象时，JVM 需要一种机制来跟踪这些跨代引用，以避免每次对新生代进行垃圾回收(Minor GC)时都去扫描整个老年代。为此，JVM 采用了卡表(Card Table)的概念。卡表将堆内存划分为固定大小的卡页(Card Page)，每个卡页通常对应 512 字节的内存块。当一个老年代对象引用到新生代对象时，该老年代对象所在的卡页会被标记为脏(通过设置卡表中相应的条目)。这种标记操作是通过写屏障(Write Barrier)来实现的，即每当有新的引用指向新生代对象时，写屏障会自动更新对应的卡表条目。

`_pending_cards`可以理解为一组等待处理的脏卡片。当发生一次 GC 事件时，特别是年轻代的垃圾回收，垃圾收集器会检查这些待处理的卡片，并且只扫描那些被标记为脏的卡页，而不是整个老年代。这样就可以大大减少垃圾收集过程中的开销。在垃圾收集的过程中，`_pending_cards`会被清空，因为它们已经得到了处理。如果某个卡页内没有新的跨代引用产生，那么下一次 GC 时它就不会再出现在`_pending_cards`列表中。

## MMU

最小赋值器利用率(Minimum Mutator Utilization, MMU)反映了任意给定时间窗(x)内的最小赋值器使用率(y)。

对于 MMU 曲线，假设当 x=100 时，y=50%，其含义是：在任意一个 100ms 的时间窗口内，赋值器使用率的最小值是 50%。

## BMU

界限赋值器使用率(Bounded Mutator Utilization, BMU)反映了任意给定时间窗或者更大的时间范围内的最小赋值器使用率。

对于 BMU 曲线，假设当 x=200 时，y=60%，其含义是：在任意一个不小于 200ms 的时间范围内，赋值器使用率的最小值是 60%。

## 串行并行和并发

与操作系统中的串行、并行和并发的概念不同, 垃圾回收中的串行、并行和并发:

- 串行执行: 应用程序和垃圾回收器交替执行, 垃圾回收器执行的时候应用程序暂停执行。串行执行指的是垃圾回收器有且仅有一个后台线程执行垃圾对象的识别和回收
- 并行执行: 应用程序和垃圾回收器交替执行, 垃圾回收器执行的时候应用程序暂停执行。并行执行指的是垃圾回收器有多个后台线程执行垃圾对象的识别和回收, 多个垃圾回收线程同时执行
- 并发执行: 应用程序和垃圾回收器同时运行, 除了在某些必要的情况下垃圾回收器需要暂停应用程序的执行, 其余的时候在应用程序运行的同时, 垃圾回收器的后台线程也运行, 如标识垃圾对象并回收垃圾对象所占的空间

## 堆

堆是由一段或者几段连续内存组成的空间集合。内存颗粒(granule)是堆内存分配的最小单位，一般是一个字(word)或者一个双字(double-word)，这取决于需要的对齐(alignment)方式。内存块(chunk)是一组较大的连续内存颗粒。内存单元(cell)是由数个连续颗粒组成小内存块，通常用于内存的分配和释放，也可能由于某种原因被浪费或闲置。

堆通常可以使用对象图(object graph)的方式来描述，它一般是一个有向图(directedgraph)，图的节点(node)是堆中的对象，有向边是对象之间的引用。边一般是从源节点(source node)或者根(root)指向目标节点(destination node)的引用。

## 赋值器与回收器

- 赋值器(mutator)执行应用代码。这一过程会分配新的对象，并且修改对象之间的引用关系，进而改变堆中对象图的拓扑结构。随着引用关系的不断变更，部分对象会失去与根的联系，即从根出发沿着对象图的任何一条边进行遍历都无法到达该对象
- 回收器(collector)执行垃圾回收代码，即找到不可达对象并将其回收

一个程序可能拥有多个赋值器线程，但是它们共用同一个堆。相应的，也可能存在多个回收器线程。

## 赋值器根

与堆内存不同，赋值器的根是一个有限的指针集合，赋值器可以不经过其他对象直接访问这些指针。堆中直接由赋值器根所引用的对象称为根对象(root object)。

当赋值器访问堆中的对象时，它需要从当前的根对象集合中加载指针(进而会增加新的根)。赋值器也可能会丢弃一些根，例如将某个根指针改写为新的引用(即改写为空指针或者指向其他对象的指针)。根通常包括静态/全局存储以及线程本地存储(例如线程栈)，赋值器可以通过根中的指针直接操纵堆中对象。

一旦某个对象在堆中不可达，并且赋值器的所有根指针中也不包含对该对象的引用，赋值器将无法再次访问该对象。

## 万物静止(stop the world)

当回收器线程运行时，所有的赋值器线程均处于停止状态。

## 标记-清扫算法(mark-sweep)

它的回收过程分为两个阶段：第一阶段为追踪(trace)阶段，即回收器从根集合(寄存器、线程栈、全局变量)开始遍历对象图，并标记(mark)所遇到的每个对象；第二阶段为清扫(sweep)阶段，即回收器检查堆中每一个对象，并将所有未标记的对象当作垃圾进行回收。

标记-清扫算法是一种间接回收(indirect collection)算法，它并非直接检测垃圾本身，而是先确定所有存活对象，然后反过来判定其他对象都是垃圾。

## 三色抽象

三色抽象(tricolour abstraction)可以简洁地描述回收过程中对象状态的变化(是否已被标记、是否在工作列表中等)。

回收器将对象图划分为黑色对象(确定存活)和白色对象(可能死亡)。任意对象在初始状态下均为白色，当回收器初次扫描到某一对象时将其标记为灰色，当完成该对象的扫描并找到其所有子节点之后，回收器会将其标记为黑色。黑色意味着已经被回收器处理过，灰色意味着已经被回收器遍历但尚未完成处理(或者需要再次进行处理)。

## 标记-复制算法(mark-copy)

## 标记-整理算法(mark-compact)

## 引用计数算法(reference counting)

## SATB

原始快照(Snapshot-At-The-Beginning, SATB): 当扫描到灰色对象的引用删除时, 会将这个引用删除前的状态保存成一个快照, 然后放到集合里。等到重新标记阶段, 会扫描这个集合, 把里面的对象标记为灰色。

## nmethods

nmethods 是指编译后的本地方法(native methods)，它是 JIT 编译器生成的机器代码片段。每个 nmethod 对象包含编译后的代码及其相关的元数据，如方法签名、异常处理信息等。

## card set

## 掩码

掩码（Mask）是一种用于对数据进行特定处理的二进制模式。它就像一个过滤器或者模板，通过与目标数据进行位运算（如与运算、或运算、异或运算等），来提取、设置或清除目标数据中的某些位，从而达到特定的目的。

### 与运算（AND）用于提取位:

当掩码与目标数据进行与运算时，可以提取目标数据中的某些位。掩码中的 1 位表示要提取目标数据中对应的位，0 位表示忽略对应的位。

例如，假设有一个 8 位二进制数 10101101，如果使用掩码 00001111 与之进行与运算（10101101 & 00001111），得到的结果是 00001101。通过这种方式，可以提取出目标数据的低 4 位。

### 或运算（OR）用于设置位

掩码与目标数据进行或运算可以设置目标数据中的某些位。掩码中的 1 位表示将目标数据中对应的位设置为 1，0 位表示保持目标数据中对应的位不变。

例如，对于同样的 8 位二进制数 10101101，如果使用掩码 00001111 与之进行或运算（10101101 | 00001111），得到的结果是 10101111。这样就将目标数据的低 4 位设置为 1。

### 异或运算（XOR）用于翻转位

掩码与目标数据进行异或运算可以翻转目标数据中的某些位。掩码中的 1 位表示将目标数据中对应的位进行翻转（0 变 1，1 变 0），0 位表示保持目标数据中对应的位不变。

例如，对于 8 位二进制数 10101101，使用掩码 00001111 与之进行异或运算（10101101 ^ 00001111），得到的结果是 10100010。低 4 位被翻转了。
