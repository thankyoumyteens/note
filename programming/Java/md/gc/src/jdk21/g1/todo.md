# todo

## 空闲 region

是什么, 有什么用

## pending cards

在 Java 虚拟机(JVM)中，`_pending_cards`通常与垃圾收集(Garbage Collection, GC)相关，特别是在使用分代垃圾收集算法时。这个术语一般出现在 HotSpot JVM 的实现细节中。

具体来说，`_pending_cards`可能是指那些已经被标记为脏(dirty)但还未被处理的卡片(card)。在 Card Table 等数据结构中，每个卡片代表了一块固定大小的内存区域(通常是 512 字节或更大)。当一个对象引用从一个代指向另一个代时(比如从年轻代指向老年代)，对应的卡片会被标记为脏，表示该区域内有跨代引用发生改变。这些脏卡片的信息将被保存在一个队列或者列表里，即所谓的`_pending_cards`。随后，在适当的时机，如安全点(safepoint)期间，垃圾收集器会处理这些待处理卡片，更新相应的记忆集(Remembered Set)，从而保证 GC 过程中可以正确追踪到所有存活对象及其引用链。

在 Java 虚拟机(JVM)中，`_pending_cards`是一个与垃圾收集相关的内部数据结构，它特别关联于使用了卡表(Card Table)和写屏障(Write Barrier)技术的垃圾收集器，比如 CMS(Concurrent Mark Sweep)或 G1(Garbage First)垃圾收集器。这个术语用来指代那些已经被标记为脏(dirty)但尚未被处理的卡片集合。

当老年代的对象引用到了新生代中的对象时，JVM 需要一种机制来跟踪这些跨代引用，以避免每次对新生代进行垃圾回收(Minor GC)时都去扫描整个老年代。为此，JVM 采用了卡表(Card Table)的概念。卡表将堆内存划分为固定大小的卡页(Card Page)，每个卡页通常对应 512 字节的内存块。当一个老年代对象引用到新生代对象时，该老年代对象所在的卡页会被标记为脏(通过设置卡表中相应的条目)。这种标记操作是通过写屏障(Write Barrier)来实现的，即每当有新的引用指向新生代对象时，写屏障会自动更新对应的卡表条目。

`_pending_cards`可以理解为一组等待处理的脏卡片。当发生一次 GC 事件时，特别是年轻代的垃圾回收，垃圾收集器会检查这些待处理的卡片，并且只扫描那些被标记为脏的卡页，而不是整个老年代。这样就可以大大减少垃圾收集过程中的开销。在垃圾收集的过程中，`_pending_cards`会被清空，因为它们已经得到了处理。如果某个卡页内没有新的跨代引用产生，那么下一次 GC 时它就不会再出现在`_pending_cards`列表中。
