# todo

## 空闲 region

是什么, 有什么用

## pending cards

在 Java 虚拟机(JVM)中，`_pending_cards`通常与垃圾收集(Garbage Collection, GC)相关，特别是在使用分代垃圾收集算法时。这个术语一般出现在 HotSpot JVM 的实现细节中。

具体来说，`_pending_cards`可能是指那些已经被标记为脏(dirty)但还未被处理的卡片(card)。在 Card Table 等数据结构中，每个卡片代表了一块固定大小的内存区域(通常是 512 字节或更大)。当一个对象引用从一个代指向另一个代时(比如从年轻代指向老年代)，对应的卡片会被标记为脏，表示该区域内有跨代引用发生改变。这些脏卡片的信息将被保存在一个队列或者列表里，即所谓的`_pending_cards`。随后，在适当的时机，如安全点(safepoint)期间，垃圾收集器会处理这些待处理卡片，更新相应的记忆集(Remembered Set)，从而保证 GC 过程中可以正确追踪到所有存活对象及其引用链。

在 Java 虚拟机(JVM)中，`_pending_cards`是一个与垃圾收集相关的内部数据结构，它特别关联于使用了卡表(Card Table)和写屏障(Write Barrier)技术的垃圾收集器，比如 CMS(Concurrent Mark Sweep)或 G1(Garbage First)垃圾收集器。这个术语用来指代那些已经被标记为脏(dirty)但尚未被处理的卡片集合。

当老年代的对象引用到了新生代中的对象时，JVM 需要一种机制来跟踪这些跨代引用，以避免每次对新生代进行垃圾回收(Minor GC)时都去扫描整个老年代。为此，JVM 采用了卡表(Card Table)的概念。卡表将堆内存划分为固定大小的卡页(Card Page)，每个卡页通常对应 512 字节的内存块。当一个老年代对象引用到新生代对象时，该老年代对象所在的卡页会被标记为脏(通过设置卡表中相应的条目)。这种标记操作是通过写屏障(Write Barrier)来实现的，即每当有新的引用指向新生代对象时，写屏障会自动更新对应的卡表条目。

`_pending_cards`可以理解为一组等待处理的脏卡片。当发生一次 GC 事件时，特别是年轻代的垃圾回收，垃圾收集器会检查这些待处理的卡片，并且只扫描那些被标记为脏的卡页，而不是整个老年代。这样就可以大大减少垃圾收集过程中的开销。在垃圾收集的过程中，`_pending_cards`会被清空，因为它们已经得到了处理。如果某个卡页内没有新的跨代引用产生，那么下一次 GC 时它就不会再出现在`_pending_cards`列表中。

## MMU

最小赋值器利用率(Minimum Mutator Utilization, MMU)反映了任意给定时间窗(x)内的最小赋值器使用率(y)。

对于 MMU 曲线，假设当 x=100 时，y=50%，其含义是：在任意一个 100ms 的时间窗口内，赋值器使用率的最小值是 50%。

## BMU

界限赋值器使用率(Bounded Mutator Utilization, BMU)反映了任意给定时间窗或者更大的时间范围内的最小赋值器使用率。

对于 BMU 曲线，假设当 x=200 时，y=60%，其含义是：在任意一个不小于 200ms 的时间范围内，赋值器使用率的最小值是 60%。

## 串行并行和并发

与操作系统中的串行、并行和并发的概念不同, 垃圾回收中的串行、并行和并发:

- 串行执行: 应用程序和垃圾回收器交替执行, 垃圾回收器执行的时候应用程序暂停执行。串行执行指的是垃圾回收器有且仅有一个后台线程执行垃圾对象的识别和回收
- 并行执行: 应用程序和垃圾回收器交替执行, 垃圾回收器执行的时候应用程序暂停执行。并行执行指的是垃圾回收器有多个后台线程执行垃圾对象的识别和回收, 多个垃圾回收线程同时执行
- 并发执行: 应用程序和垃圾回收器同时运行, 除了在某些必要的情况下垃圾回收器需要暂停应用程序的执行, 其余的时候在应用程序运行的同时, 垃圾回收器的后台线程也运行, 如标识垃圾对象并回收垃圾对象所占的空间

## 堆

堆是由一段或者几段连续内存组成的空间集合。内存颗粒(granule)是堆内存分配的最小单位，一般是一个字(word)或者一个双字(double-word)，这取决于需要的对齐(alignment)方式。内存块(chunk)是一组较大的连续内存颗粒。内存单元(cell)是由数个连续颗粒组成小内存块，通常用于内存的分配和释放，也可能由于某种原因被浪费或闲置。

堆通常可以使用对象图(object graph)的方式来描述，它一般是一个有向图(directedgraph)，图的节点(node)是堆中的对象，有向边是对象之间的引用。边一般是从源节点(source node)或者根(root)指向目标节点(destination node)的引用。

## 赋值器与回收器

- 赋值器(mutator)执行应用代码。这一过程会分配新的对象，并且修改对象之间的引用关系，进而改变堆中对象图的拓扑结构。随着引用关系的不断变更，部分对象会失去与根的联系，即从根出发沿着对象图的任何一条边进行遍历都无法到达该对象
- 回收器(collector)执行垃圾回收代码，即找到不可达对象并将其回收

一个程序可能拥有多个赋值器线程，但是它们共用同一个堆。相应的，也可能存在多个回收器线程。

## 赋值器根

与堆内存不同，赋值器的根是一个有限的指针集合，赋值器可以不经过其他对象直接访问这些指针。堆中直接由赋值器根所引用的对象称为根对象(root object)。

当赋值器访问堆中的对象时，它需要从当前的根对象集合中加载指针(进而会增加新的根)。赋值器也可能会丢弃一些根，例如将某个根指针改写为新的引用(即改写为空指针或者指向其他对象的指针)。根通常包括静态/全局存储以及线程本地存储(例如线程栈)，赋值器可以通过根中的指针直接操纵堆中对象。

一旦某个对象在堆中不可达，并且赋值器的所有根指针中也不包含对该对象的引用，赋值器将无法再次访问该对象。

## 万物静止(stop the world)

当回收器线程运行时，所有的赋值器线程均处于停止状态。

## 标记-清扫算法(mark-sweep)

它的回收过程分为两个阶段：第一阶段为追踪(trace)阶段，即回收器从根集合(寄存器、线程栈、全局变量)开始遍历对象图，并标记(mark)所遇到的每个对象；第二阶段为清扫(sweep)阶段，即回收器检查堆中每一个对象，并将所有未标记的对象当作垃圾进行回收。

标记-清扫算法是一种间接回收(indirect collection)算法，它并非直接检测垃圾本身，而是先确定所有存活对象，然后反过来判定其他对象都是垃圾。

## 标记-复制算法(mark-copy)

## 标记-整理算法(mark-compact)

## 引用计数算法(reference counting)

## SATB

原始快照(Snapshot-At-The-Beginning, SATB): 当扫描到灰色对象的引用删除时, 会将这个引用删除前的状态保存成一个快照, 然后放到集合里。等到重新标记阶段, 会扫描这个集合, 把里面的对象标记为灰色。

## Eager Reclaim

提前回收。

## nmethods

nmethods 是指编译后的本地方法（native methods），它是 JIT 编译器生成的机器代码片段。每个 nmethod 对象包含编译后的代码及其相关的元数据，如方法签名、异常处理信息等。

## card set
