# 持久化

Redis 的持久化是指将内存中的数据保存到磁盘上。由于 Redis 是一个基于内存的数据存储系统, 内存中的数据在服务器重启或崩溃后会丢失。为了解决这个问题, Redis 提供了几种持久化机制, 使得数据可以在这些情况下得到恢复。

## RDB

RDB(Redis Database): 这种持久化方式是通过创建 Redis 数据的快照来实现的。Redis 可以配置在特定的时间间隔内自动保存快照。当 Redis 需要保存快照时, 它会将当前内存中的数据集写入到一个 RDB 文件中。这种方式的优点是恢复速度快, 且对性能的影响较小, 因为写入操作是批量进行的。但是, 如果在最后一次成功保存快照之后有数据变更, 而这些变更在下一次快照保存之前发生故障, 那么这些变更将会丢失。

RDB 有两种触发方式, 分别是自动触发和手动触发。

手动触发 RDB 的命令有两种:

1. save: 该命令会阻塞当前 Redis 服务器, 执行 save 命令期间, Redis 不能处理其他命令, 直到快照完成为止
2. bgsave: 执行该命令时, Redis 会开启一个子进程在后台进行快照操作, 而 Redis 服务器在子进程工作期间仍然可以处理来自客户端的请求

自动触发 RDB 需要修改 redis.conf 文件:

```shell
# 表示 60 秒内如果至少有 10000 个 key 的值变化, 则执行 bgsave
save 60 10000
# 当后台保存进程失败时, 是否停止主服务器的写操作, 默认是yes
stop-writes-on-bgsave-error yes
# 是否对RDB文件进行压缩。压缩可以减小RDB文件的大小, 但会增加CPU的占用, 默认是yes
rdbcompression yes
# 是否对RDB文件进行校验和检查。这有助于在加载RDB文件时检测数据损坏, 默认是yes
rdbchecksum yes
```

### bgsave 的实现方式

bgsave 会使用操作系统的 fork() 函数创建一个子进程, fork 是在类 unix 系统中创建新进程的主要方法:

1. 通过 fork 创建的子进程能够获得和父进程完全相同的内存空间, 这样子进程就可以访问 redis 内存中存储的数据了, 而且后续两者对内存的写入都不会相互影响
2. 通过 fork 创建子进程时不会立刻触发大量内存的拷贝, 内存在被修改时会以页为单位进行拷贝, 这也就避免了大量拷贝内存而带来的性能问题

```cpp
// fork函数的头文件
#include <unistd.h>
#include <stdio.h>

int main () {
    // fork函数返回的子进程id
    pid_t fpid;
    // 创建子进程, 并返回子进程的PID
    // 子进程是父进程的一个副本
    // fork函数是以复制的方式创建子进程
    // 子进程几乎完全复制了父进程
    // 也会从main函数开始执行
    // 不同的是, 子进程执行fork函数会返回0, 并且不会创建新的子进程
    // 否则就递归创建无限个进程了
    // 子进程会拷贝父进程的数据段, 堆, 栈, 并且拷贝父进程打开的所有文件描述符
    // 父进程与子进程并不共享这些存储空间, 这是子进程对父进程相应部分存储空间的完全复制
    // 执行fork之后, 子进程和父进程各自在自己的进程空间中运行
    // 每个进程均可以独立修改自己的内存空间而不会影响另一个进程
    fpid = fork();

    if (fpid < 0) {
        printf("创建子进程失败\n");
    } else if (fpid == 0) {
        printf("子进程会执行这段代码, 它的父进程ID是: %d\n", getpid());
    } else {
        printf("父进程会执行这段代码, 它的子进程ID是: %d\n", fpid);
    }
    return 0;
}
```

### 写时复制(Copy-on-Write)

父进程和子进程拥有完全相同的内存空间并且两者对内存的写入都不会相互影响, 但如果在 fork 时对父进程的内存进行全量的拷贝会导致程序长时间无响应, 并且占用大量的系统资源。为了解决这个问题操作系统使用了写时复制技术。

在 fork 函数调用时, 父进程和子进程会被分配到不同的虚拟内存空间中, 所以在两个进程看来它们访问的是不同的内存, 但在真正访问虚拟内存空间时, 操作系统会将虚拟内存映射到相同的物理内存上, 所以父子进程共享了物理上的内存空间。

当父进程或者子进程对共享的内存进行修改时, 共享的内存才会以页为单位进行拷贝, 父进程会继续使用原有的物理内存, 而子进程会使用拷贝后的新物理内存。在 Redis 中, 子进程只会读取共享内存中的数据, 它并不会执行任何写操作, 只有父进程会在写入时才会触发这一机制, 而对于大多数的 Redis 服务或者数据库, 写请求都是远小于读请求的, 所以使用 fork 加上写时复制这一机制能够带来非常好的性能, 也让 bgsave 这一操作的实现变得非常简单。
