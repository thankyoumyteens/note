# 四种IO模型

常见的IO模型有四种: 

1. 同步阻塞IO(Blocking IO)
2. 同步非阻塞IO(Non-blocking IO)
3. IO多路复用模型(IO Multiplexing)
4. 异步IO(Asynchronous IO)

## 同步阻塞IO

在阻塞式IO模型中, Java应用程序从系统调用开始, 直到系统调用返回的这段时间内, Java进程一直是阻塞的。返回成功后, 应用进程开始处理用户空间的缓存区数据。

发起一个socket的read读操作的系统调用, 流程如下: 

1. 应用程序发起read系统调用开始, 用户线程就进入阻塞状态
2. 当系统内核收到read系统调用, 就开始准备数据。一开始数据可能还没有到达内核缓冲区, 这个时候内核就要等待
3. 内核一直等到完整的数据到达, 才会将数据从内核缓冲区复制到进程缓冲区, 然后内核返回结果
4. 直到内核返回后, 用户线程才会解除阻塞的状态, 重新运行起来

在高并发的应用场景下, 阻塞IO需要大量的线程来维护大量的网络连接, 内存、线程切换开销会非常巨大。因此, 基本上阻塞IO模型在高并发应用场景下是不可用的。

## 同步非阻塞IO

在同步非阻塞IO模型中, 应用程序一旦开始IO系统调用, 会出现以下两种情况: 

1. 在内核缓冲区中没有数据的情况下, 系统调用会立即返回, 返回一个调用失败的信息
2. 在内核缓冲区中有数据的情况下, 是阻塞的, 直到数据从内核缓冲复制到进程缓冲区。复制完成后, 系统调用返回成功, 应用程序开始处理用户空间的缓存数据

发起一个非阻塞socket的read读操作的系统调用, 流程如下: 

1. 在内核数据没有准备好的阶段, 用户线程发起IO请求时, 立即返回。所以, 为了读取到最终的数据, 用户线程需要不断地发起 IO系统调用
2. 内核数据到达后, 用户线程发起系统调用, 用户线程阻塞。内核开始复制数据到用户进程缓冲区, 然后内核返回结果
3. 用户线程读到数据后, 才会解除阻塞状态, 重新运行起来。也就是说, 用户进程需要经过多次的尝试, 才能保证最终真正读到数据, 而后继续执行

同步非阻塞IO在等待数据时, 会不断地轮询内核, 这将占用大量的CPU时间, 效率低下。因此, 同步非阻塞IO模型在高并发应用场景下是不可用的。

同步非阻塞IO虽然简称为NIO, 但它和Java中的NIO不是一个东西。

## IO多路复用模型

在IO多路复用模型中, 引入了一种新的系统调用, 可以查询IO的就绪状态。在Linux系统中, 对应的系统调用为select/epoll系统调用。通过该系统调用, 一个进程可以监视多个文件描述符, 一旦某个描述符就绪, 内核能够将就绪的状态返回给应用程序。随后, 应用程序根据就绪的状态, 进行相应的IO系统调用。epoll是linux所特有的, 而select是POSIX所规定, 一般操作系统均有实现。

发起一个多路复用IO的read读操作的系统调用, 流程如下: 

1. 选择器注册。在这种模式中, 首先, 将需要read操作的目标socket网络连接, 提前注册到select/epoll选择器中, 然后, 才可以开启整个IO多路复用模型的轮询流程
2. 就绪状态的轮询。通过选择器的查询方法, 查询注册过的所有socket连接的就绪状态。通过查询的系统调用, 内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好了, 内核就将该socket加入到就绪的列表中
3. 用户线程获得了就绪状态的列表后, 根据其中的socket连接, 发起read系统调用, 用户线程阻塞。内核开始复制数据, 将数据从内核缓冲区复制到用户缓冲区
4. 复制完成后, 内核返回结果, 用户线程才会解除阻塞的状态, 用户线程读取到了数据, 继续执行

IO多路复用模型与一个线程维护一个连接的阻塞IO模式相比, 使用select/epoll的最大优势在于, 一个选择器查询线程可以同时处理成千上万个连接。系统不必创建大量的线程, 也不必维护这些线程, 从而大大减小了系统的开销。Java语言的NIO技术, 使用的就是IO多路复用模型。在Linux 系统上使用的是epoll系统调用。本质上, select/epoll系统调用是阻塞式的, 属于同步IO, 都需要在读写事件就绪后, 由系统调用本身负责进行读写, 也就是说这个读写过程是阻塞的。

## 异步IO

在异步IO模型中, 在整个内核的数据处理过程中, 包括内核将数据从物理设备读取到内核缓冲区、将内核缓冲区的数据复制到用户线程缓冲区, 用户程序都不需要阻塞。

发起一个异步IO的read读操作的系统调用, 流程如下: 

1. 当用户线程发起了read系统调用, 立刻就可以开始去做其他的事, 用户线程不阻塞
2. 内核开始准备数据, 等到数据准备好了, 内核就会将数据从内核缓冲区复制到用户进程缓冲区
3. 内核会给用户线程发送一个信号, 或者回调用户线程注册的回调接口, 告诉用户线程read操作完成了
4. 用户线程读取用户进程缓冲区的数据, 完成后续的业务操作

异步IO模型在内核等待数据和复制数据的两个阶段, 用户线程都不是阻塞的。用户线程需要接收内核的IO操作完成的事件, 或者注册一个IO操作完成的回调函数。因此, 异步IO也被称为信号驱动IO。

异步IO模型需要底层内核提供支持, Linux对AIO的支持并不完善。
