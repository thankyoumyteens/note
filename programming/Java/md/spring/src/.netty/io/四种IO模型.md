# 四种IO模型

常见的IO模型有四种：

1. 同步阻塞IO(Blocking IO)
2. 同步非阻塞IO(Non-blocking IO)
3. IO多路复用模型(IO Multiplexing)
4. 异步IO(Asynchronous IO)

## 同步阻塞IO

在阻塞式IO模型中，Java应用程序从系统调用开始，直到系统调用返回的这段时间内，Java进程一直是阻塞的。返回成功后，应用进程开始处理用户空间的缓存区数据。

发起一个socket的read读操作的系统调用，流程如下：

1. 应用程序发起read系统调用开始，用户线程就进入阻塞状态
2. 当系统内核收到read系统调用，就开始准备数据。一开始数据可能还没有到达内核缓冲区，这个时候内核就要等待
3. 内核一直等到完整的数据到达，才会将数据从内核缓冲区复制到进程缓冲区，然后内核返回结果
4. 直到内核返回后，用户线程才会解除阻塞的状态，重新运行起来

在高并发的应用场景下，阻塞IO需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。

## 同步非阻塞IO

在同步非阻塞IO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：

1. 在内核缓冲区中没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息
2. 在内核缓冲区中有数据的情况下，是阻塞的，直到数据从内核缓冲复制到进程缓冲区。复制完成后，系统调用返回成功，应用程序开始处理用户空间的缓存数据

发起一个非阻塞socket的read读操作的系统调用，流程如下：

1. 在内核数据没有准备好的阶段，用户线程发起IO请求时，立即返回。所以，为了读取到最终的数据，用户线程需要不断地发起 IO系统调用
2. 内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据到用户进程缓冲区，然后内核返回结果
3. 用户线程读到数据后，才会解除阻塞状态，重新运行起来。也就是说，用户进程需要经过多次的尝试，才能保证最终真正读到数据，而后继续执行

同步非阻塞IO在等待数据时，会不断地轮询内核，这将占用大量的CPU时间，效率低下。因此，同步非阻塞IO模型在高并发应用场景下是不可用的。

同步非阻塞IO虽然简称为NIO，但它和Java中的NIO不是一个东西。

## IO多路复用模型

在IO多路复用模型中，引入了一种新的系统调用，可以查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪，内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。epoll是linux所特有的，而select是POSIX所规定，一般操作系统均有实现。

发起一个多路复用IO的read读操作的系统调用，流程如下：

1. 选择器注册。在这种模式中，首先，将需要read操作的目标socket网络连接，提前注册到select/epoll选择器中，然后，才可以开启整个IO多路复用模型的轮询流程
2. 就绪状态的轮询。通过选择器的查询方法，查询注册过的所有socket连接的就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好了，内核就将该socket加入到就绪的列表中
3. 用户线程获得了就绪状态的列表后，根据其中的socket连接，发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区
4. 复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行

IO多路复用模型与一个线程维护一个连接的阻塞IO模式相比，使用select/epoll的最大优势在于，一个选择器查询线程可以同时处理成千上万个连接。系统不必创建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。Java语言的NIO技术，使用的就是IO多路复用模型。在Linux 系统上使用的是epoll系统调用。本质上，select/epoll系统调用是阻塞式的，属于同步IO，都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。

## 异步IO

在异步IO模型中，在整个内核的数据处理过程中，包括内核将数据从物理设备读取到内核缓冲区、将内核缓冲区的数据复制到用户线程缓冲区，用户程序都不需要阻塞。

发起一个异步IO的read读操作的系统调用，流程如下：

1. 当用户线程发起了read系统调用，立刻就可以开始去做其他的事，用户线程不阻塞
2. 内核开始准备数据，等到数据准备好了，内核就会将数据从内核缓冲区复制到用户进程缓冲区
3. 内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程read操作完成了
4. 用户线程读取用户进程缓冲区的数据，完成后续的业务操作

异步IO模型在内核等待数据和复制数据的两个阶段，用户线程都不是阻塞的。用户线程需要接收内核的IO操作完成的事件，或者注册一个IO操作完成的回调函数。因此，异步IO也被称为信号驱动IO。

异步IO模型需要底层内核提供支持，Linux对AIO的支持并不完善。
