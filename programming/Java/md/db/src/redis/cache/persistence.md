# 持久化

Redis 的持久化是指将内存中的数据保存到磁盘上。由于 Redis 是一个基于内存的数据存储系统, 内存中的数据在服务器重启或崩溃后会丢失。为了解决这个问题, Redis 提供了几种持久化机制, 使得数据可以在这些情况下得到恢复。

## RDB

RDB(Redis Database): 这种持久化方式是通过创建 Redis 数据的快照来实现的。Redis 可以配置在特定的时间间隔内自动保存快照。当 Redis 需要保存快照时, 它会将当前内存中的数据集写入到一个 RDB 文件中。

RDB 有两种触发方式, 分别是自动触发和手动触发。

手动触发 RDB 的命令有两种:

1. save: 该命令会阻塞当前 Redis 服务器, 执行 save 命令期间, Redis 不能处理其他命令, 直到快照完成为止
2. bgsave: 执行该命令时, Redis 会开启一个子进程在后台进行快照操作, 而 Redis 服务器在子进程工作期间仍然可以处理来自客户端的请求

自动触发 RDB 需要修改 redis.conf 文件:

```shell
# 表示 60 秒内如果至少有 10000 个 key 的值变化, 则执行 bgsave
save 60 10000
# 当后台保存进程失败时, 是否停止主服务器的写操作, 默认是yes
stop-writes-on-bgsave-error yes
# 是否对RDB文件进行压缩。压缩可以减小RDB文件的大小, 但会增加CPU的占用, 默认是yes
rdbcompression yes
# 是否对RDB文件进行校验和检查。这有助于在加载RDB文件时检测数据损坏, 默认是yes
rdbchecksum yes
```

### bgsave 的实现方式

bgsave 会使用操作系统的 fork() 函数创建一个子进程, fork 是在类 unix 系统中创建新进程的主要方法:

1. 通过 fork 创建的子进程能够获得和父进程完全相同的内存空间, 这样子进程就可以访问 redis 内存中存储的数据了, 而且后续两者对内存的写入都不会相互影响
2. 通过 fork 创建子进程时不会立刻触发大量内存的拷贝, 内存在被修改时会以页为单位进行拷贝, 这也就避免了大量拷贝内存而带来的性能问题

```cpp
// fork函数的头文件
#include <unistd.h>
#include <stdio.h>

int main () {
    // fork函数返回的子进程id
    pid_t fpid;
    // 创建子进程, 并返回子进程的PID
    // 子进程是父进程的一个副本
    // fork函数是以复制的方式创建子进程
    // 子进程几乎完全复制了父进程
    // 也会从main函数开始执行
    // 不同的是, 子进程执行fork函数会返回0, 并且不会创建新的子进程
    // 否则就递归创建无限个进程了
    // 子进程会拷贝父进程的数据段, 堆, 栈, 并且拷贝父进程打开的所有文件描述符
    // 父进程与子进程并不共享这些存储空间, 这是子进程对父进程相应部分存储空间的完全复制
    // 执行fork之后, 子进程和父进程各自在自己的进程空间中运行
    // 每个进程均可以独立修改自己的内存空间而不会影响另一个进程
    fpid = fork();

    if (fpid < 0) {
        printf("创建子进程失败\n");
    } else if (fpid == 0) {
        printf("子进程会执行这段代码, 它的父进程ID是: %d\n", getpid());
    } else {
        printf("父进程会执行这段代码, 它的子进程ID是: %d\n", fpid);
    }
    return 0;
}
```

### 写时复制(Copy-on-Write)

父进程和子进程拥有完全相同的内存空间并且两者对内存的写入都不会相互影响, 但如果在 fork 时对父进程的内存进行全量的拷贝会导致程序长时间无响应, 并且占用大量的系统资源。为了解决这个问题操作系统使用了写时复制技术。

在 fork 函数调用时, 父进程和子进程会被分配到不同的虚拟内存空间中, 所以在两个进程看来它们访问的是不同的内存, 但在真正访问虚拟内存空间时, 操作系统会将虚拟内存映射到相同的物理内存上, 所以父子进程共享了物理上的内存空间。

当父进程或者子进程对共享的内存进行修改时, 共享的内存才会以页为单位进行拷贝, 父进程会继续使用原有的物理内存, 而子进程会使用拷贝后的新物理内存。在 Redis 中, 子进程只会读取共享内存中的数据, 它并不会执行任何写操作, 只有父进程会在写入时才会触发这一机制, 而对于大多数的 Redis 服务或者数据库, 写请求都是远小于读请求的, 所以使用 fork 加上写时复制这一机制能够带来非常好的性能, 也让 bgsave 这一操作的实现变得非常简单。

### 优点

- RDB 提供了快速的数据恢复能力, 文件体积相对较小, 恢复速度快, 对性能的影响较小

### 缺点

- 如果在最后一次成功的 RDB 保存之后, Redis 发生了故障, 那么自上次保存以来的所有更改都会丢失

## AOF

Redis 的 AOF(Append Only File)持久化机制是 Redis 提供的一种日志型持久化方式。与 RDB 相比, AOF 提供了更高的数据安全性, 因为它记录了 Redis 执行的所有写操作命令, 并确保这些命令能够被重新执行以恢复数据。

重写机制: 随着时间的推移, AOF 文件可能会变得非常庞大, 因为它记录了每个写操作。为了提高性能和减少恢复时间, Redis 提供了 AOF 重写功能。当 AOF 文件的大小达到一定阈值时, Redis 会启动一个后台进程来创建一个新的 AOF 文件, 这个新文件只包含达到当前数据状态所需的最小命令集(比如一个 key 被多次赋值, 重写后只会保留最新的一次赋值操作)。这个过程称为 AOF 重写。

AOF 默认是关闭的, 需要修改 redis.conf 文件启用:

```shell
# 是否开启AOF, 默认no
appendonly yes
# 指定 AOF 文件名
appendfilename appendonly.aof
# 配置记录日志的频率
# always 每次收到写命令就立即强制写入磁盘, 是最有保证的完全的持久化, 但速度也是最慢的, 不推荐
# everysec 每秒钟强制写入磁盘一次, 在性能和持久化方面做了很好的折中, 推荐
# no 完全依赖OS的写入, 一般为30秒左右一次, 性能最好但是持久化最没有保证, 不推荐
appendfsync everysec

# 在日志重写时, 不进行命令追加操作, 而只是将其放在缓冲区里, 避免与命令的追加造成DISK IO上的冲突。
# 设置为yes表示重写期间对新写的数据暂时存在内存中, 等rewrite完成后再写入, 默认为no
no-appendfsync-on-rewrite no
# 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时, 自动启动新的日志重写过程
auto-aof-rewrite-percentage 100
#当前AOF文件启动新的日志重写过程的最小值, 避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写
auto-aof-rewrite-min-size 64mb
```

bgrewriteaof 命令用于异步执行一个 AOF 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 bgrewriteaof 执行失败, 也不会有任何数据丢失, 因为旧的 AOF 文件在 bgrewriteaof 成功之前不会被修改。

从 Redis 2.4 开始,  AOF 重写由 Redis 自行触发,  bgrewriteaof 仅仅用于手动触发重写操作。

### 优点

- 高数据安全性: 由于 AOF 记录了所有的写操作, 即使在多次短暂的写操作后发生故障, 也能确保数据不会丢失
- 可配置的同步频率: 可以根据需要在数据安全性和性能之间做出权衡。
- 人类可读: AOF 文件中的命令是人类可读的, 这使得调试和数据恢复更加容易

### 缺点

- 文件大小: AOF 文件可能会比 RDB 文件大, 因为它记录了所有的写操作
- 数据恢复速度: 由于需要逐条执行命令, AOF 文件的数据恢复速度可能比 RDB 慢
- 磁盘 I/O 负载: 频繁的磁盘同步可能会增加磁盘 I/O 负载

## RDB 和 AOF 的对比

| 特性         | RDB                                                              | AOF                                                                                                      |
| ------------ | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| 持久化方式   | 快照(Snapshot)                                                 | 日志(Log)                                                                                              |
| 数据恢复速度 | 快, 因为是从单一的 RDB 文件中读取数据                            | 慢, 因为需要逐条执行 AOF 文件中的命令来恢复数据                                                          |
| 数据安全性   | 低, 因为在两次快照之间的数据可能会丢失                           | 高, 几乎不会丢失数据, 因为每个写操作都被记录                                                             |
| 文件大小     | 通常较小, 因为是压缩的二进制文件                                 | 可能较大, 因为是文本文件且记录每个操作                                                                   |
| 文件压缩     | 有, RDB 文件可以使用 LZF 算法压缩                                | 无, AOF 文件不压缩                                                                                       |
| 性能影响     | 有, 因为保存 RDB 文件时主进程会被阻塞                            | 较小, 因为 AOF 写入和同步操作可以配置为每秒一次或根据需要同步, 对性能影响较小                            |
| 适用场景     | 适合做全量备份, 或者在数据安全性要求不是非常高的场景下使用       | 适合做数据恢复, 或者在需要高数据安全性的场景下使用                                                       |
| 启动加载     | 启动时可以选择加载 RDB 或 AOF 文件, 如果两者都存在, 优先加载 AOF | 同上                                                                                                     |
| 重写机制     | 无, 但可以通过配置`save`参数来控制快照的生成频率                 | 有, 可以通过配置`auto-aof-rewrite-percentage`和`auto-aof-rewrite-min-size`来自动触发重写, 也可以手动触发 |
| 额外功能     | 无                                                               | 可以通过 AOF 文件进行数据的审计或分析                                                                    |

在实际使用中, 为了获得更好的性能和数据安全性, 很多用户会选择同时开启 RDB 和 AOF 持久化机制。这样, Redis 可以在启动时优先使用 AOF 文件来恢复数据, 以确保数据的完整性, 同时在正常运行时利用 RDB 文件进行快速的数据备份和恢复。
