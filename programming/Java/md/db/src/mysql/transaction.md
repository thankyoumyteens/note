# 事务

事务的特性 ACID:

1. 原子性（Atomicity）：事务中的所有操作要么全部完成，要么全部失败
2. 一致性（Consistency）：事务完成时, 必须使所有的数据都保持一致
3. 隔离性（Isolation）：每个事务都是独立的，不受其他事务的干扰
4. 持久性（Durability）：一旦事务提交，它对数据库的改变就是永久性的

## 并发事务导致的问题

1. 脏读: 相当于事务不考虑并发问题: 一个事务读到另一个事务还没有提交的数据

   | 事务 1               | 事务 2                        |
   | -------------------- | ----------------------------- |
   | 开启事务             | -                             |
   | -                    | 开启事务                      |
   | -                    | 插入 id=1, value='abc' 的数据 |
   | 读取 id=1 的数据     | -                             |
   | 可以读到 value='abc' | -                             |
   | -                    | 提交事务                      |
   | 提交事务             | -                             |

2. 不可重复读: 解决脏读, 但会导致新的问题: 一个事务先后读取同一条记录, 但两次读取的数据不同

   | 事务 1               | 事务 2                        |
   | -------------------- | ----------------------------- |
   | 开启事务             | -                             |
   | 读取 id=1 的数据     | -                             |
   | 没有数据             | -                             |
   | -                    | 开启事务                      |
   | -                    | 插入 id=1, value='abc' 的数据 |
   | -                    | 提交事务                      |
   | 读取 id=1 的数据     | -                             |
   | 可以读到 value='abc' | -                             |
   | 提交事务             | -                             |

3. 幻读: 一个事务不会查到其它事务提交的数据, 解决不可重复读, 但会导致新的问题: 一个事务按照条件查询数据时, 查不到对应的数据, 但是在插入数据时, 又发现这行数据已经存在

   | 事务 1                        | 事务 2                        |
   | ----------------------------- | ----------------------------- |
   | 开启事务                      | -                             |
   | 读取 id=1 的数据              | -                             |
   | 没有数据                      | -                             |
   | -                             | 开启事务                      |
   | -                             | 插入 id=1, value='abc' 的数据 |
   | -                             | 提交事务                      |
   | 插入 id=1, value='def' 的数据 | -                             |
   | 失败, id 为 1 的数据已存在    | -                             |
   | 读取 id=1 的数据              | -                             |
   | 没有数据                      | -                             |
   | 提交事务                      | -                             |

## 事务隔离级别

1. read uncommitted(读未提交): 完全不解决事务的并发问题, 安全性最差
2. read committed(读已提交)
3. repeatable read(可重复读): MySQL 默认的隔离级别
4. serializable(串行化): 禁止事务并发执行, 性能最差

| 隔离级别         | 脏读 | 不可重复读 ｜ 幻读 |
| ---------------- | ---- | ------------------ | --- |
| read uncommitted | 有   | 有                 | 有  |
| read committed   | 无   | 有                 | 有  |
| repeatable read  | 无   | 无                 | 有  |
| serializable     | 无   | 无                 | 无  |

## redo log

数据页: InnoDB 磁盘管理的最小单元, 每个页的大小默认是 16KB, 页中存储的是行数据。

缓冲池: 保存在内存中, 缓存磁盘上常用的数据。在执行增删改查操作时, 会先查询缓冲池中的数据。

缓冲池中的数据会以一定频率刷新到磁盘, 从而减少磁盘 I/O, 提高效率。

增删改数据时, 缓冲池中的数据改变, 如果此时宕机, 还没刷新到磁盘中的数据就会丢失。

redo log（重做日志）是 InnoDB 存储引擎中的一种关键机制，用于确保事务的持久性和数据库的崩溃恢复能力。redo log 记录了数据库中数据页的物理更改，在事务提交时，InnoDB 会将 redo log 写入到磁盘，确保事务的更改在发生故障后可以被恢复。

为了提高性能，InnoDB 会先将 redo log 写入到内存中的日志缓冲区（log buffer），然后在适当的时机刷新到磁盘。虽然写入 redo log 是事务提交的必要步骤，但它通常不会成为性能瓶颈，因为它的写入操作是异步的, 而且由于日志文件是追加的形式, 是顺序的磁盘 I/O, 而数据库的增删改操作是随机磁盘 I/O, 因此 redo log 的效率会更高。

## undo log

undo log（回滚日志）, 当数据被修改时，原始的数据值会被记录到 undo log 中，这样在需要时可以恢复原始状态。它用于以下两个主要目的：

1. 事务回滚
2. 多版本并发控制（MVCC）

与 redo log 的区别：Redo log 记录了数据的更改，用于在系统崩溃后重做更改，而 undo log 记录了数据的原始状态，用于事务回滚和 MVCC。undo log 确保了事务的原子性和一致性。redo log 确保了事务的持久性。

## MVCC

MVCC 和排他锁确保了事务的隔离性。

MVCC（Multi-Version Concurrency Control，多版本并发控制）是 InnoDB 存储引擎实现的一种用于提高数据库并发性能的技术。MVCC 允许多个事务同时对同一数据进行读取和写入操作，而不会相互干扰，从而减少了锁的争用和死锁的可能性。

InnoDB 通过 undo log 保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。

MVCC 只在已提交读和可重复读两个隔离级别下工作，其他两个隔离级别和 MVCC 是不兼容的。因为未提交读总是读取最新的数据，而不是读取符合当前事务版本的数据行。而串行化不允许事务并发执行。

事务版本号: 事务每次开启时，都会从数据库获得一个自增长的事务 ID，可以从事务 ID 判断事务的执行先后顺序。这就是事务版本号。

对于 InnoDB 存储引擎，每一行记录都有两个隐藏列 trx_id 和 roll_pointer, 如果数据表中存在主键或者非 NULL 的 UNIQUE 键时不会创建 row_id, 否则 InnoDB 会自动生成单调递增的隐藏主键 row_id。

trx_id: 记录操作该行数据事务的事务 ID。

roll_pointer: 回滚指针，指向当前记录行的 undo log 信息。

undo log 分为两类：

1. insert undo log: insert 时产生的 undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即删除
2. update undo log: delete 和 update 时产生的 undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被删除
