# 缓存击穿

redis 的某个 key 设置了过期时间, 当 key 过期时, 恰好有大量请求查询这个 key, 可能会导致数据库崩溃。

## 解决方案

1. 添加互斥锁: 查询缓存未命中时, 先获取(分布式)锁, 再取数据库查询, 把数据写入缓存后再释放锁
   - 优点: 保证强一致性
   - 缺点: 性能差
2. 逻辑过期: 不在redis层面设置过期时间, 写入缓存时, 在数据中手动添加一个过期时间字段。查询数据时如果发现过期, 会获取互斥锁并直接返回过期的数据, 然后启动一个线程使用这个互斥锁来更新缓存的数据。其它线程如果发现过期, 也会获取互斥锁, 如果获取锁失败, 表示已经有其它线程在更新缓存了, 直接返回过期的数据就好
   - 优点: 性能好
   - 缺点: 存在数据不一致的情况
