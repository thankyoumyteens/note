# 你说理解 G1 的 Young GC / Mixed GC，大概能说一下两者的区别和触发时机吗？

在 G1 里，其实主要有两种常见的停顿：Young GC 和 Mixed GC。

Young GC 只收集年轻代的 Region，而 Mixed GC 会同时收集年轻代和一部分老年代的 Region，这是两者最大的区别。

### Young GC：是什么 + 什么时候触发

Young GC 可以理解成 G1 里的 Minor GC。

它的典型触发时机比较直接：当新对象在 Eden 区分配发现空间不足，或者 G1 根据暂停时间目标觉得该收一收年轻代了，就会触发一次 Young GC。

在日志里一般会看到 `GC pause (G1 Evacuation Pause) (young)` 这样的标记。

这类 GC 只会处理 Eden 和 Survivor 这些年轻代 Region：

1. 首先从 GC Roots 扫描可达对象；
2. 然后把还活着的对象从 Eden、旧的 Survivor 复制到新的 Survivor，存活时间到了阈值就晋升到 Old 区；
3. 复制完之后，Eden 和旧 Survivor 对应的 Region 就会被整体回收，重新变成空闲 Region。

所以 Young GC 的特点就是：**频率比较高，停顿时间相对短，主要用来处理短命对象，只动年轻代，不回收老年代。**

### Mixed GC：是什么 + 什么时候触发

Mixed GC 是 G1 的一个特点，它介于纯粹的 Young GC 和 Full GC 之间。

Mixed GC 同样是 `G1 Evacuation Pause`，但是类型会是 `(mixed)`，表示这次不仅收年轻代，还会顺带收集一部分老年代 Region。

Mixed GC 的触发是跟并发标记周期绑在一起的：

1. 当整个堆里老年代占用超过一个阈值（G1 里有个 IHOP：Initiating Heap Occupancy Percent，可以自动调整），G1 会启动一次**并发标记**，把整个堆里各个 Region 的存活率统计出来；
2. 并发标记结束之后，如果发现老年代里的垃圾比例比较高，G1 就不会直接 full，而是进入一段 **Mixed GC 周期**；
3. 在这几次 GC 里，每次停顿仍然是 Young 触发的 Evacuation Pause，但是 G1 会额外**挑出一批“垃圾比较多”的 Old Region 一起收集**，而不是把所有老年代一次性收掉。

也就是说，Mixed GC 的收集集合是：**年轻代 Region + 一部分被选中的老年代 Region**，而不是全堆。

这样设计的好处是：G1 不需要一次性 Stop-The-World 回收整个老年代，而是拆成多次 Mixed GC，比较容易在暂停时间和吞吐量之间做平衡。

---

## 深入追问

### 你刚才说 G1 有 Young GC 和 Mixed GC，那在什么场景下会 Full GC？Full GC 和 Mixed GC 的区别是什么？

Full GC 一般是 G1 扛不住了的兜底方案，整堆 Stop-The-World，使用单线程或多线程(JDK10 新增)做传统的标记-整理，停顿时间非常长。

正常情况下，G1 的目标是通过 Young GC + Mixed GC 就把垃圾处理掉，尽量避免 Full GC。只有在老年代空间吃紧、Mixed GC 回收不上来，或者并发标记出问题、老年代分配失败的时候，才会退化到 Full GC。

### G1 的 Mixed GC 能不能理解为 ‘老年代的 Minor GC’？如果不能，你觉得差异在哪？

不能直接把 Mixed GC 理解成“老年代的 Minor GC”。

- 首先，Mixed GC 一定同时包含 Young 部分，也会处理 Eden、Survivor，这一点和 Minor GC 比较像。
- 但 Mixed GC 的关键在于：它只挑选一部分收益比较高的老年代 Region 来回收，不是整个老年代都扫一遍，这跟传统意义上“针对老年代的一次完整 Major GC”不太一样。
- 而且 G1 是基于 Region 和 Remembered Set 来做精确回收的，它在并发标记阶段已经统计了各个老年代 Region 的存活率和回收收益，所以 Mixed GC 更偏向于“按收益优先，分批回收老年代”的策略，而不是“一刀切”的老年代 GC。

所以更准确说法是：Mixed GC 是 G1 利用并发标记结果，对年轻代 + 部分老年代做的一次组合回收，而不是简单的“老年代 Minor GC”。

### 你刚才说 Eden 满了会触发 Young GC，那在 G1 里，Eden 的大小是固定的吗？是谁、通过什么策略决定下一次 Young GC 什么时候发生？

在 G1 里，Eden 的大小不是固定的，是动态调整的。

G1 会根据之前几次 GC 的停顿时间、存活率这些历史数据，去自动调整年轻代（包括 Eden 和 Survivor）的大小，从而尽量满足我们配置的 `-XX:MaxGCPauseMillis` 这个暂停时间目标。

触发 Young GC 的直接表象是“Eden 分配不下了”，但是：

- 谁在调 Eden 大小？是 G1 的内存调度器 / 自适应策略 在控制，也就是 JVM 里那套 ergonomics（自适应优化）机制。它会根据：
  - 上几次 Young/Mixed GC 的实际停顿时间；
  - 每次 GC 后还活着多少对象（存活率）；
  - 当前堆的使用情况； 来决定：“下一次给年轻代分多少 Region 才更有可能在目标暂停时间内收完。”
- Eden 怎么变？
  - 如果最近几次 Young GC 都非常快，远低于 MaxGCPauseMillis，G1 可能会扩大年轻代（Eden + Survivor），让每次 GC 回收更多垃圾、频率降低。
  - 如果最近 Young GC 一直超出目标暂停时间，它就会缩小年轻代，让每次需要扫描和复制的对象变少，从而降低每次停顿时间。

所以总结一句：Eden 大小在 G1 里是动态可调的，由 G1 的自适应算法根据历史 GC 行为和 MaxGCPauseMillis 来决定；而 “Eden 被填满”只是 Young GC 的直接触发条件，背后真正控制 Young GC 频率和规模的是 G1 的这个自适应策略。

### 如果我把 `-XX:MaxGCPauseMillis` 调得很小，比如 50ms，对 Young GC 的频率和每次回收规模会有什么影响？

MaxGCPauseMillis 在 G1 里，其实是一个“期望的最大停顿时间目标”，不是硬性上限。

如果我把它调得很小，比如 50ms，会对 Young GC 带来两个直接影响：

1. 每次 Young GC 回收的规模会变小
   - 为了尽量把一次 GC 停顿控制在 50ms 以内，G1 会倾向于：
     - 减小年轻代的大小（包括 Eden + Survivor 的 Region 数）；
     - 每次 GC 时要处理的对象、扫描的卡片、复制的对象会变少；
   - 这样单次 GC 的工作量减少，停顿时间才有希望接近 50ms。
   - 对 Mixed GC 也类似：它会在一次 Mixed GC 里选择更少的老年代 Region 参与回收，避免把一堆“脏活累活”堆在同一次停顿里。
2. Young GC 的频率会变高
   - 因为年轻代整体被压缩了，每次给 Eden 分配的空间变少，新对象更快把 Eden 填满；
   - 一旦 Eden 里可用的 Region 用完，就要触发 Young GC；
   - 所以结果就是：GC 次数变多，但单次停顿变短。
3. 潜在副作用
   - 如果目标设得过于激进，比如 50ms，而业务对象存活率又比较高：
     - Young GC 频率非常高，应用线程会频繁被打断；
     - 年轻代太小，对象很快晋升到老年代，老年代膨胀速度加快；
     - 后面为了控制老年代，又会加大 Mixed GC 的密度，甚至在极端情况下可能更容易顶到 Full GC。
   - 所以调得太小，不一定提升整体吞吐量，反而可能让应用“抖得更厉害”。

总结一下：

- 把 MaxGCPauseMillis 调小 -> 单次 Young GC 规模变小，频率变高；
- 调得过小的话，整体吞吐量和老年代压力可能会变差，需要结合监控数据去权衡，而不是一味追求小停顿。

### Mixed GC 是在并发标记之后触发的，这个并发标记是如何被触发的？

在 G1 里，并发标记的触发其实主要是由老年代占用比例来驱动的，它不是随便什么时候都在跑。

大致可以分三点来说：

#### 1. 触发条件的核心：老年代占用到了一定阈值

G1 会维护一个“老年代占用了整个堆多少比例”的指标。

当这个比例超过一个阈值（可以认为是类似 InitiatingHeapOccupancyPercent 这样的参数）时，就会启动一个新的并发标记周期。

可以这么理解流程：

1. 程序一直在跑，Young GC 在不断发生，对象在晋升，老年代越来越大。
2. G1 一直在监控：老年代占用 / 整个堆
3. 当这个比例超过触发阈值，比如说 45% 或 50%（具体值可以通过参数调整），G1 认为：“如果再不开始并发标记，等到老年代真的满了就晚了。”
4. 然后就启动一次 Concurrent Marking（并发标记周期）。

#### 2. 并发标记从哪里开始？怎么跑？

启动并发标记后，G1 会经历一套固定的阶段，一般包括：

1. Initial Mark（初始标记）
   - 通常会和一次 Young GC 的停顿合并在一起完成；
   - 在这个阶段，会标记从 GC Roots 直接可达的对象，尤其是那些位于老年代的根对象。
2. Concurrent Mark（并发标记阶段）
   - 这一步是和应用线程并发执行的；
   - GC 线程在后台从已标记对象出发，遍历整个对象图，给老年代中的存活对象打标记；
   - 同时会统计每个 Region 的存活比例，给后面的 Mixed GC 选择“性价比高”的老年代 Region 做准备。
3. Remark（重新标记）
   - 短暂停顿（STW）；
   - 把并发标记期间新产生或变化的引用补一补，保证标记结果尽量完整、准确。
4. Cleanup（清理/回收准备）
   - 再做一些统计和状态清理；
   - 确定哪些 Region 基本都是垃圾，可以回收；
   - 把这些 Region 标记成“可在后续 Mixed GC 中回收”的候选集合。

等这一整套并发标记流程结束后，G1 就有了“老年代中每个 Region 的存活率和回收收益”的信息，接下来就可以开始安排 Mixed GC 了。

#### 3. 并发标记 + Mixed GC 的节奏关系

标记结束之后，之后的几次 GC，会从 Young GC 变成 Mixed GC；

每次 Mixed GC：

- 一定会收集年轻代；
- 另外再从老年代 Region 里，按回收收益（垃圾比例高）排序，挑出一小批加入这次回收；

这样就把大块的老年代回收工作，拆散在多次 Mixed GC 里摊平，避免一次停顿特别长。

所以总结一下触发逻辑就是：

老年代使用比例超过阈值 -> 触发并发标记周期 -> 标记阶段收集存活/收益信息 -> 标记完成后的一段时间内改用 Mixed GC 回收老年代。

### 你知道 `InitiatingHeapOccupancyPercent` 这个参数吗？默认是怎么工作的？

知道，这个参数在 G1 里很关键，叫 IHOP（Initiating Heap Occupancy Percent），它主要决定：

- “老年代 / 整个堆 的占用比例到多少时，G1 开始触发并发标记周期。”

也就是说，它是用来控制 什么时候启动 Concurrent Marking 的一个阈值。

以前早期版本（比如 JDK7/8 很多资料里）常见的默认值是 45% 左右，但现在实际实现里，G1 对 IHOP 是有“自适应（adaptive）机制”的，默认不是简单死板地用一个固定百分比“死扛到底”。

所以可以这么说：

1. JVM 启动后，G1 有一个初始 IHOP 阈值（比如 45%）。
2. 程序跑起来，Young GC 在不停发生，对象在晋升，老年代占用越来越大。
3. 当老年代 / 堆容量 接近这个阈值的时候，G1 会决定：“现在开始一个新的 Concurrent Mark 周期。”
4. 这一次并发标记做完后，G1 会回头看历史数据：
   - 从“开始并发标记”到“Mixed GC 真正开始跑”之间，老年代膨胀得有多快？
   - 这次并发标记是不是有点晚了 / 早了？
5. 下一轮的时候，它会对实际触发点做微调：
   - 如果上次险些顶满，它就会更早一些触发；
   - 如果上次明显太早，老年代还很空，它就可以稍微推迟一点触发。

一般情况下，我不会一上来就随便改 InitiatingHeapOccupancyPercent，会先跑一段时间，看 GC 日志里并发标记开始和结束的时间、老年代增速，如果发现：

- 并发标记经常结束得太晚、老年代很紧：可以考虑适当调低 IHOP，让标记更早一点开始；
- 如果系统一直比较空，IHOP 调得太低反而让标记太频繁，也可以略微调高一些。

### G1 的 IHOP 有 ‘静态’ 和 ‘自适应’ 两种模式，你了解吗？大致说一下。

G1 的 IHOP（Initiating Heap Occupancy Percent）确实有静态模式和自适应模式两种：

- 静态模式：完全按照我们配置的百分比触发并发标记；
- 自适应模式：G1 根据历史数据动态调整触发点，不死板用那个百分比。

这两个模式的核心区别在于：“触发并发标记的阈值是固定的，还是自动算出来的。”

### Mixed GC 只回收一部分老年代 Region，但必须保证不会漏掉从其他 Region 指向这些 Region 的引用。G1 是怎么做到的？

G1 能只回收部分老年代 Region 而不漏引用，核心靠两块：

- 每个 Region 自己有一个 Remembered Set（RSet）
  - RSet 告诉 GC：哪些 Region、哪些卡片(Card)上可能有指向 R 的引用；
  - Mixed GC 回收某个 Region 时，不需要全堆扫，只要看这个 Region 的 RSet，就知道从其它 Region 过来的所有跨 Region 引用。
- 写屏障 + 卡表维护 RSet 的准确性
  - 当应用线程更新引用时，通过写屏障把“跨 Region 的引用修改”记录到卡表 / RSet 里，保证 RSet 不会漏；
  - 再结合 G1 的并发标记使用 SATB（Snapshot-At-The-Beginning）写屏障，保证在标记期间对象存活信息也是完整的。

#### G1 怎么用 RSet？

RSet 不是“我指向谁”，而是“谁指向我”；可以理解成：“对于 Region R，RSet 记录了：哪些其它 Region 的哪些卡（Card）里可能有指向 R 的引用。”

G1 选择某个老年代 Region R 进入回收集时：

- 不用全堆找“谁引用 R”；
- 只要看 R 的 RSet 里记录的那些卡，去这些卡对应的内存区域里精确扫描引用；
- 找到指向 R 的引用，这些目标对象如果不在回收集里(代表本次不会回收它们)，就标记为存活，避免被错误回收。

好处

- 不需要在 Mixed GC 时全堆扫描老年代；
- 只需为每个被回收的 Region 扫它的 RSet，规模可控，停顿时间可预测。

#### RSet 怎么保持“不会漏”？

RSet 的准确性很关键，不然就会“漏”跨 Region 引用。

G1 主要通过**写屏障（Write Barrier）+ 卡表（Card Table）**来维护 RSet。

当应用线程在跑的时候，对象引用是一直在变的，比如：

- 从 Region A 的对象字段里写入一个指向 Region B 对象的引用；
- 或者把一个原本指向 B 的引用改成 null 或者改成指向别的对象。

G1 不能每次写引用都全堆检查，只能用写屏障做一点“增量记录”。

##### 卡表（Card Table）

- 堆被逻辑上再切分成很多“卡片”（比如每张卡 512B 或 1KB）；
- 卡表记录某张卡是否“脏”（即里面的引用可能发生了跨 Region 修改）。

##### 写屏障做的两件事

当应用线程执行类似：

```java
objA.field = objB;  // 可能是跨 Region 的引用写
```

写屏障会拦一下这次写操作，并做一些附加动作：

- Card Marking（标记卡片为脏）
  - 把 objA 所在地址对应的那张卡表项标记为“脏”；
  - 后续 G1 会基于这些“脏卡”更新 RSet：这张卡上如果有指向其它 Region 的引用，就加到对应 Region 的 RSet 里。
- 在并发标记阶段还会触发 SATB 相关逻辑
  - 如果是删除老引用、或者覆盖指针，写屏障会把“旧值”也记录下来，保证并发标记不漏（这个更多是保证标记的正确性，和 RSet 一起配合）。

JVM 不会实时、逐写地更新完整 RSet，而是：

- 写屏障把卡片标记脏；
- 在合适时机（比如 GC 前或某些维护阶段），从这些脏卡中抽取跨 Region 引用，更新到对应 Region 的 RSet；
- 然后把卡片标记回“干净”。

这样既保证了 RSet 最终是一致的，又不会把写屏障的开销搞得太大。

### 如果应用写入非常频繁，RSet 的维护会带来什么开销？你在排查过哪些因为卡表 / RSet 导致的 GC 问题吗？
