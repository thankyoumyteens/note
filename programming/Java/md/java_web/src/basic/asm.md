# 你说有 ASM 字节码增强的实践，具体是做什么？为什么不用 Spring AOP？

在 XX 项目里，我们曾经做过一个**统一的接口审计与性能统计组件**，最开始用的是 Spring AOP + 注解方式，后面遇到两个问题：

1. 有一部分是第三方 jar 包里的类，无法直接加注解或改代码；
2. AOP 在某些高调用频次的核心链路上，有一定性能开销，我们想要更细粒度地控制增强点。

所以后来尝试了基于 ASM 的字节码增强，主要做了两类事情：

1. 在类加载阶段对特定包下的方法进行字节码修改，注入「进入方法时间点、出方法时间点、异常捕获」等逻辑，然后把数据异步上报到监控系统；
2. 对接第三方 SDK 的入口方法进行增强，不需要修改原始源码，就能加入我们自己的 traceId 透传逻辑。

Spring AOP 更偏向于业务层面的横切关注点，而 ASM 直接操作字节码，虽然复杂一些，但能做到：

- 不依赖 Spring 容器；
- 可以增强第三方类；
- 在某些高性能场景下更精细地控制增强粒度。

当然，ASM 只用在少数关键场景，大部分业务层的横切还是用 Spring AOP 来做。

---

## 深入追问

### 你刚才说“在类加载阶段对特定包下的方法做字节码修改”，这个是怎么接入到 JVM 生命周期里的？是 Java Agent 还是自己写的自定义 ClassLoader，能具体说说吗？

我们当时是走的 Java Agent + Instrumentation 这一套

1. 启动方式
   - 在 JVM 启动参数里加：`-javaagent:/path/to/agent.jar`
   - 这样 JVM 启动时会先加载我们的 agent。
2. agent 入口类
   - agent.jar 里有一个 `premain(String agentArgs, Instrumentation inst)` 方法。
   - 在 premain 里，我们通过 `inst.addTransformer(...)` 注册了一个 ClassFileTransformer。
3. 增强时机
   - 每当有类要被加载时，JVM 会回调我们的 transform 方法，传入原始的字节码数组。
   - 在这个 transform 里，我们用 ASM 读取、修改字节码，然后返回增强后的字节码给 JVM，最后再由 JVM 去定义这个类。
4. 过滤范围
   - 在 transform 里，我们只对符合条件的类做处理，比如包名以 com.xxx.service 开头，或者类名匹配某些第三方 SDK 的入口类，其它的一律直接返回 null，不做修改。

这样做的好处是：

- 不侵入业务代码；
- 能够增强到第三方 jar 里的类，只要它通过标准的类加载流程。

### 那在 ASM 里具体是怎么给方法加“进入、退出、异常”的逻辑的？能讲讲你大致操作了哪些指令、是覆盖 visitMethod 还是怎么做的？

整体是基于 ASM 的 ClassVisitor + MethodVisitor 模式，逻辑大概是这样：

1. 遍历类结构
   - 在 ClassVisitor#visitMethod 里拿到每一个方法的 MethodVisitor。
   - 对不需要增强的方法直接返回原来的 visitor，对命中规则的方法包一层自定义的 MethodVisitor。
2. 方法进入点增强
   - 在 MethodVisitor#visitCode（方法字节码开始）时，插入一段字节码：
   - 调用我们自定义的工具类，比如 `TraceHelper.onMethodEnter(className, methodName)`；
   - 这个工具类里会记录当前时间、生成一个调用 ID(TraceID) 等，放到 ThreadLocal 或者 MDC 里。
3. 方法正常退出增强
   - 通过重写 visitInsn，在遇到 IRETURN、ARETURN、RETURN 等 return 指令前，先插入：
     - 调用 `TraceHelper.onMethodExit(callId, null)`；
     - 内部会计算耗时、组装审计日志，异步上报。
4. 异常退出增强
   - 用 ASM 给方法包一个 try-catch：
   - 在异常 handler 里，插入调用 `TraceHelper.onMethodException(callId, throwable)`；
   - 然后再把异常重新抛出，保证原有语义不变。
5. 性能方面的小优化
   - 尽量少做对象创建，把调用 ID 等信息尽量放在 ThreadLocal 或局部变量里；
   - 上报部分完全是异步，主线程只是打点，减少对原有业务的影响。

这样就能在不改源码的情况下，为指定包下的方法自动插入“进出日志 + 耗时统计 + 异常捕获”。

### 你说 Spring AOP 在高频链路上有性能开销，这个你们有量化过吗？跟 ASM 增强相比，大概差距在哪儿？

我们当时做过一轮简单 Benchmark，场景就是一个非常简单的方法，循环调用几百万次，分别用：

- 直接调用；
- Spring AOP（基于 CGLIB 的代理）；
- ASM 字节码增强后直接调用。

测试结论大概是：

1. 直接调用
   - 作为基准，QPS 最高、时延最低。
2. Spring AOP 代理
   - 多了代理对象和 MethodInvocation 的那层封装；
   - 在我们那次测试中，平均时延大概是基准的 1.3~1.5 倍，根据切面的复杂度有所变化；
   - 在普通业务接口里完全可以接受，但在极大量循环调用 / 高频打点的链路上，这个额外开销就有些明显了。
3. ASM 增强
   - 增强后方法本身就包含了打点逻辑，调用路径上没有代理这层；
   - 在我们的压测里，时延大概只比直接调用多了 5~10% 左右，主要开销来自我们自己的打点逻辑（比如记录时间和异步上报），而不是框架本身。

所以整体看下来：

- 绝大部分业务接口：Spring AOP 足够，且开发效率很高；
- 极端高频的底层基础库、第三方 SDK 入口：我们更倾向用 ASM，牺牲一些开发复杂度，换一点性能和可控性。

### 增强第三方 jar 比较容易搞出兼容性问题，比如版本升级、签名校验失败之类的，你们在这块有什么保护措施没有？

这个确实是 ASM 带来的额外风险，我们主要做了几层保护：

1. 严格匹配增强范围
   - 不直接用“前缀匹配包名”这种粗暴方式；
   - 对于第三方 SDK，我们会配置明确的“类名 + 方法签名”白名单，比如：
     - `com.xxx.sdk.Client#doRequest(Ljava/lang/String;)Lcom/xxx/Response`;
   - 非白名单的一律不改，减少误伤概率。
2. 增强失败要优雅降级
   - 在 ClassFileTransformer#transform 里，整个 ASM 修改逻辑都包 try-catch；
   - 一旦出现 ASM 解析异常、修改异常，直接返回原始字节码，让类按原样加载，不影响业务启动和运行；
   - 同时打出错误日志，方便排查。
3. 版本兼容
   - 对第三方 SDK，我们通常会固定一两个版本做适配；
   - 每次升级 SDK 版本时，会配套升级 agent 里的匹配规则，并在测试环境先跑一轮回归；
   - 对于不确定的版本，agent 端可以加一个“版本白名单”，只对特定版本号生效。
4. 可开关 / 可动态关闭
   - 增强逻辑本身是可配置的，比如通过系统属性 / 环境变量控制开关；
   - 线上一旦发现某个增强有问题，可以通过配置快速关掉对应增强点，避免必须重启或回滚。

这样至少保证：“最坏情况下，业务像没加过 agent 一样正常跑，只是没有这些监控和埋点能力。”

### 字节码改错了很难调试，你们当时是怎么验证这些增强逻辑是对的？有用到哪些工具或者手段吗？

我们当时主要用这几种方式：

1. 打印增强后的字节码 / 反编译查看
   - ASM 处理完后，会在测试环境把增强后的 .class 写到本地临时目录；
   - 然后用 javap -c 或者 IDEA 里的 FernFlower 反编译插件，直接跟原始代码比对，看插入的指令是不是在我们预期的位置。
2. 单元测试 + 集成测试
   - 对关键增强点写专门的测试用例，验证：
     - 原来的业务逻辑行为不变；
     - 日志、traceId、耗时这些是否被正确采集到；
     - 异常路径下是否也能正常打点，不吞异常。
3. 灰度发布
   - agent 的上线一定是先在预发环境验证，然后在一小部分机器灰度，观察：
     - 错误率有没有波动；
     - GC、CPU、延迟有没有异常变化；
   - 没问题再全量放量。

### 你提到用 ASM 给第三方 SDK 增强 traceId 透传，能具体讲讲：你是从哪儿拿 traceId，透到哪儿去？中间用的是什么形式？

我们当时主要是解决两个问题：

1. 应用内部已经有 traceId（通过网关注入），但：
   - 第三方 SDK 自己的 Client 不知道这个 traceId；
   - 直接改 SDK 源码不现实。
2. 希望在调用第三方 HTTP/SDK 时，能把 traceId 统一塞到请求里，方便下游排查问题。

具体做法是：

1. 获取 traceId
   - 在我们增强的方法里，通过 ThreadLocal / MDC 拿当前线程上的 traceId；
   - 如果没有，就生成一个新的，保证后续链路都有东西可用。
2. 透传方式
   - 如果是 HTTP 请求：
     - 在增强逻辑里，对 HttpRequest 对象进行操作，往 Header 里加一个 X-Trace-Id；
   - 如果是自定义的 SDK 协议：
     - 找到它的 Request 对象，把 traceId 塞到它的 context 或 metadata 字段里。
3. 下游配合
   - 对于我们自己控制的下游服务，会统一从 Header/context 里解析 traceId，打入日志，形成完整的调用链。
