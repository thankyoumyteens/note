# 说一个你用MQ做异步解耦/削峰的具体场景

项目中的短信、站内信、APP 推送等。

我们把「核心业务处理」和「通知推送」解耦开来：

1. 前台请求只负责写主业务数据，并同步发送一条消息到 MQ（包含用户 ID、业务类型等简单信息）；
2. 通知服务作为消费者异步消费这条消息，完成短信、站内信、APP 推送等动作；
3. 消费端做了幂等控制，确保重复消息不会导致多次发送（比如基于消息 ID 或业务 ID 做去重）。

这样带来的好处是：

- 前台接口响应更快，用户体验更好；
- 通知服务可以独立扩展，遇到高峰时可以通过增加消费者实例来「削峰填谷」。

## 深入追问

### 你为什么要用 MQ 来做这个异步通知？如果不用 MQ 会有什么问题？

如果不用 MQ，通知逻辑直接写在核心业务事务后面，主要有几个问题：

1. 响应时间变长
   - 核心业务：比如写库几十毫秒就够了；
   - 通知：要调用短信供应商、推送服务等外部接口，可能一条就几百毫秒，甚至秒级。
   - 串在一起会导致接口整体 RT 升高，用户点一下按钮要等很久才能看到结果。
2. 稳定性差，外部依赖拖垮核心流程
   - 短信网关或者推送服务经常会有超时、限流、偶发失败；
   - 如果这些都在主线程里执行，只要网关抖一下，整个核心业务接口就会变慢甚至超时。
3. 耦合度高，扩展不方便
   - 后面如果要加一种新的通知方式，比如企业微信、邮件，每增加一种都要改核心业务代码；
   - 发布和故障也会相互影响，通知有问题时可能拖累主业务。

引入 MQ 之后：

- 核心接口只做两件事：
  - 保证主业务事务成功；
  - 成功后发一条简单消息到 MQ。
- 通知服务拿到消息之后异步发送短信、站内信、APP 推送，出现问题只影响通知链路。

### 你刚说“写主业务 + 发送 MQ 消息”，那如何保证这两步的一致性？主业务成功但消息没发出去怎么办？

这是我们重点考虑的一致性问题，不能出现“业务成功了，但用户完全收不到任何通知”的情况。我们主要有两层保障：

1. 本地事务 + 本地消息表（最终一致）
   - 在核心业务库里建一张 message_outbox 表，用来记录待发送的通知消息，里面有：
     - 业务 ID、用户 ID、消息类型、状态、重试次数等。
   - 在同一个本地事务里同时：
     - 写主业务表；
     - 写一条“待发送”的消息到 message_outbox。
   - 这样可以保证：只要事务提交成功，主业务和“要发一条通知”这件事是一起成功的。
2. 异步投递 + 补偿机制
   - 有一个后台任务/小服务，定时扫描 message_outbox 中状态为“待发送/发送失败”的记录：
     - 发送到 MQ；
     - 成功后把状态更新为“已发送”；
     - 如果 MQ 短暂不可用，通过重试和告警的方式补偿。
   - 即使“写库成功但当时 MQ 不可用”，这个任务也能把消息补出去，达到最终一致性。

### 你说“消费端做了幂等控制”，具体是怎么保证幂等的？MQ 可能会重复投递时你们做了什么？

我们默认 MQ 至少一次投递，所以消费者一定要幂等。我们主要做了几件事：

1. 业务 ID / 消息 ID 去重表
   - 设计每条通知有一个全局唯一标识，比如：notify_id，或者 (业务类型 + 业务 ID) 组合。
   - 消费前先往一张“去重表”或者 Redis 里写一条记录（用唯一索引/SET）：
     - 如果写入成功，说明是第一次消费，可以继续发送通知；
     - 如果发现记录已存在，说明这条已经处理过，直接丢弃本次消费。
2. 发送记录落库
   - 每条通知发送成功后，会在通知表里落一条记录：包含业务 ID、通知渠道（短信/站内信/APP）、状态等信息。
   - 发送前根据 (业务 ID + 渠道) 查一次，如果已经有成功记录，就不再发，防止重复消息。
3. 超时重试与状态机
   - 如果调用第三方短信/推送失败，我们会根据状态和重试次数做有限次重试；
   - 每次重试也是按照上面的幂等逻辑来判断，保证不会重复发送多条。

整体上，就是用“唯一业务标识 + 去重记录 + 发送记录”三层防护，来适配 MQ 的重复投递特性。

### 你提到“削峰填谷”，具体是怎么削的？高峰期大量通知消息进来时怎么保护下游渠道？

高峰期会出现瞬时大量通知任务，我们的削峰策略主要在两层：

1. 利用 MQ 的缓冲能力
   - 前台请求只负责把消息写入 MQ，写入成功就返回；
   - MQ 本身就是一个天然的“缓冲队列”，高峰时消息会堆积在 MQ 中，后台消费者按自己的能力慢慢消费；
   - 这样不会因为下游短信网关变慢而把前台接口拖垮。
2. 消费端限流 + 并发控制
   - 每个消费者实例内部会控制并发度，比如线程池大小、每次批量拉取的消息数量；
   - 对接第三方短信、APP 推送网关时，也会做调用限流：
   - 比如“每秒最多调用 X 次”，超过就排队或降级；
   - MQ 端可以根据堆积情况，临时多拉几个消费者实例上来，提高整体消费能力。
3. 降级策略
   - 如果监控发现某个渠道异常（比如短信网关严重超时）：
   - 可以暂时只保留“关键通知”（如验证码），对非关键的推送做降级或延后；
   - 或者把失败的通知标记为“待人工处理/后续补发”，避免一直狂重试，进一步冲击下游。
