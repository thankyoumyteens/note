# 你是怎么在项目中应对缓存击穿/穿透/雪崩这些问题的？

1. **缓存穿透（查询一个一定不存在的数据，直打数据库）**
   - 第一层是缓存空值。当某个 key 缓存 miss，DB 查出来也没有，就在缓存里写一个空值占位，并设置一个比较短的 TTL，比如几分钟。这样相同的无效 key 再来时就能直接在缓存命中，避免频繁查 DB。
   - 第二层是在入口侧做过滤。简单一点的是参数校验，比如 ID 范围、格式校验，把明显不合法的请求在网关就挡住。再高级一点可以上布隆过滤器，提前把所有合法 ID 加进去，请求进来先查布隆过滤器：如果判断“这个 key 一定不存在”，就直接返回，不再访问缓存和数据库。
2. **缓存击穿（某个热点 key 过期，大量并发同时打到数据库）**
   - 普通热点 key：
     - 用「互斥锁 + 双重检查」的方式，只允许一个线程回源数据库，其他线程要么等待，要么等缓存重建后再读；
     - 锁可以用 Redis 分布式锁，注意获取锁前后都要再查一次缓存，避免重复回源。
   - 特别核心的热点数据：
     - 会用「逻辑过期」方案，而不是直接依赖 Redis 的 TTL 让 key 消失；
     - 在 value 里带一个 expireTime 字段，读的时候如果逻辑过期了，先返回旧值，同时异步触发后台线程刷新缓存；
     - 这样对外几乎没有 RT 抖动，也不会出现大批请求瞬间打到 DB，只是接受一个短暂的不一致窗口。
3. **缓存雪崩（大批 key 同时过期，导致数据源压力骤增）**
   - 设置过期时间时加随机因子，避免同一时间大面积失效；
   - 对部分核心数据采用多级缓存策略（本地缓存 + 分布式缓存）；
   - 再配合限流、降级措施，在缓存不可用时期保护数据库和下游。

## 互斥锁 + 双重检查（适合常规热点 key）

用锁把“回源数据库”这件事串行化，只允许一个线程去 DB，避免高并发时所有请求一起打 DB。

1. 线程 A 查询缓存：发现 key 不在缓存。
2. A 去竞争“加载锁”（可以是 Redis 分布式锁等）。
3. 抢到锁的线程（假设就是 A）：
   1. 再次到缓存里 _做一次检查（双重检查）_，因为可能在自己等锁/获取锁的这段时间，别的线程已经加载完了。
   2. 如果此时缓存里已经有了，就直接返回；
   3. 如果还是没有，再去 DB 查数据；
   4. 把查到的数据写回缓存，然后释放锁。
4. 其他没抢到锁的线程有两种策略：
   - 要么等待一小段时间，等锁释放后再从缓存里读；
   - 要么直接返回“过期前的旧值”（如果你做了逻辑过期 / 双缓存）。
