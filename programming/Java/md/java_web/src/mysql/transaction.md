# 事务

事务的特性 ACID:

1. 原子性(Atomicity): 事务中的所有操作要么全部完成, 要么全部失败
2. 一致性(Consistency): 事务完成时, 必须使所有的数据都保持一致
3. 隔离性(Isolation): 每个事务都是独立的, 不受其他事务的干扰
4. 持久性(Durability): 一旦事务提交, 它对数据库的改变就是永久性的

## 并发事务导致的问题

1. 脏读: 相当于事务不考虑并发问题: 一个事务读到另一个事务还没有提交的数据

   | 事务 1               | 事务 2                        |
   | -------------------- | ----------------------------- |
   | 开启事务             | -                             |
   | -                    | 开启事务                      |
   | -                    | 插入 id=1, value='abc' 的数据 |
   | 读取 id=1 的数据     | -                             |
   | 可以读到 value='abc' | -                             |
   | -                    | 提交事务                      |
   | 提交事务             | -                             |

2. 不可重复读: 解决脏读, 但会导致新的问题: 一个事务先后读取同一条记录, 但两次读取的数据不同

   | 事务 1               | 事务 2                        |
   | -------------------- | ----------------------------- |
   | 开启事务             | -                             |
   | 读取 id=1 的数据     | -                             |
   | 没有数据             | -                             |
   | -                    | 开启事务                      |
   | -                    | 插入 id=1, value='abc' 的数据 |
   | -                    | 提交事务                      |
   | 读取 id=1 的数据     | -                             |
   | 可以读到 value='abc' | -                             |
   | 提交事务             | -                             |

3. 幻读: 一个事务不会查到其它事务提交的数据, 解决不可重复读, 但会导致新的问题: 一个事务按照条件查询数据时, 查不到对应的数据, 但是在插入数据时, 又发现这行数据已经存在

   | 事务 1                        | 事务 2                        |
   | ----------------------------- | ----------------------------- |
   | 开启事务                      | -                             |
   | 读取 id=1 的数据              | -                             |
   | 没有数据                      | -                             |
   | -                             | 开启事务                      |
   | -                             | 插入 id=1, value='abc' 的数据 |
   | -                             | 提交事务                      |
   | 插入 id=1, value='def' 的数据 | -                             |
   | 失败, id 为 1 的数据已存在    | -                             |
   | 读取 id=1 的数据              | -                             |
   | 没有数据                      | -                             |
   | 提交事务                      | -                             |

## 事务隔离级别

1. read uncommitted(读未提交): 完全不解决事务的并发问题, 安全性最差
2. read committed(读已提交)
3. repeatable read(可重复读): MySQL 默认的隔离级别
4. serializable(串行化): 禁止事务并发执行, 性能最差

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| read uncommitted | 有   | 有         | 有   |
| read committed   | 无   | 有         | 有   |
| repeatable read  | 无   | 无         | 有   |
| serializable     | 无   | 无         | 无   |

## redo log

数据页: InnoDB 磁盘管理的最小单元, 每个页的大小默认是 16KB, 页中存储的是行数据。

缓冲池: 保存在内存中, 缓存磁盘上常用的数据。在执行增删改查操作时, 会先查询缓冲池中的数据。

缓冲池中的数据会以一定频率刷新到磁盘, 从而减少磁盘 I/O, 提高效率。

增删改数据时, 缓冲池中的数据改变, 如果此时宕机, 还没刷新到磁盘中的数据就会丢失。

redo log(重做日志)是 InnoDB 存储引擎中的一种关键机制, 用于确保事务的持久性和数据库的崩溃恢复能力。redo log 记录了数据库中数据页的物理更改, 在事务提交时, InnoDB 会将 redo log 写入到磁盘, 确保事务的更改在发生故障后可以被恢复。

为了提高性能, InnoDB 会先将 redo log 写入到内存中的日志缓冲区(log buffer), 然后在适当的时机刷新到磁盘。虽然写入 redo log 是事务提交的必要步骤, 但它通常不会成为性能瓶颈, 因为它的写入操作是异步的, 而且由于日志文件是追加的形式, 是顺序的磁盘 I/O, 而数据库的增删改操作是随机磁盘 I/O, 因此 redo log 的效率会更高。

## undo log

undo log(回滚日志), 当数据被修改时, 原始的数据值会被记录到 undo log 中, 这样在需要时可以恢复原始状态。它用于以下两个主要目的:

1. 事务回滚
2. 多版本并发控制(MVCC)

与 redo log 的区别: Redo log 记录了数据的更改, 用于在系统崩溃后重做更改, 而 undo log 记录了数据的原始状态, 用于事务回滚和 MVCC。undo log 确保了事务的原子性和一致性。redo log 确保了事务的持久性。
