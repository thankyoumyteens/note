# SpringCloud

## CAP 定理

- 一致性(Consistency): 指的是所有节点在同一时刻看到的数据是相同的。即, 一旦一个写操作被确认成功完成, 那么之后的所有节点的读操作都应该返回最新的值
- 可用性(Availability): 指的是每个请求无论是否最终成功都要得到响应。即, 每个操作都应该在有限的时间内得到回复, 即使这个回复是失败信息
- 分区容错性(Partition tolerance): 指的是即便一部分节点由于网络问题无法与其他节点通信时, 系统仍然能够继续运作

在实际应用中, 分布式系统一定是需要网络的, 而网络故障是不可避免的, 所以分区容错性是必须的。

- AP: 如果要保证系统可以持续对外提供服务, 那么就不能保证系统数据的强一致性
- CP: 如果要保证系统数据的强一致性, 就要放弃高可用性

## nacos 实现了 CAP 中的哪两个

Nacos 既可以实现 AP（可用性和分区容错性）模式，也可以实现 CP（一致性和分区容错性）模式，用户可以根据具体的业务场景选择合适的模式。

Nacos 默认采用 AP 模式，在集群环境下，即使部分节点出现故障或网络分区，客户端仍然可以从其他可用节点获取服务信息和配置信息。

可以通过修改 Nacos 配置文件中的 mode 参数将 Nacos 切换为 CP 模式。

## 什么是服务熔断？什么是服务降级

熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。

服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的 fallback 回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。

在 SpringCloud 框架里熔断机制通过 Hystrix 实现，Hystrix 会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是 5 秒内调用 20 次，如果失败，就会启动熔断机制。

Hystrix 相关注解 @EnableHystrix：开启熔断 @HystrixCommand(fallbackMethod=”XXX”)：声明一个失败回滚处理函数 XXX，当被注解的方法执行超时（默认是 1000 毫秒），就会执行 fallback 函数，返回错误提示。

## Eureka 和 zookeeper 的区别

- CAP 理论
  - Eureka：遵循 AP（可用性和分区容错性）原则。当某个 Eureka 节点出现故障时，其他节点仍然可以正常提供服务注册与发现服务，客户端可以继续从可用节点获取服务信息
  - ZooKeeper：遵循 CP（一致性和分区容错性）原则。只有当大多数节点正常工作时，ZooKeeper 才会对外提供服务，否则会停止服务以避免数据不一致
- 服务实例状态监测
  - Eureka：采用客户端主动向 Eureka 服务器发送心跳的方式来监测服务实例的状态。服务实例会定期向 Eureka 服务器发送心跳请求，如果 Eureka 服务器在一定时间内没有收到服务实例的心跳，则认为该服务实例已经失效，并将其从服务注册表中移除
  - ZooKeeper：使用临时节点来表示服务实例，当服务实例与 ZooKeeper 失去连接时，对应的临时节点会自动删除，ZooKeeper 会通知其他客户端该服务实例已下线
- 集群架构
  - Eureka：采用去中心化的架构，各个 Eureka 节点之间是平等的，没有主从之分, 每个 Eureka 节点都可以接收服务注册和提供服务发现功能
  - ZooKeeper：采用主从架构，其中有一个 Leader 节点和多个 Follower 节点。Leader 节点负责处理所有的写操作，Follower 节点负责处理读操作。当 Leader 节点出现故障时，会通过选举机制选出新的 Leader 节点
- 使用场景
  - Eureka：适用于云原生架构和微服务架构，特别是对服务可用性要求较高的场景
  - ZooKeeper：适用于对数据一致性要求较高的场景，如分布式锁、配置管理等

## 抢票问题

一万张优惠券，无数人抢，保证不会抢重(两个人抢到同一张)，用户界面不会卡死，在一分钟内慢慢放出而不是瞬间被抢完，怎么实现

### 1. 数据库设计

创建一个优惠券表，包含优惠券的唯一标识、是否已被领取字段。

```sql
CREATE TABLE coupons (
    id INT AUTO_INCREMENT PRIMARY KEY,
    is_claimed BOOLEAN DEFAULT false,
    -- 其它省略
);
```

### 2. 实现分布式锁

使用 Redis 实现分布式锁，确保同一时间只有一个用户可以尝试领取某张优惠券。

```java
public String claimCoupon() {
    String lockName = "coupon_lock";
    // 加锁
    if (redisLock.acquireLock(lockName, 10)) {
        try {
            List<Map<String, Object>> result = jdbcTemplate.queryForList("SELECT id FROM coupons WHERE is_claimed = false LIMIT 1 FOR UPDATE");
            if (!result.isEmpty()) {
                int couponId = (int) result.get(0).get("id");
                jdbcTemplate.update("UPDATE coupons SET is_claimed = true WHERE id = ?", couponId);
                return "抢到了: " + couponId;
            } else {
                return "抢完了";
            }
        } finally {
            // 解锁
            redisLock.releaseLock(lockName);
        }
    } else {
        return "请重试";
    }
}
```

### 3. 实现限流

使用 Spring Cloud Gateway 进行限流，确保在一分钟内慢慢放出优惠券。可以通过配置路由规则和限流过滤器来实现。

在 application.yml 中配置路由和限流规则，目标是在一分钟内放出一万张优惠券，即每秒大约 167 张优惠券，可据此设置令牌桶的参数

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: coupon_route
          uri: lb://coupon-service # 假设优惠券服务的服务名是 coupon-service
          predicates:
            - Path=/coupon/claim # 匹配领取优惠券的请求路径
          filters:
            - name: RequestRateLimiter # 使用令牌桶算法实现对进入网关的请求进行限流
              args:
                key-resolver: "#{@ipKeyResolver}" # 使用 IP 地址作为限流的键(也可以用用户的id)
                redis-rate-limiter.replenishRate: 167 # 每秒补充的令牌数
                redis-rate-limiter.burstCapacity: 167 # 令牌桶的最大容量
```

KeyResolver 用于确定限流的键，这里使用请求的 IP 地址作为键:

```java
@Configuration
public class KeyResolverConfig {

    /**
     * 定义一个基于 IP 地址的 KeyResolver Bean
     * KeyResolver 的作用是确定限流的键，在限流过程中，根据这个键来对不同的请求进行分组限流
     * 这里使用请求的 IP 地址作为限流的键，意味着会根据不同的 IP 地址对请求进行限流
     *
     * @return 返回一个 KeyResolver 实例
     */
    @Bean
    public KeyResolver ipKeyResolver() {
        // 创建一个 KeyResolver 实例，使用 Lambda 表达式实现 resolve 方法
        return exchange -> {
            // exchange 代表当前的请求 - 响应交换，包含了请求和响应的各种信息
            // getRequest() 方法用于获取当前请求对象
            // getRemoteAddress() 方法用于获取请求的远程地址，包含了客户端的 IP 地址和端口号
            // getAddress() 方法用于从远程地址中提取出 InetAddress 对象
            // getHostAddress() 方法用于从 InetAddress 对象中获取客户端的 IP 地址
            String ipAddress = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
            // Mono 是 Reactor 库中的一个响应式类型，用于表示包含 0 或 1 个元素的异步序列
            // Mono.just() 方法用于创建一个包含单个元素的 Mono 实例
            // 这里将获取到的 IP 地址封装到 Mono 中并返回，以便在响应式编程模型中进行处理
            return Mono.just(ipAddress);
        };
    }
}
```
