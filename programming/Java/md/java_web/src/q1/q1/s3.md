# 多线程

## 创建线程的常用方式

1. 继承 Thread 类
2. 实现 Runnable 接口
3. 实现 Callable 接口 + FutureTask
4. 线程池方式创建

实现 Runnable 接口与实现 Callable 接口的方式类似，只是 Callable 接口里定义的方法可以返回值，可以抛出异常。

```java
public class MyThread implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName());
        return "Hello, World!";
    }
}

public static void main(String[] args) {
    FutureTask<String> futureTask = new FutureTask<>(new MyThread());
    Thread t1 = new Thread(futureTask);
    t1.start();
    try {
        // 阻塞等待线程执行完毕, 并获取返回值
        System.out.println(futureTask.get());
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
}
```

## 如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止
2. 使用 stop 方法强行终止，但是不推荐这个方法，因为 stop 和 suspend 及 resume 一样都是过期作废的方法
3. 使用 interrupt 方法中断线程

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        while (true) {
            // 中断标志位
            boolean interrupted = Thread.currentThread().isInterrupted();
            // 判断中断标志位, 如果为true, 则退出循环
            if (interrupted) break;
            System.out.println("Thread is running");
        }
    });

    t1.start();
    Thread.sleep(1000);
    // 中断线程, 实际上是设置线程的中断标志位, 并不会真正中断线程
    // 如果中断正在阻塞的线程, 会唤醒线程, 并在线程中抛出InterruptedException异常
    t1.interrupt();
}
```

## notify 和 notifyAll 有什么区别

- 唤醒线程的数量
  - notify()：该方法会随机唤醒在此对象监视器（锁）上等待的一个线程。也就是说，如果有多个线程在同一个对象上调用了 wait() 方法进入等待状态，notify() 只会选择其中一个线程将其唤醒，而其他线程仍然处于等待状态
  - notifyAll()：该方法会唤醒在此对象监视器上等待的所有线程。所有因调用 wait() 方法而处于等待状态的线程都会被唤醒，这些线程会竞争该对象的锁，获得锁的线程将继续执行，未获得锁的线程将进入阻塞状态，等待锁的释放
- 使用场景
  - notify()：当只有一个等待线程需要被唤醒，并且多个等待线程执行的任务是等价的，使用 notify() 可以避免不必要地唤醒多个线程，减少上下文切换的开销
  - notifyAll()：当多个等待线程需要同时响应某个条件的变化，或者不确定哪个线程应该被唤醒时，使用 notifyAll() 可以确保所有相关线程都有机会继续执行。例如，生产者 - 消费者模型

## sleep 和 wait 有什么区别

- 所属类不同
  - sleep() 是 Thread 类的静态方法, 可以在任何地方使用，不依赖于对象的实例
  - wait() 是 Object 类的实例方法, 需要在同步代码块或同步方法中使用, 它必须通过对象实例来调用
- 对锁的处理不同
  - sleep() 方法在调用时，线程会暂时让出 CPU 资源，但不会释放持有的对象锁
  - wait() 方法在调用时，线程会释放持有的对象锁，使得其他线程可以获得该锁并进入同步代码块或同步方法
- 使用场景不同
  - sleep() 主要用于让线程暂停执行一段时间，通常用于模拟耗时操作、控制线程的执行速度等
  - wait() 主要用于线程间的协作和通信，当一个线程需要等待某个条件满足时，可以调用 wait() 方法进入等待状态，直到其他线程调用 notify() 或 notifyAll() 方法唤醒它

## volatile 是什么

volatile 关键字的主要作用是确保变量的可见性。在多线程环境下，每个线程都有自己的工作内存，变量的值会被缓存在线程的工作内存中。当多个线程同时访问和修改同一个共享变量时，可能会出现一个线程修改了变量的值，但其他线程没有及时看到最新值的情况，这就是可见性问题。

使用 volatile 修饰的变量，会保证该变量在多个线程之间的可见性。当一个线程修改了 volatile 变量的值，会立即将修改后的值刷新到主内存中；而其他线程在读取该变量时，会直接从主内存中读取最新的值，而不是使用自己工作内存中的缓存值。

## volatile 可以保证有序性吗

部分保证有序性

volatile 关键字可以保证一定程度的有序性，具体是通过禁止指令重排序来实现的。

在 Java 中，为了提高程序的执行效率，编译器和处理器可能会对指令进行重排序。指令重排序虽然不会影响单线程程序的执行结果，但在多线程环境下可能会导致程序出现错误。

volatile 关键字会在变量的写操作和读操作前后插入内存屏障，从而限制指令重排序的范围。具体来说：

- 写操作：在对 volatile 变量进行写操作之前的所有普通写操作，不会被重排序到该 volatile 写操作之后；在 volatile 写操作之后插入一个释放屏障，确保该写操作对其他线程可见
- 读操作：在对 volatile 变量进行读操作之后的所有普通读操作，不会被重排序到该 volatile 读操作之前；在 volatile 读操作之前插入一个获取屏障，确保能读取到其他线程对该 volatile 变量的最新写操作结果

## Thread 类中的 start() 和 run() 方法有什么区别

start()方法被用来启动新创建的线程，而且 start()内部调用了 run()方法，这和直接调用 run()方法的效果不一样。当手动调用 run()方法的时候，还是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

## Java 中 synchronized 和 ReentrantLock 有什么不同？

- Synchronized 是 Java 语言的关键字，是原生语法层面的互斥锁，需要 jvm 实现。而 ReentrantLock 它是 JDK 1.5 之后提供的 API 层面的互斥锁，需要 lock()和 unlock()方法配合 try/finally 语句块来完成
- Synchronized 编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令。在执行 monitorenter 指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加 1，相应的，在执行 monitorexit 指令时会将锁计算器就减 1，当计算器为 0 时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止
- 由于 ReentrantLock 是 java.util.concurrent 包下提供的一套互斥锁，相比 Synchronized，ReentrantLock 类提供了一些高级功能，主要有以下 3 项：
  1. 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，可以避免出现死锁的情况
  2. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized 锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数 true 设为公平锁，但公平锁表现的性能不是很好
  3. 锁绑定多个条件，一个 ReentrantLock 对象可以同时绑定对个对象

## 保证线程的执行顺序

使用 join 方法

```java
public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        System.out.println("1");
    });
    Thread t2 = new Thread(() -> {
        try {
            // join 方法会阻塞当前线程, 直到t1线程执行完毕
            t1.join();
        } catch (InterruptedException ignored) {
        }
        System.out.println("2");
    });
    Thread t3 = new Thread(() -> {
        try {
            // join 方法会阻塞当前线程, 直到t2线程执行完毕
            t2.join();
        } catch (InterruptedException ignored) {
        }
        System.out.println("3");
    });

    t1.start();
    t2.start();
    t3.start();
}
```

## Collections.synchronizedMap() 和 ConcurrentHashMap 有什么区别

- Collections.synchronizedMap() 是一个包装器方法，它返回一个 SynchronizedMap 对象。SynchronizedMap 通过在每个方法上加 synchronized 关键字来实现线程安全。也就是说，它使用的是全局锁，同一时间只允许一个线程访问 Map 的任何方法
- ConcurrentHashMap
  - 在 Java 7 及以前，ConcurrentHashMap 使用分段锁（Segment）机制。它将整个 Map 分成多个段（Segment），每个段相当于一个小的 HashMap，并且每个段都有自己独立的锁。不同的线程可以同时访问不同的段，从而提高并发性能
  - 从 Java 8 开始，ConcurrentHashMap 摒弃了分段锁机制，采用 CAS 和 synchronized 来实现并发控制。它使用数组 + 链表 + 红黑树的数据结构，在操作时，首先通过 CAS 操作尝试更新数据，如果失败则使用 synchronized 对节点加锁，这样可以进一步减少锁的粒度

## Thread 类中的 yield 方法有什么作用

yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield()的线程有可能在进入到暂停状态后马上又被执行。

## 线程池中 submit 和 execute 方法有什么区别

两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在 Executor 接口中, 而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。

## 常用的线程池有哪些

- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
- newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小
- newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求
