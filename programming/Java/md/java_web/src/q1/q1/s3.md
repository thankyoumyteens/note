# 多线程

## 创建线程的常用方式

1. 继承 Thread 类
2. 实现 Runnable 接口
3. 实现 Callable 接口 + FutureTask
4. 线程池方式创建

Callable 接口类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到。所以 Callable 用于产生结果，Future 用于获取结果。

## 如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止
2. 使用 stop 方法强行终止，但是不推荐这个方法，因为 stop 和 suspend 及 resume 一样都是过期作废的方法
3. 使用 interrupt 方法中断线程

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        while (true) {
            // 中断标志位
            boolean interrupted = Thread.currentThread().isInterrupted();
            // 判断中断标志位, 如果为true, 则退出循环
            if (interrupted) break;
            System.out.println("Thread is running");
        }
    });

    t1.start();
    Thread.sleep(1000);
    // 中断线程, 实际上是设置线程的中断标志位, 并不会真正中断线程
    // 如果中断正在阻塞的线程, 会唤醒线程, 并在线程中抛出InterruptedException异常
    t1.interrupt();
}
```

## notify 和 notifyAll 有什么区别

- 唤醒线程的数量
  - notify()：该方法会随机唤醒在此对象监视器（锁）上等待的一个线程。也就是说，如果有多个线程在同一个对象上调用了 wait() 方法进入等待状态，notify() 只会选择其中一个线程将其唤醒，而其他线程仍然处于等待状态
  - notifyAll()：该方法会唤醒在此对象监视器上等待的所有线程。所有因调用 wait() 方法而处于等待状态的线程都会被唤醒，这些线程会竞争该对象的锁，获得锁的线程将继续执行，未获得锁的线程将进入阻塞状态，等待锁的释放
- 使用场景
  - notify()：当只有一个等待线程需要被唤醒，并且多个等待线程执行的任务是等价的，使用 notify() 可以避免不必要地唤醒多个线程，减少上下文切换的开销
  - notifyAll()：当多个等待线程需要同时响应某个条件的变化，或者不确定哪个线程应该被唤醒时，使用 notifyAll() 可以确保所有相关线程都有机会继续执行。例如，生产者 - 消费者模型

## sleep 和 wait 有什么区别

- 所属类不同
  - sleep() 是 Thread 类的静态方法, 可以在任何地方使用，不依赖于对象的实例
  - wait() 是 Object 类的实例方法, 需要在同步代码块或同步方法中使用, 它必须通过对象实例来调用
- 对锁的处理不同
  - sleep() 方法在调用时，线程会暂时让出 CPU 资源，但不会释放持有的对象锁
  - wait() 方法在调用时，线程会释放持有的对象锁，使得其他线程可以获得该锁并进入同步代码块或同步方法
- 使用场景不同
  - sleep() 主要用于让线程暂停执行一段时间，通常用于模拟耗时操作、控制线程的执行速度等
  - wait() 主要用于线程间的协作和通信，当一个线程需要等待某个条件满足时，可以调用 wait() 方法进入等待状态，直到其他线程调用 notify() 或 notifyAll() 方法唤醒它

## volatile 是什么

volatile 关键字的主要作用是确保变量的可见性。在多线程环境下，每个线程都有自己的工作内存，变量的值会被缓存在线程的工作内存中。当多个线程同时访问和修改同一个共享变量时，可能会出现一个线程修改了变量的值，但其他线程没有及时看到最新值的情况，这就是可见性问题。

使用 volatile 修饰的变量，会保证该变量在多个线程之间的可见性。当一个线程修改了 volatile 变量的值，会立即将修改后的值刷新到主内存中；而其他线程在读取该变量时，会直接从主内存中读取最新的值，而不是使用自己工作内存中的缓存值。

## volatile 可以保证有序性吗

部分保证有序性

volatile 关键字可以保证一定程度的有序性，具体是通过禁止指令重排序来实现的。

在 Java 中，为了提高程序的执行效率，编译器和处理器可能会对指令进行重排序。指令重排序虽然不会影响单线程程序的执行结果，但在多线程环境下可能会导致程序出现错误。

volatile 关键字会在变量的写操作和读操作前后插入内存屏障，从而限制指令重排序的范围。具体来说：

- 写操作：在对 volatile 变量进行写操作之前的所有普通写操作，不会被重排序到该 volatile 写操作之后；在 volatile 写操作之后插入一个释放屏障，确保该写操作对其他线程可见
- 读操作：在对 volatile 变量进行读操作之后的所有普通读操作，不会被重排序到该 volatile 读操作之前；在 volatile 读操作之前插入一个获取屏障，确保能读取到其他线程对该 volatile 变量的最新写操作结果

## Thread 类中的 start() 和 run() 方法有什么区别

start()方法被用来启动新创建的线程，而且 start()内部调用了 run()方法，这和直接调用 run()方法的效果不一样。当手动调用 run()方法的时候，还是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

## Java 中 synchronized 和 ReentrantLock 有什么不同？

- Synchronized 是 Java 语言的关键字，是原生语法层面的互斥锁，需要 jvm 实现。而 ReentrantLock 它是 JDK 1.5 之后提供的 API 层面的互斥锁，需要 lock()和 unlock()方法配合 try/finally 语句块来完成
- Synchronized 编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令。在执行 monitorenter 指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加 1，相应的，在执行 monitorexit 指令时会将锁计算器就减 1，当计算器为 0 时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止
- 由于 ReentrantLock 是 java.util.concurrent 包下提供的一套互斥锁，相比 Synchronized，ReentrantLock 类提供了一些高级功能，主要有以下 3 项：
  1. 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，可以避免出现死锁的情况
  2. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized 锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数 true 设为公平锁，但公平锁表现的性能不是很好
  3. 锁绑定多个条件，一个 ReentrantLock 对象可以同时绑定对个对象

## 保证线程的执行顺序

使用 join 方法

```java
public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        System.out.println("1");
    });
    Thread t2 = new Thread(() -> {
        try {
            // join 方法会阻塞当前线程, 直到t1线程执行完毕
            t1.join();
        } catch (InterruptedException ignored) {
        }
        System.out.println("2");
    });
    Thread t3 = new Thread(() -> {
        try {
            // join 方法会阻塞当前线程, 直到t2线程执行完毕
            t2.join();
        } catch (InterruptedException ignored) {
        }
        System.out.println("3");
    });

    t1.start();
    t2.start();
    t3.start();
}
```

## Collections.synchronizedMap() 和 ConcurrentHashMap 有什么区别

- Collections.synchronizedMap() 是一个包装器方法，它返回一个 SynchronizedMap 对象。SynchronizedMap 通过在每个方法上加 synchronized 关键字来实现线程安全。也就是说，它使用的是全局锁，同一时间只允许一个线程访问 Map 的任何方法
- ConcurrentHashMap
  - 在 Java 7 及以前，ConcurrentHashMap 使用分段锁（Segment）机制。它将整个 Map 分成多个段（Segment），每个段相当于一个小的 HashMap，并且每个段都有自己独立的锁。不同的线程可以同时访问不同的段，从而提高并发性能
  - 从 Java 8 开始，ConcurrentHashMap 摒弃了分段锁机制，采用 CAS 和 synchronized 来实现并发控制。它使用数组 + 链表 + 红黑树的数据结构，在操作时，首先通过 CAS 操作尝试更新数据，如果失败则使用 synchronized 对节点加锁，这样可以进一步减少锁的粒度

## Thread 类中的 yield 方法有什么作用

yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield()的线程有可能在进入到暂停状态后马上又被执行。

## 线程池中 submit 和 execute 方法有什么区别

两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在 Executor 接口中, 而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。

## 常用的线程池有哪些

- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
- newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小
- newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求

## 对线程池的好处

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

## 锁的优化机制

从 JDK1.6 版本之后，synchronized 本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。

锁的状态从低到高依次为 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁，升级的过程就是从低到高，降级在一定条件也是有可能发生的。

- 自旋锁：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining 来开启，自旋的默认次数是 10 次，可以使用-XX:PreBlockSpin 设置
- 自适应锁：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定
- 锁消除：锁消除指的是 JVM 检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除
- 锁粗化：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外

## 锁升级的过程

Java 的锁升级过程是一个逐步演进的过程，根据不同的并发场景自动调整锁的状态，以达到性能的最优。无锁状态适用于没有锁竞争的情况；偏向锁适用于单线程多次访问同步块的场景；轻量级锁适用于多个线程交替访问同步块的场景；重量级锁则适用于多个线程同时竞争锁的场景。

1. 无锁状态: 对象刚被创建时，还没有任何线程来竞争该对象的锁，此时对象处于无锁状态。在对象头的 Mark Word 中，锁标志位为 01，偏向锁标志位为 0
2. 偏向锁状态: 偏向锁是为了在没有多线程竞争的情况下尽量减少锁带来的性能开销。当一个线程第一次访问同步块并获取锁时，会在对象头的 Mark Word 中记录该线程的 ID，这个过程是通过 CAS 操作实现的。之后该线程再次进入这个同步块时，无需进行任何同步操作，直接获取锁，这样可以避免频繁的锁竞争和同步带来的性能损耗。Mark Word 中存储线程 ID，锁标志位为 01，偏向锁标志位为 1
3. 轻量级锁状态: 当有另一个线程尝试访问这个加了偏向锁的同步块时，偏向锁就会失效，进入锁升级流程。偏向锁的撤销需要在全局安全点（所有线程都暂停执行）下进行，如果持有偏向锁的线程已经退出同步块，即不再使用该锁，那么将对象恢复到无锁状态。如果持有偏向锁的线程仍然在同步块中执行，JVM 会将偏向锁升级为轻量级锁。轻量级锁适用于多个线程交替访问同步块的场景。当线程进入同步块时，线程会在自己的栈帧中创建一个锁记录（Lock Record），并通过 CAS 操作将对象头的 Mark Word 复制到锁记录中，同时将对象头的 Mark Word 指向锁记录的地址。如果 CAS 操作成功，线程就获取了轻量级锁；如果失败，表示有其他线程已经获取了该锁，当前线程会尝试自旋等待锁的释放。Mark Word 中存储指向线程栈中锁记录的指针，锁标志位为 00
4. 重量级锁状态: 如果自旋次数达到一定阈值（不同 JVM 实现可能不同），或者有多个线程同时竞争该锁，轻量级锁就会升级为重量级锁。重量级锁是通过操作系统的互斥量（Mutex）来实现的，当多个线程同时竞争同一个锁时，竞争失败的线程会被阻塞，进入等待队列，直到持有锁的线程释放锁后，操作系统会唤醒等待队列中的线程继续竞争锁。由于涉及到用户态和内核态的切换，重量级锁的开销比较大。Mark Word 中存储指向重量级锁（Monitor）的指针，锁标志位为 10

## 进程和线程的区别

1. 进程是系统进行资源分配和调度的一个独立单位
2. 一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）
3. 线程上下文的切换比进程上下文切换要快很多:
   - 进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置
   - 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作

## 产生死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。比如有三个进程 P1、P2、P3，它们分别持有资源 R1、R2、R3。此时，P1 请求 R2，P2 请求 R3，P3 请求 R1，形成了一个循环等待的局面，即 P1 等待 P2 释放 R2，P2 等待 P3 释放 R3，P3 等待 P1 释放 R1

## 如何避免死锁

- 如果把只能互斥使用的资源改造为允许共享使用, 则系统不会进入死锁状态
- 可以采用静态分配方法, 即进程在运行前一次性申请完它所需要的全部资源, 在它的资源未满足前, 不让它投入运行。一旦投入运行后, 这些资源就一直归它所有, 该进程就不会再请求别的任何资源了
- 当某个进程需要的资源被其他进程所占有的时候, 可以由操作系统协助, 将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级
- 可采用顺序资源分配法。首先给系统中的资源编号, 规定每个进程必须按编号递增的顺序请求资源, 同类资源一次申请完。一个进程只有已占有小编号的资源时, 才有资格申请更大编号的资源。按此规则, 已持有大编号资源的进程不可能逆向地回来申请小编号的资源, 从而就不会产生循环等待的现象

## 线程池有几个核心的参数

1. 最大线程数 maximumPoolSize
2. 核心线程数 corePoolSize
3. 活跃时间 keepAliveTime
4. 阻塞队列 workQueue
5. 拒绝策略 RejectedExecutionHandler

当提交一个新任务到线程池时，具体的执行流程如下：

1. 当我们提交任务，线程池会根据 corePoolSize 大小创建若干任务数量线程执行任务
2. 当任务的数量超过 corePoolSize 数量，后续的任务将会进入阻塞队列阻塞排队
3. 当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize 额外创建的线程等待 keepAliveTime 之后被自动销毁
4. 如果达到 maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理

## 线程池核心线程数怎么设置

分为 CPU 密集型和 IO 密集型

- CPU 密集型: 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 CPU 核心数+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间
- IO 密集型: 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是：核心线程数=CPU 核心数\*2

## 线程池中常用的队列

- ArrayBlockingQueue 是一个基于数组结构的有界阻塞队列，此队列按先入先出原则对元素进行排序。
- LinkedBlockingQueue 一个基于链表结构的阻塞队列，此队列按先入先出排序元素，吞吐量通常要高于 ArrayBlockingQueue
- SynchronousQueue 一个不存储元素的阻塞队列
- PriorityBlockingQueue 一个具有优先级的无限阻塞队列
- DelayQueue 只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列

## 线程池的拒绝策略有哪些

1. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
2. CallerRunsPolicy：只用调用者所在的线程来处理任务
3. DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务，也不抛出异常

## 线程之间是如何通信的

线程之间的通信有两种方式：共享内存和消息传递。

- 共享内存: 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。
- 消息传递: 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。比如 BlockingQueue, 当队列满时，生产者线程会被阻塞，直到队列有空间；当队列空时，消费者线程会被阻塞，直到队列中有元素

## CAS

CAS 叫做 CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：

1. 变量内存地址 V
2. 旧值 A
3. 准备设置的新值 B

当执行 CAS 指令时，只有当 V 等于 A 时，才会用 B 去更新 V 的值，否则就不会执行更新操作。

## CAS 的缺点

- ABA 问题：ABA 的问题指的是在 CAS 更新的过程中，当读取到的值是 A，然后准备赋值的时候仍然是 A，但是实际上有可能 A 的值被改成了 B，然后又被改回了 A。只是 ABA 的问题大部分场景下都不影响并发的最终效果。
- 循环时间长开销大：自旋 CAS 的方式如果长时间不成功，会给 CPU 带来很大的开销。
- 只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以使用锁 synchronized 实现

## ThreadLocal 原理

ThreadLocal 是 Java 中的一个类，它为每个使用该变量的线程都提供一个独立的变量副本，每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。

Thread 类中有一个类型为 ThreadLocal.ThreadLocalMap 的成员变量 threadLocals，它用于存储当前线程的所有 ThreadLocal 变量及其对应的值。

ThreadLocal 有一个静态内部类 ThreadLocalMap，ThreadLocalMap 又包含了一个 Entry 数组，Entry 的 key 是指向 ThreadLocal 的弱引用。

弱引用的目的是为了防止内存泄露，如果是强引用那么 ThreadLocal 对象除非线程结束否则始终无法被回收，弱引用则会在下一次 GC 的时候被回收。

但是这样还是会存在内存泄露的问题，假如 key 指向的 ThreadLocal 对象被回收之后，entry 中就存在 key 为 null，但是 value 有值的 entry 对象，但是永远没办法被访问到。

但是只要 ThreadLocal 使用恰当，在使用完之后调用 remove 方法删除 Entry 对象，实际上是不会出现这个问题的。

## JMM

Java 内存模型(JMM)定义了 Java 程序中多线程并发访问共享内存的规范。共享内存是指多个线程可以同时访问和修改的内存区域。

Java 内存模型的主要目的是定义程序中各种变量的访问规则。此处的变量包括了实例字段、静态字段和构成数组对象的元素, 但是不包括局部变量与方法参数, 因为后者是线程私有的, 不存在竞争问题。

Java 内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存, 线程的工作内存中保存了被该线程使用的变量的主内存副本, 线程对变量的所有操作都必须在工作内存中进行, 而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要通过主内存来完成。

主内存直接对应于物理硬件的内存, 而为了获取更好的运行速度, 虚拟机一般会让工作内存优先存储于寄存器和高速缓存中, 因为程序运行时主要访问的是工作内存。

## CyclicBarrier 和 CountDownLatch 的区别

- 功能特点
  - CyclicBarrier：允许一组线程互相等待，直到到达某个公共屏障点（barrier point）。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且 CyclicBarrier 可以被重置后再次使用，所以它是可循环利用的
  - CountDownLatch：主要用于让一个或多个线程等待其他一组线程完成特定操作后再继续执行。它通过计数器来实现，计数器初始化为指定的值，每调用一次 countDown 方法，计数器减 1，当计数器减到 0 时，等待的线程就可以继续执行，CountDownLatch 不能被重置，是一次性的
- 应用场景
  - CyclicBarrier：适用于需要多线程反复协作，在某个阶段达到同步的场景。例如，在并行计算中，多个线程分别处理不同的数据块，当所有线程都完成各自的数据块处理后，需要进行数据合并或汇总操作，然后再进行下一轮的计算，就可以使用 CyclicBarrier 来实现线程之间的同步
  - CountDownLatch：常用于控制线程的启动顺序或等待一组线程完成任务后再进行下一步操作的场景。比如，在一个应用程序启动时，可能需要加载多个资源，如数据库连接、配置文件等，这些资源的加载可以由多个线程并行进行，主线程可以使用 CountDownLatch 来等待所有资源加载线程完成任务后，再继续执行应用程序的初始化后续操作
- 内部实现机制
  - CyclicBarrier：内部使用了 ReentrantLock 和 Condition 来实现线程的等待和唤醒。它通过一个计数器记录到达屏障点的线程数量，当线程调用 await 方法时，会将计数器减 1，然后判断计数器是否为 0，如果不为 0，则线程进入等待状态，直到所有线程都调用了 await 方法，计数器变为 0，此时所有线程被唤醒，继续执行后续操作
  - CountDownLatch：内部基于 AQS 来实现。通过 AQS 的状态变量来表示计数器的值，线程调用 countDown 方法时，会将状态变量减 1，当状态变量为 0 时，会唤醒所有在等待队列中的线程

## 什么是 AQS

AbstractQueuedSynchronizer（AQS）是 Java 并发包中的一个核心基础框架，很多同步工具类都是基于它来实现的，如 ReentrantLock、CountDownLatch、Semaphore 等。

AQS 是一个抽象类，它提供了一种基于 FIFO 队列来实现阻塞锁和相关同步器的框架。其核心思想是通过一个整数状态变量（state）来表示同步状态，并且提供了一系列方法来对这个状态进行操作和管理，从而实现不同的同步功能。

同步状态（state）：是 AQS 的核心属性，用于表示资源的同步状态。比如，在独占锁的场景下，state 为 0 表示锁未被占用，为 1 表示锁已被占用；在共享锁的场景下，state 可以表示有多少个线程可以同时获取资源。

工作原理:

- 当一个线程尝试获取资源时，首先会调用 AQS 的获取资源方法，如 acquire 或 acquireShared。这些方法会先调用子类实现的 tryAcquire 或 tryAcquireShared 方法来尝试获取资源。如果获取成功，则线程可以继续执行；如果获取失败，线程会被封装成一个节点加入到 CLH 等待队列(一个双向链表实现的等待队列)中
- 当持有资源的线程释放资源时，会调用 release 或 releaseShared 方法，这些方法会先调用子类实现的 tryRelease 或 tryReleaseShared 方法来尝试释放资源。如果释放成功，会根据节点的状态和队列的情况唤醒等待队列中的后继线程，被唤醒的线程会再次尝试获取资源

## 什么是 Semaphore

Semaphore 是一个信号量，它维护了一个许可集。线程在访问资源之前，需要从 Semaphore 获取许可，如果有可用许可，线程获取许可后可以继续执行；如果没有可用许可，线程则会被阻塞，直到有其他线程释放许可。

工作原理:

- Semaphore 内部通过 AQS 来管理许可的获取和释放。它将 AQS 的 state 变量用于表示可用许可的数量
- 当线程调用 acquire 方法时，会尝试通过 CAS 操作将 state 的值减 1，表示获取一个许可。如果 state 的值小于 0，说明没有可用许可，线程会被封装成一个节点加入到 AQS 的等待队列中，进入阻塞状态
- 当线程调用 release 方法时，会通过 CAS 操作将 state 的值加 1，表示释放一个许可。然后会检查等待队列中是否有线程在等待许可，如果有，则唤醒一个等待的线程，让其有机会获取许可继续执行

## 什么是阻塞队列

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。

阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。

JDK7 提供了 7 个阻塞队列。分别是：

- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列
- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列
- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列
- DelayQueue：一个使用优先级队列实现的无界阻塞队列
- SynchronousQueue：一个不存储元素的阻塞队列
- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列

## 什么是 Daemon 线程 它有什么意义

所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说， 只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用 setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行 finally 子句的情况下就会终止其 run()方法。

比如：JVM 的垃圾回收线程就是 Daemon 线程，Finalizer 也是守护线程。

## 乐观锁和悲观锁的理解及如何实现

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁的实现方式：

1. 使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略
2. java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数: 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作
