# 基础

## 自动装箱与拆箱

装箱就是自动将基本数据类型转换为包装器类型（int -> Integer）。调用方法：Integer 的 valueOf(int) 方法
拆箱就是自动将包装器类型转换为基本数据类型（Integer -> int）。调用方法：Integer 的 intValue 方法

以下代码会输出什么？

```java
public static void main(String[] args) {

    Integer i1 = 100;
    Integer i2 = 100;
    Integer i3 = 200;
    Integer i4 = 200;

    System.out.println(i1 == i2);
    System.out.println(i3 == i4);
}
```

运行结果：

```
true
false
```

原因

`Integer i1 = 100;` 会自动装箱, 调用 valueOf 方法, valueOf 如下:

```java
public static Integer valueOf(int i) {
    // low = -128
    // high = 127
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

可以看出，在通过 valueOf 方法创建 Integer 对象的时候，如果数值在 `[-128,127]` 之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。

上面的代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。

## 重载和重写的区别

重写 Override

1. 发生在父类与子类之间
2. 方法名，参数列表，返回类型必须相同(子类中方法的返回类型可以是父类中返回类型的子类)
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符(public>protected>default>private)
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

重载 Overload

1. 重载是一个类中多态性的一种表现
2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准

## equals 与 == 的区别

- == 比较的是两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。对象比较的是地址，如果是原始类型，值相等则为 true
- equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的是 == 的判断

总结：所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的
equals object 可能为 null 则空指针

## hashCode() 的作用

hashCode 方法返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，再调用它的 equals 方法与新元素进行比较。这样一来实际调用 equals 方法的次数就大大降低了。

## String、String StringBuffer 和 StringBuilder 的区别

- String 是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个 final 类型的 char 数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对 String 的操作都会生成新的 String 对象
- StringBuffer 和 StringBuilder 的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和 StringBuilder 来进行操作
- StringBuffer 对方法加了同步锁，所以是线程安全的
- StringBuilder 并没有对方法加同步锁，所以是非线程安全的

## ArrayList 和 linkedList 的区别

- ArrayList 可以看作是能够自动增长容量的数组。数组根据下标访问数据很快, 但是在数组中间插入数据/删除数据却开销很大，因为插入/删除数据以后, 需要把后面所有的数据前移
- LinkList 是一个双向链表, 在添加和删除元素时具有比 ArrayList 更好的性能。但在 get 与 set 方面弱于 ArrayList

## HashMap 和 HashTable 的区别

- 对 null 的支持不同
  - HashTable 和 value 都不能为 null
  - HashMap：key 可以为 null，但是这样的 key 只能有一个，因为必须保证 key 的唯一性。可以有多个 key 值对应的 value 为 null
- 线程安全性不同
  - HashTable 是线程安全的，它的每个方法上都有 synchronized 关键字
  - HashMap 是线程不安全的, 但是它的效率远远高于 HashTable
- 初始容量不同
  - HashTable 的初始长度是 11
  - HashMap 的初始长度为 16
- 扩容大小不同
  - HashTable 每次扩充容量变为之前的 2n+1(n 为上一次的长度)
  - HashMap 每次扩充变为原来的两倍

在需要线程安全的情况下还要考虑性能, 应该使用 ConcurrentHashMap

## HashMap 与 ConcurrentHashMap 的区别

- HashMap 是线程不安全的，ConcurrentHashMap 是线程安全的
- HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表/红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快
- ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁(Segment + HashEntry)来现实的。JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现

## 红黑树的特性

- 每个节点不是是黑色, 就是红色
- 根节点一定是黑色
- 红色节点只能是左侧的子节点
- 红色节点是表示和父节点融合在一起的
- 红色节点的子节点一定是黑色
- 添加节点时, 永远添加红色节点
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点

## 3\*0.1 == 0.3 的返回值是什么

false, 因为有些浮点数不能完全精确的表示出来

## a=a+b 与 a+=b 有什么区别

`+=` 操作符会自动进行类型转换。

比如下面, 当执行 b += a; 时，a 和 b 在进行加法运算时会先被提升为 int 类型（因为 Java 在进行算术运算时，byte、short 和 char 类型会自动提升为 int 类型以保证计算精度）。然后 `+=` 会自动将计算结果强制转换回变量 b 的类型 byte:

```java
byte a = 127;
byte b = 127;

// b = -2
b += a;
```

`+` 则不会自动进行类型转换。

比如下面, a 和 b 在进行加法运算时也会先被提升为 int 类型, 但计算完的 int 类型不经过类型转换无法赋值给 byte 类型变量:

```java
byte a = 127;
byte b = 127;

// 编译报错: 不兼容的类型: 从int转换到byte可能会有损失
b = a + b;
```

## try 里有 return，finally 还执行么

执行，java 会先把要返回的值暂存起来, 等 finally 执行完再返回。

## 创建对象有几种方式

- 使用 new 关键字
- 使用反射方式创建对象
- 使用 clone 方法
- 使用反序列化创建对象，调用 ObjectInputStream 类的 readObject() 方法

## 获取 Class 对象的方式

- 通过类对象的 getClass() 方法获取
- 通过类的静态成员 class 获取
- 通过 Class 类的静态方法 forName() 方法获取

## 什么是 fail-fast

fail-fast 机制是 Java 集合中的一种错误机制。当多个线程对同一个集合的内容进行操作(add、remove 和 clear)时，就可能会产生 fail-fast 事件。

例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事
件。

解决办法：使用 java.util.concurrent 包下的类去取代 java.util 包下的类
