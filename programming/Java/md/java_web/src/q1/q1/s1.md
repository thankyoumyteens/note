# 基础

## 自动装箱与拆箱

装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer 的 valueOf(int) 方法
拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer 的 intValue 方法

以下代码会输出什么？

```java
public static void main(String[] args) {

    Integer i1 = 100;
    Integer i2 = 100;
    Integer i3 = 200;
    Integer i4 = 200;

    System.out.println(i1 == i2);
    System.out.println(i3 == i4);
}
```

运行结果：

```
true
false
```

原因

`Integer i1 = 100;` 会自动装箱, 调用 valueOf 方法, valueOf 如下:

```java
public static Integer valueOf(int i) {
    // low = -128
    // high = 127
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

可以看出，在通过 valueOf 方法创建 Integer 对象的时候，如果数值在 `[-128,127]` 之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。

上面的代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。

## 重载和重写的区别

重写 Override

1. 发生在父类与子类之间
2. 方法名，参数列表，返回类型必须相同(子类中方法的返回类型可以是父类中返回类型的子类)
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符(public>protected>default>private)
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

重载 Overload

1. 重载是一个类中多态性的一种表现
2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准

## equals 与 == 的区别

- == 比较的是两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。对象比较的是地址，如果是原始类型，值相等则为 true
- equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的是 == 的判断

总结：所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的
equals object 可能为 null 则空指针

## hashcode() 的作用

hashCode 方法返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，再调用它的 equals 方法与新元素进行比较。这样一来实际调用 equals 方法的次数就大大降低了。
