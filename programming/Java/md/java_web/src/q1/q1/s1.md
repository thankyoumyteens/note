# 基础

## 自动装箱与拆箱

装箱就是自动将基本数据类型转换为包装器类型（int -> Integer）。调用方法：Integer 的 valueOf(int) 方法
拆箱就是自动将包装器类型转换为基本数据类型（Integer -> int）。调用方法：Integer 的 intValue 方法

以下代码会输出什么？

```java
public static void main(String[] args) {

    Integer i1 = 100;
    Integer i2 = 100;
    Integer i3 = 200;
    Integer i4 = 200;

    System.out.println(i1 == i2);
    System.out.println(i3 == i4);
}
```

运行结果：

```
true
false
```

原因

`Integer i1 = 100;` 会自动装箱, 调用 valueOf 方法, valueOf 如下:

```java
public static Integer valueOf(int i) {
    // low = -128
    // high = 127
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

可以看出，在通过 valueOf 方法创建 Integer 对象的时候，如果数值在 `[-128,127]` 之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。

上面的代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。

## hashCode() 的作用

hashCode 方法返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，再调用它的 equals 方法与新元素进行比较。这样一来实际调用 equals 方法的次数就大大降低了。

## HashMap 和 HashTable 的区别

- 对 null 的支持不同
  - HashTable 的 key 和 value 都不能为 null
  - HashMap 的 key 可以为 null，但是这样的 key 只能有一个，因为必须保证 key 的唯一性。可以有多个 key 值对应的 value 为 null
- 线程安全性不同
  - HashTable 是线程安全的，它的每个方法上都有 synchronized 关键字
  - HashMap 是线程不安全的, 但是它的效率远远高于 HashTable
- 初始容量不同
  - HashTable 的初始长度是 11
  - HashMap 的初始长度为 16
- 扩容大小不同
  - HashTable 每次扩充容量变为之前的 2n+1(n 为上一次的长度)
  - HashMap 每次扩充变为原来的两倍

在需要线程安全的情况下还要考虑性能, 应该使用 ConcurrentHashMap

## HashMap 与 ConcurrentHashMap 的区别

- HashMap 是线程不安全的，ConcurrentHashMap 是线程安全的
- HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表/红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快
- ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁(Segment + HashEntry)来现实的。JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现

## 3\*0.1 == 0.3 的返回值是什么

false, 因为有些浮点数不能完全精确的表示出来

## a=a+b 与 a+=b 有什么区别

`+=` 操作符会自动进行类型转换。

比如下面, 当执行 b += a; 时，a 和 b 在进行加法运算时会先被提升为 int 类型（因为 Java 在进行算术运算时，byte、short 和 char 类型会自动提升为 int 类型以保证计算精度）。然后 `+=` 会自动将计算结果强制转换回变量 b 的类型 byte:

```java
byte a = 127;
byte b = 127;

// b = -2
b += a;
```

`+` 则不会自动进行类型转换。

比如下面, a 和 b 在进行加法运算时也会先被提升为 int 类型, 但计算完的 int 类型不经过类型转换无法赋值给 byte 类型变量:

```java
byte a = 127;
byte b = 127;

// 编译报错: 不兼容的类型: 从int转换到byte可能会有损失
b = a + b;
```

## try 里有 return，finally 还执行么

执行，java 会先把要返回的值暂存起来, 等 finally 执行完再返回。

## 创建对象有几种方式

- 使用 new 关键字
- 使用反射方式创建对象
- 使用 clone 方法
- 使用反序列化创建对象，调用 ObjectInputStream 类的 readObject() 方法

## 获取 Class 对象的方式

- 通过类对象的 getClass() 方法获取
- 通过类的静态成员 class 获取
- 通过 Class 类的静态方法 forName() 方法获取

## java 内存泄漏的案例

- 静态集合类导致的内存泄漏: 静态集合类（如 static List、static Map 等）的生命周期和应用程序的生命周期一致，如果将对象添加到静态集合中，并且在对象不再使用时没有从集合中移除，这些对象就无法被垃圾回收，从而造成内存泄漏。解决办法: 在对象不再使用时，及时从静态集合中移除该对象
- 未关闭的资源导致的内存泄漏: 比如文件、网络连接、数据库连接等资源在使用完毕后需要手动关闭。如果没有正确关闭这些资源，它们会一直占用系统资源，导致内存泄漏。解决办法: 使用 try-with-resources 语句来自动关闭资源，或者在 finally 块中手动关闭资源
- 数据库连接池配置不合理: 数据库连接池用于管理数据库连接，提高数据库操作的性能。但如果配置不合理，如连接池的最大连接数设置过大，或者连接长时间未释放，会导致连接池中的连接对象一直占用内存，造成内存泄漏。解决办法: 合理配置数据库连接池的参数，如最大连接数、最小连接数、连接超时时间等

## 如何绕过私有构造方法，创建多个单例对象

利用反射机制, 设置可访问私有构造方法 `constructor.setAccessible(true);`

## java 保证插入顺序的集合是哪个

LinkedHashSet 是 Set 接口的实现类，它继承自 HashSet，并使用链表维护元素的插入顺序。与 HashSet 不同的是，LinkedHashSet 会保证元素的迭代顺序与插入顺序一致，同时它不允许存储重复的元素。
