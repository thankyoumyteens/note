# JVM

## Java 内存模型

Java 内存模型(JMM)定义了 Java 程序中多线程并发访问共享内存的规范。共享内存是指多个线程可以同时访问和修改的内存区域。

Java 内存模型的主要目的是定义程序中各种变量的访问规则。此处的变量包括了实例字段、静态字段和构成数组对象的元素, 但是不包括局部变量与方法参数, 因为后者是线程私有的, 不存在竞争问题。

Java 内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存, 线程的工作内存中保存了被该线程使用的变量的主内存副本, 线程对变量的所有操作都必须在工作内存中进行, 而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要通过主内存来完成。

主内存直接对应于物理硬件的内存, 而为了获取更好的运行速度, 虚拟机可能会让工作内存优先存储于寄存器和高速缓存中, 因为程序运行时主要访问的是工作内存。

## JVM 运行时数据区

- 线程私有区:
  - 程序计数器: 每个线程有一个属于自己的计数器来记录下一条要运行的指令。计数器记录正在执行的 java 字节码地址，如果执行的是 native 方法，则计数器为空
  - 虚拟机栈栈: 与线程在同一时间创建。每个方法执行时都会创建一个栈桢来存储方法的的本地变量表、操作数栈、动态链接、返回地址等信息。栈的大小决定了方法调用的深度（递归多少层，或嵌套调用多少层其他方法，-Xss 参数可以设置虚拟机栈大小）。栈的大小可以是固定的，也可以是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出 stackOverflowError。如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出 OutofMemoryError
  - 本地方法栈: 与虚拟机栈作用相似。但它不是为 Java 方法服务的，而是本地方法（C 语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同
- 线程共享区:
  - 堆: 存放对象和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的 Eden 区中，经过 GC 后进入新生代的 Survivor 区中，15 次 GC 后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则抛出 OutOfMemoryError
  - 方法区: 用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。其中运行时常量池存放编译生成的各种常量。如果虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且加载该类的 ClassLoader 被回收

## 堆和栈的区别

- 栈是运行时单位，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片
- 堆是存储单位，代表着数据，可被多个栈共享，所在区域不连续，会有碎片
- 功能不同: 栈内存用来存储局部变量和方法调用。而堆内存用来存储 Java 中的对象, 无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
- 共享性不同: 栈内存是线程私有的。堆内存是所有线程共有的
- 异常错误不同: 如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：java.lang.OutOfMemoryError
- 空间大小: 栈的空间大小远远小于堆的

## 类的加载与卸载

类的生命周期: 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

其中验证,准备,解析合称链接

- 加载: 通过类的完全限定名,查找此类字节码文件,利用字节码文件创建 Class 对象
- 验证: 确保 Class 文件符合当前虚拟机的要求,不会危害到虚拟机自身安全
- 准备: 进行内存分配,为 static 修饰的类变量分配内存,并设置初始值(0 或 null)。不包含 final 修饰的静态变量,因为 final 变量在编译时分配
- 解析: 将常量池中的符号引用替换为直接引用的过程。直接引用为直接指向目标的指针或者相对偏移量等
- 初始化: 主要完成静态代码块执行以及静态变量的赋值。先初始化父类,再初始化当前类

初始化的触发条件

- 创建类的实例时
- 访问类的静态方法或静态变量的时候
- 使用 Class.forName 反射类的时候
- 某个子类初始化的时候

Java 自带的加载器加载的类, 在虚拟机的生命周期中是不会被卸载的, 只有用户自定义的加载器加载的类才可以被卸载

## 双亲委派模型

类加载器加载类时先把请求委托给自己的父类加载器执行,直到最顶层的启动类加载器。父类加载器能够完成加载则成功返回, 不能的话子类加载器才自己尝试加载。

优点:

1. 避免类被重复加载
2. 避免 Java 的核心 API 被篡改

内置的类加载器:

- 启动类加载器：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）
- 扩展类加载器：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是启动类加载器
- 系统类加载器：又叫应用类加载器，其父类是扩展类加载器。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器

## 分代回收

分代收集理论建立在两个分代假说之上:

1. 弱分代假说: 绝大多数对象都是朝生夕灭的
2. 强分代假说: 熬过越多次垃圾回收的对象就越难以消亡

这两个分代假说共同奠定了多款常用的垃圾回收器的一致的设计原则: 垃圾回收器应该将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄(年龄即对象熬过垃圾回收的次数)分配到不同的区域之中存储。

如果一个区域中大多数对象都是朝生夕灭, 那么把它们集中放在一起, 每次回收时只关注如何保留少量存活的对象而不是去标记那些大量将要被回收的对象, 就能以较低代价回收到大量的空间。如果剩下的都是难以消亡的对象, 那把它们集中放在一块, 垃圾回收器便可以使用较低的频率来回收这个区域, 这就同时兼顾了垃圾回收的时间开销和内存的空间有效利用。

在 Java 堆划分出不同的区域(新生代、老年代)之后, 垃圾回收器才可以每次只回收其中某一个或者某些部分的区域, 也能够对不同的区域使用不同的垃圾回收算法。

## 什么时候会触发 Full GC

- 直接调用 System.gc 外
- 老年代空间不足: 老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space
- 永久代空间满: 当系统中加载了大量的类(例如在使用动态类加载、CGLIB 等字节码操作库、或者在开发大型企业应用时加载大量的第三方库等)时，永久代可能会被占满，如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space。Java 8 及以后版本没有了永久代, 取而代之, 当元空间耗尽本地内存时，就会抛出 java.lang.OutOfMemoryError: Metaspace
- CMS GC 时出现 promotion failed 和 concurrent mode failure: 对于采用 CMS 进行老年代 GC 的程序而言，当这两种状况出现时可能会触发 Full GC。promotion failed 是在进行 Minor GC 时，survivor 区放不下、对象只能放入老年代，而此时老年代也放不下造成的。concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。 应对措施为：增大 survivor 空间、老年代空间或调低触发并发 GC 的比率
- 统计得到的 Minor GC 晋升到老年代的平均大小大于老年代的剩余空间: Hotspot 为了避免由于新生代对象晋升到老年代导致老年代空间不足的现象，在进行 Minor GC 时，做了一个判断，如果之前统计所得到的 Minor GC 晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发 Full GC。例如程序第一次触发 Minor GC 后，有 6MB 的对象晋升到老年代，那么当下一次 Minor GC 发生时，首先检查老年代的剩余空间是否大于 6MB，如果小于 6MB，则执行 Full GC。 当新生代采用 PS GC 时，方式稍有不同，PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时老年代的剩余空间是否大于 6MB，如小于，则触发对老年代的回收

## 对象分配规则

- 对象优先分配在 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝(新生代采用复制算法回收内存)
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次新生代 GC 那么对象会进入 Survivor 区，之后每经过一次新生代 GC 那么对象的年龄加 1，直到达到阀值对象进入老年代
- 动态判断对象的年龄。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代

## 空间分配担保机制

在 JDK 1.6 及以前的版本中，空间分配担保机制与 HandlePromotionFailure 参数密切相关。当发生 Minor GC 时，新生代的对象可能会因为年龄达到阈值或者 Survivor 区空间不足等原因需要晋升到老年代。此时，如果老年代没有足够的连续空间来容纳这些对象，JVM 会根据 HandlePromotionFailure 参数的设置来决定处理方式：

- HandlePromotionFailure 开启：检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小。若大于，则尝试进行对象晋升；若小于，则进行一次 Full GC
- HandlePromotionFailure 关闭：直接触发一次 Full GC

从 JDK 1.7 开始，HandlePromotionFailure 参数逐渐失去原有的作用，空间分配担保机制的实现逻辑发生了改变。在进行 Minor GC 之前，JVM 不再检查 HandlePromotionFailure 标志，而是进行以下检查：

- 第一次检查：查看老年代的最大可用连续空间是否大于新生代所有对象的总大小。如果大于，说明老年代有足够的空间来容纳新生代的所有对象，那么可以放心地进行 Minor GC
- 第二次检查：如果老年代的最大可用连续空间小于新生代所有对象的总大小，JVM 会进一步检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小
  - 若大于：JVM 会认为这次晋升是有风险的，但仍然会尝试进行 Minor GC。因为虽然老年代当前可能没有足够的空间容纳新生代所有对象，但从历史晋升情况来看，还是有可能成功晋升部分对象的。如果在 Minor GC 后有对象需要晋升到老年代，但老年代空间不足，就会触发 Full GC
  - 若小于：JVM 会直接进行一次 Full GC，先清理老年代的空间，为可能的对象晋升做准备，然后再进行 Minor GC

## 对象创建过程

- JVM 遇到 new 指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类
- 为对象分配内存。具体通过哪种方式来给对象分配内存是由 JVM 使用哪个垃圾回收器来决定的
  - 指针碰撞: 如果堆中内存是绝对规整的, 所有被使用过的内存都被放在一边, 空闲的内存被放在另一边, 中间放着一个指针作为分界点的指示器, 那分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离, 这种分配方式称为指针碰撞
  - 空闲列表: 如果堆中的内存并不是规整的, 已被使用的内存和空闲的内存相互交错在一起, 那就没有办法简单地进行指针碰撞了, JVM 必须维护一个列表, 记录哪些内存块是可用的, 在分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的记录, 这种分配方式称为空闲列表
- 将除对象头外的对象内存空间初始化为 0
- 设置对象头(元数据指针、对象的哈希码、对象的 GC 分代年龄等信息)
- 一般来说, 执行完 new 指令之后会接着执行 invokespecial 指令调用`<init>()`方法

## 什么是 TLAB

堆是线程的共享区域, 任何线程都可以访问到堆中的数据, 由于对象的创建在 JVM 中非常频繁, 因此在并发环境下从堆中划分内存空间是线程不安全的。为了避免多个线程操作同一个地址, 需要使用线程同步机制(加锁等), 而同步会影响分配速度。

线程本地分配缓冲区(TLAB)是每个线程在 Eden 空间中私有的一块内存区域。开启 TLAB 时, JVM 会优先在 TLAB 中分配内存, 当对象在 TLAB 空间分配内存失败时, JVM 才会尝试通过使用同步机制直接在 Eden 空间中分配内存。

## 对象的结构

- 对象头: 由两部分组成
  - 第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁标识状态、线程持有的锁、偏向锁的线程 ID
  - 第二部分是指针，指向对象的类元数据类型（即对象属于哪个类）
  - 如果是数组对象，则对象头中还有一部分用来记录数组长度
- 实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的字段）
- 对齐填充：JVM 要求对象起始地址必须是 8 字节的整数倍（8 字节对齐）

## 如何判断对象可以被回收

- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 时可以回收。此方法简单，但存在对象之间相互循环引用的问题
- 可达性分析：从 GC Roots(根集合)开始向下搜索，搜索所走过的路径称为引用链。当一个对象到根集合没有任何引用链相连时，则证明此对象是可以回收的

## 垃圾回收算法

- 标记-清除算法: 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象
- 复制算法: 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块中，然后再把已使用过的内存空间一次性清理掉
- 标记-压缩算法: 标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

## 有哪些垃圾回收器

- Serial 回收器 (复制算法): 新生代单线程回收器，标记和清理都是单线程，优点是简单高效
- ParNew 回收器 (复制算法): 新生代收并行集器，实际上是 Serial 回收器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现
- Parallel Scavenge 回收器 (复制算法): 新生代并行回收器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互响应要求不高的场景
- Serial Old 回收器 (标记-整理算法): 老年代单线程回收器，Serial 回收器的老年代版本
- Parallel Old 回收器 (标记-整理算法)： 老年代并行回收器，吞吐量优先，Parallel Scavenge 回收器的老年代版本
- CMS 回收器 (标记-清除算法)：老年代并行回收器，以获取最短回收停顿时间为目标的回收器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间
- G1 回收器 (标记-整理算法)：Java 堆并行回收器，G1 回收器是 JDK1.7 提供的一个新回收器，G1 回收器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 回收器不同于之前的回收器的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)，而前六种回收器回收的范围仅限于新生代或老年代其中的一个
- ZGC (标记-整理算法): 是一款由 Oracle 公司研发的，以低延迟为首要目标的一款垃圾回收器。它是基于动态 Region 内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的回收器。在 JDK 11 新加入，还在实验阶段，主要特点是：回收 TB 级内存（最大 4T），停顿时间不超过 10ms

## 如何选择垃圾回收器

1. 如果你的堆大小不是很大（比如 100MB ），选择串行回收器一般是效率最高的。参数： -XX:+UseSerialGC
2. 如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行回收器依然是合适的，这时候启用一些并行回收器没有任何收益。参数： -XX:+UseSerialGC
3. 如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行回收器是比较好的。参数： -XX:+UseParallelGC
4. 如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1、ZGC、CMS 都是合理的。虽然这些回收器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。参数：
   - -XX:+UseConcMarkSweepGC
   - -XX:+UseG1GC
   - -XX:+UseZGC

从上面这些出发点来看，我们平常的 Web 服务器，都是对响应性要求非常高的。选择性其实就集中在 CMS、G1、ZGC 上。而对于某些定时任务，使用并行回收器，是一个比较好的选择。

## 常见的调优工具

- jps: 列出正在运行的 JVM 进程, 以及这些进程的唯一 ID
- jstat: 用于监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾回收、JIT 编译等运行数据
- jmap: 用于生成 heap dump 文件
- jhat: 与 jmap 搭配使用，用来分析 jmap 生成的 dump，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看
- jstack: 用于生成 java 虚拟机当前时刻的线程快照
- jinfo: 实时查看和调整虚拟机运行参数
- jconsole: 图形化界面, JDK 自带的 java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控
- jvisualvm: 图形化界面, 可以分析内存快照、线程快照；监控内存变化、GC 变化等

## 性能调优参数

- -Xms 设置堆的初始大小
- -Xmx 设置堆的最大大小
- -XX:NewSize：新生代大小
- -XX:NewRatio 新生代和老生代占比
- -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比
- -XX:+UseParallelGC 设定垃圾回收器
- -XX:+PrintGCDetails 打印 GC 详细信息

## 对象一定分配在堆中吗

不一定，JVM 通过「逃逸分析」，那些逃不出方法的对象会在栈上分配。

逃逸分析，是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，JVM 能够分析出一个对象的使用范围，从而决定是否要将这个对象分配到堆上。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。

## 逃逸分析的好处

- 栈上分配，可以降低垃圾回收器运行的频率
- 同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步锁
- 标量替换，不创建对象, 而是把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。二、程序内存回收效率高，并且 GC 频率也会减少

## 什么是 Stop The World

进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为 STW。

## 什么是 OopMap

在 HotSpot 中，有个数据结构（映射表）称为「OopMap」。一旦类加载完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，记录到 OopMap。在即时编译过程中，也会在「特定的位置」生成 OopMap，记录下栈上和寄存器里哪些位置是引用。

## 什么是安全点

HotSpot 只会在特定的位置记录 OopMap 的变化, 这些位置被称为安全点。由于垃圾回收需要借助 OopMap, 因此必须到达安全点时才可以开始垃圾回收。

一般会在如下几个位置选择安全点:

- 循环的末尾
- 方法临返回前
- 调用方法之后
- 抛异常的位置
