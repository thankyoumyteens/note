# JVM

## Java 内存模型

Java 内存模型(JMM)定义了 Java 程序中多线程并发访问共享内存的规范。共享内存是指多个线程可以同时访问和修改的内存区域。

Java 内存模型的主要目的是定义程序中各种变量的访问规则。此处的变量包括了实例字段、静态字段和构成数组对象的元素, 但是不包括局部变量与方法参数, 因为后者是线程私有的, 不存在竞争问题。

Java 内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存, 线程的工作内存中保存了被该线程使用的变量的主内存副本, 线程对变量的所有操作都必须在工作内存中进行, 而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要通过主内存来完成。

主内存直接对应于物理硬件的内存, 而为了获取更好的运行速度, 虚拟机可能会让工作内存优先存储于寄存器和高速缓存中, 因为程序运行时主要访问的是工作内存。

## JVM 运行时数据区

- 线程私有区:
  - 程序计数器: 每个线程有一个属于自己的计数器来记录下一条要运行的指令。计数器记录正在执行的 java 字节码地址，如果执行的是 native 方法，则计数器为空
  - 虚拟机栈栈: 与线程在同一时间创建。每个方法执行时都会创建一个栈桢来存储方法的的本地变量表、操作数栈、动态链接、返回地址等信息。栈的大小决定了方法调用的深度（递归多少层，或嵌套调用多少层其他方法，-Xss 参数可以设置虚拟机栈大小）。栈的大小可以是固定的，也可以是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出 stackOverflowError。如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出 OutofMemoryError
  - 本地方法栈: 与虚拟机栈作用相似。但它不是为 Java 方法服务的，而是本地方法（C 语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同
- 线程共享区:
  - 堆: 存放对象和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的 Eden 区中，经过 GC 后进入新生代的 Survivor 区中，15 次 GC 后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则抛出 OutOfMemoryError
  - 方法区: 用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。其中运行时常量池存放编译生成的各种常量。如果虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且加载该类的 ClassLoader 被回收

## 堆和栈的区别

- 栈是运行时单位，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片
- 堆是存储单位，代表着数据，可被多个栈共享，所在区域不连续，会有碎片
- 功能不同: 栈内存用来存储局部变量和方法调用。而堆内存用来存储 Java 中的对象, 无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
- 共享性不同: 栈内存是线程私有的。堆内存是所有线程共有的
- 异常错误不同: 如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：java.lang.OutOfMemoryError
- 空间大小: 栈的空间大小远远小于堆的

## 类加载与卸载

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

其中验证,准备,解析合称链接

- 加载: 通过类的完全限定名,查找此类字节码文件,利用字节码文件创建 Class 对象
- 验证: 确保 Class 文件符合当前虚拟机的要求,不会危害到虚拟机自身安全
- 准备: 进行内存分配,为 static 修饰的类变量分配内存,并设置初始值(0 或 null)。不包含 final 修饰的静态变量,因为 final 变量在编译时分配
- 解析: 将常量池中的符号引用替换为直接引用的过程。直接引用为直接指向目标的指针或者相对偏移量等
- 初始化: 主要完成静态代码块执行以及静态变量的赋值。先初始化父类,再初始化当前类

初始化的触发条件

- 创建类的实例时
- 访问类的静态方法或静态变量的时候
- 使用 Class.forName 反射类的时候
- 某个子类初始化的时候

Java 自带的加载器加载的类, 在虚拟机的生命周期中是不会被卸载的, 只有用户自定义的加载器加载的类才可以被卸载

## 双亲委派模型

类加载器加载类时先把请求委托给自己的父类加载器执行,直到最顶层的启动类加载器。父类加载器能够完成加载则成功返回, 不能的话子类加载器才自己尝试加载。

优点:

1. 避免类被重复加载
2. 避免 Java 的核心 API 被篡改

内置的类加载器:

- 启动类加载器：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）
- 扩展类加载器：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是启动类加载器
- 系统类加载器：又叫应用类加载器，其父类是扩展类加载器。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器

## 分代回收

分代收集理论建立在两个分代假说之上:

1. 弱分代假说: 绝大多数对象都是朝生夕灭的
2. 强分代假说: 熬过越多次垃圾回收的对象就越难以消亡

这两个分代假说共同奠定了多款常用的垃圾回收器的一致的设计原则: 垃圾回收器应该将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄(年龄即对象熬过垃圾回收的次数)分配到不同的区域之中存储。

如果一个区域中大多数对象都是朝生夕灭, 那么把它们集中放在一起, 每次回收时只关注如何保留少量存活的对象而不是去标记那些大量将要被回收的对象, 就能以较低代价回收到大量的空间。如果剩下的都是难以消亡的对象, 那把它们集中放在一块, 垃圾回收器便可以使用较低的频率来回收这个区域, 这就同时兼顾了垃圾回收的时间开销和内存的空间有效利用。

在 Java 堆划分出不同的区域(新生代、老年代)之后, 垃圾回收器才可以每次只回收其中某一个或者某些部分的区域, 也能够对不同的区域使用不同的垃圾回收算法。

## 什么时候会触发 FullGC

- 直接调用 System.gc 外
- 老年代空间不足: 老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space
- 永久代空间满: 当系统中加载了大量的类(例如在使用动态类加载、CGLIB 等字节码操作库、或者在开发大型企业应用时加载大量的第三方库等)时，永久代可能会被占满，如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space。Java 8 及以后版本没有了永久代, 取而代之, 当元空间耗尽本地内存时，就会抛出 java.lang.OutOfMemoryError: Metaspace
- CMS GC 时出现 promotion failed 和 concurrent mode failure: 对于采用 CMS 进行老年代 GC 的程序而言，当这两种状况出现时可能会触发 Full GC。promotion failed 是在进行 Minor GC 时，survivor 区放不下、对象只能放入老年代，而此时老年代也放不下造成的。concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。 应对措施为：增大 survivor 空间、老年代空间或调低触发并发 GC 的比率
- 统计得到的 Minor GC 晋升到老年代的平均大小大于老年代的剩余空间: Hotspot 为了避免由于新生代对象晋升到老年代导致老年代空间不足的现象，在进行 Minor GC 时，做了一个判断，如果之前统计所得到的 Minor GC 晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发 Full GC。例如程序第一次触发 Minor GC 后，有 6MB 的对象晋升到老年代，那么当下一次 Minor GC 发生时，首先检查老年代的剩余空间是否大于 6MB，如果小于 6MB，则执行 Full GC。 当新生代采用 PS GC 时，方式稍有不同，PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时老年代的剩余空间是否大于 6MB，如小于，则触发对老年代的回收

## 对象分配规则

- 对象优先分配在 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝(新生代采用复制算法回收内存)
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次新生代 GC 那么对象会进入 Survivor 区，之后每经过一次新生代 GC 那么对象的年龄加 1，直到达到阀值对象进入老年代
- 动态判断对象的年龄。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代

## 空间分配担保机制

在 JDK 1.6 及以前的版本中，空间分配担保机制与 HandlePromotionFailure 参数密切相关。当发生 Minor GC 时，新生代的对象可能会因为年龄达到阈值或者 Survivor 区空间不足等原因需要晋升到老年代。此时，如果老年代没有足够的连续空间来容纳这些对象，JVM 会根据 HandlePromotionFailure 参数的设置来决定处理方式：

- HandlePromotionFailure 开启：检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小。若大于，则尝试进行对象晋升；若小于，则进行一次 Full GC
- HandlePromotionFailure 关闭：直接触发一次 Full GC

从 JDK 1.7 开始，HandlePromotionFailure 参数逐渐失去原有的作用，空间分配担保机制的实现逻辑发生了改变。在进行 Minor GC 之前，JVM 不再检查 HandlePromotionFailure 标志，而是进行以下检查：

- 第一次检查：查看老年代的最大可用连续空间是否大于新生代所有对象的总大小。如果大于，说明老年代有足够的空间来容纳新生代的所有对象，那么可以放心地进行 Minor GC
- 第二次检查：如果老年代的最大可用连续空间小于新生代所有对象的总大小，JVM 会进一步检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小
  - 若大于：JVM 会认为这次晋升是有风险的，但仍然会尝试进行 Minor GC。因为虽然老年代当前可能没有足够的空间容纳新生代所有对象，但从历史晋升情况来看，还是有可能成功晋升部分对象的。如果在 Minor GC 后有对象需要晋升到老年代，但老年代空间不足，就会触发 Full GC
  - 若小于：JVM 会直接进行一次 Full GC，先清理老年代的空间，为可能的对象晋升做准备，然后再进行 Minor GC

## 垃圾回收器
