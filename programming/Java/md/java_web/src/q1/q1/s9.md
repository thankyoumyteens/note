# 消息队列

## RabbitMQ 和 Kafka 的区别

- 架构模型
  - RabbitMQ：基于 AMQP 协议，具有丰富的路由功能和灵活的交换器类型。其基本架构包括生产者、交换器、队列和消费者，生产者将消息发送到交换器，交换器根据路由规则将消息路由到相应的队列，消费者从队列中获取消息
  - Kafka：由多个 Broker 组成集群，消息被组织成主题（Topic），每个主题可以有多个分区（Partition），生产者将消息发送到特定主题的分区，消费者通过消费者组从分区中拉取消息
- 消息存储
  - RabbitMQ：消息可以存储在内存或磁盘中，具体取决于配置和使用场景。但在处理大规模消息存储时，性能可能会受到一定限制
  - Kafka：主要以磁盘存储为主，利用磁盘的顺序读写特性来提高性能和吞吐量，能够处理海量的消息存储和快速读写
- 消息顺序性
  - RabbitMQ：默认情况下，在单个队列中可以保证消息的顺序性，但在多个队列或复杂的路由场景下，要保证全局的消息顺序性需要额外的处理和配置
  - Kafka：在同一个分区内，消息是严格按照顺序存储和消费的。但如果一个主题有多个分区，不同分区之间的消息顺序无法保证
- 性能
  - RabbitMQ：在处理小规模、低并发的消息场景时表现良好，它的优势在于其灵活性和对多种协议的支持。但在高并发、大规模消息处理时，性能相对 Kafka 可能会低一些
  - Kafka：具有高吞吐量、低延迟的特点，尤其适合处理大规模的实时数据和高并发的消息场景。它通过批量发送、异步处理等技术手段，能够在短时间内处理大量的消息

## kafka 消息堆积怎么处理

1. 增加消费者数量。增加 topic 的分区数，确保分区数足够多以支持更多的消费者。因为每个分区在同一时间只能被消费者组中的一个消费者消费
2. 将一些耗时的操作（如写入数据库、调用外部服务等）改为异步处理，使用线程池或消息队列来处理这些任务，让消费者可以更快地返回并继续消费下一条消息
3. Kafka 采用消费者拉取（pull）的方式从 broker 获取消息。消费者可以根据自身的处理能力和需求，自主控制拉取消息的速率和数量。如 max.poll.records（每次拉取的最大消息数）和 fetch.max.bytes（每次拉取的最大字节数）。Kafka 的消息是以日志文件的形式存储在磁盘上的, 这意味着大量消息积压时，消息不会全部占用内存，而是以文件形式存储在磁盘。当消费者处理不过来导致消息积压时，减少这些参数的值，让消息更多地停留在磁盘日志中，需要时再拉取处理

## kafka 如何保证消息不丢失

需要从生产者、Broker 以及消费者三个层面进行考虑和配置

- 生产者层面
  - 确认机制(ACK): 生产者发送消息时，可以通过设置 acks 参数来控制消息的确认机制，确保消息成功发送到 Broker。
  - 重试机制: 生产者可以设置 retries 参数来设置最大重试次数, retry.backoff.ms 参数啦设置重试间隔时间。当消息发送失败时，生产者会自动重试发送消息，直到达到最大重试次数
- Broker 层面
  - 多副本机制: 每个主题的分区都可以有多个副本，其中一个是 Leader 副本，负责处理读写请求，其他副本是 Follower 副本，通过与 Leader 副本同步消息来保证数据的一致性。可以通过设置 replication.factor 参数来指定每个分区的副本数
  - 同步副本集合(ISR): ISR 是与 Leader 副本保持同步的 Follower 副本集合。只有在 ISR 中的副本才会参与消息的确认和选举。可以通过设置 min.insync.replicas 参数来指定 ISR 中至少需要多少个副本才能进行消息的写入，确保有足够的副本同步消息，从而提高消息的可靠性
  - 日志刷盘策略: Kafka 的消息是先写入内存缓冲区，然后定期刷盘到磁盘。可以通过调整 log.flush.interval.messages（消息数达到一定数量时刷盘）和 log.flush.interval.ms（时间间隔达到一定值时刷盘）等参数来控制日志刷盘的频率，确保消息及时持久化到磁盘，减少因 Broker 故障导致消息丢失的风险
- 消费者层面
  - 手动提交偏移量: 在手动提交偏移量时，消费者需要在处理完消息后，手动调用 commitSync() 或 commitAsync() 方法来提交当前消费的偏移量

acks 参数的可选值:

- acks = 0：生产者发送消息后，不等待 Broker 的确认，直接认为消息发送成功。这种方式虽然发送速度快，但无法保证消息是否真正到达 Broker，可能会导致消息丢失，因此不建议用于需要保证消息不丢失的场景
- acks = 1：生产者发送消息后，等待 Leader 副本确认收到消息后就认为发送成功。如果 Leader 副本在确认消息后但在将消息同步到 Follower 副本之前发生故障，可能会导致消息丢失
- acks = all 或 acks = -1：生产者发送消息后，等待 Leader 副本和所有 ISR 中的副本都确认收到消息后才认为发送成功。这种方式可以最大程度地保证消息不丢失，但会降低消息的发送性能

## RabbitMQ 支持事务吗

支持

RabbitMQ 的事务机制主要基于 AMQP 协议提供的事务命令，主要涉及三个方法：

- tx.select：用于开启事务模式。当生产者或消费者调用该方法后，RabbitMQ 会将当前的信道（Channel）设置为事务模式
- tx.commit：用于提交事务。在开启事务模式后，生产者可以发送多条消息，当调用 tx.commit 方法时，之前发送的所有消息才会真正被提交到队列中；对于消费者而言，调用此方法意味着确认之前的消息处理操作
- tx.rollback：用于回滚事务。如果在事务执行过程中出现异常或错误，调用 tx.rollback 方法可以撤销当前事务中已经执行的操作，之前发送的消息不会被提交到队列
