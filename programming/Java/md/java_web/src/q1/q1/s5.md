# MyBatis

## #{}和${}的区别

`#{}` 是预编译处理，`${}` 是字符串替换。

Mybatis 在处理 `#{}` 时，会将 sql 中的 `#{}` 替换为 `?` 号，调用 PreparedStatement 的 set 方法来赋值。

Mybatis 在处理 `${}` 时，就是直接把 `${}` 替换成变量的值。

使用 `#{}` 可以有效的防止 SQL 注入，提高系统安全性。

## 实体类中的属性名和表中的字段名不一样怎么办

通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致

```xml
<select id="demo">
    select order_no as "orderNo"
    form order_info
</select>
```

通过来映射字段名和实体类属性名的一一对应的关系

```xml
<resultMap type="entity.OrderInfo" id="BaseResultMap">
    <id property="orderId" column="order_id"/>
    <result property="orderNo" column ="order_no"/>
</reslutMap>
```

## 分页插件的原理

分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

## Mybatis 延迟加载的实现原理是什么

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。

在 Mybatis 配置文件中，可以配置是否启用延迟加载 `lazyLoadingEnabled=true`。它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调 `用a.getB().getName()`，拦截器 invoke()方法发现 `a.getB()`是 null，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询出来，然后调用 `a.setB(b)`，于是对象 a 的 b 字段就有值了，接着完成 `a.getB().getName()` 方法的调用。这就是延迟加载的基本原理。

## Mybatis 的缓存

### 一级缓存

在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的 SQL，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的 SQL 语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。

每个 SqlSession 中持有 Executor，每个 Executor 中有一个 LocalCache。当用户发起查询时，MyBatis 根据当前执行的语句生成 MappedStatement，在 Local Cache 进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入 LocalCache，最后返回结果给用户。

1. MyBatis 一级缓存的生命周期和 SqlSession 一致
2. MyBatis 一级缓存内部设计简单，只是一个没有容量限定的 HashMap，在缓存的功能性上有所欠缺
3. MyBatis 的一级缓存最大范围是 SqlSession 内部，有多个 SqlSession 或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为 Statement

### 二级缓存

如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询。二级缓存开启后，同一个 namespace 下的所有操作语句，都影响着同一个缓存。

1. MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时粒度更加细，能够到 namespace 级别，通过 Cache 接口实现类不同的组合，对 Cache 的可控性也更强
2. MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻
3. 在分布式环境下，由于默认的 MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将 MyBatis 的 Cache 接口实现，有一定的开发成本，直接使用 Redis、Memcached 等分布式缓存可能成本更低，安全性也更高
