# Redis

## Redis 持久化方式

- RDB 用数据集快照的方式半持久化模式记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复
  - 优点：只有一个文件 dump.rdb ，方便持久化。容灾性好，一个文件可以保存到安全的磁盘。性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能。相对于数据集大时，比 AOF 的启动效率更高。
  - 缺点：数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候
- AOF 指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储，保存为 AOF 文件
  - 优点：数据安全， AOF 持久化可以配置, 使每进行一次命令操作就记录到 AOF 文件中一次。通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。AOF 机制有 rewrite 模式, AOF 文件没被 rewrite 之前(文件过大时会对命令进行合并重写)，可以删除其中的某些命令(比如误操作的 flushall)
  - 缺点：AOF 文件比 RDB 文件大，且恢复速度慢。数据集大的时候，比 RDB 启动效率低。

## 排名功能要用 redis 的哪个数据类型

在实现排名功能时，Redis 中的有序集合（Sorted Set，也称为 ZSet）是最合适的数据类型

有序集合的特性:

- 成员唯一：有序集合中的每个成员都是唯一的，不会出现重复的成员
- 分数排序：每个成员都关联着一个分数（score），Redis 会根据这些分数对成员进行从小到大的排序。当分数相同时，会按照成员的字典序进行排序
- 高效操作：支持对成员的添加、删除、修改分数等操作，并且可以根据分数范围或排名范围快速获取成员

```sh
# 添加成员及分数
ZADD game_ranking 100 "player1" 200 "player2" 150 "player3"
# 获取玩家 "player2" 的排名
ZREVRANK game_ranking "player2"
# 获取排名范围内的成员, 获取排名前 3 的玩家
ZREVRANGE game_ranking 0 2 WITHSCORES
# 将玩家 "player1" 的分数增加 50
ZINCRBY game_ranking 50 "player1"
```

## Redis 支持事务吗

Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。它的原理是先将属于一个事务的命令发送给 Redis，然后依次执行这些命令。

需要注意的点:

Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行。Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。

使用场景

- 银行转账：在银行转账的场景中，需要从一个账户扣除一定金额，然后将该金额添加到另一个账户中。这两个操作必须作为一个原子操作执行，以确保资金的安全性和一致性。可以使用 Redis 事务来实现，将扣除金额和添加金额的命令放在一个事务中，保证要么两个操作都成功，要么都失败
- 购物车结算：在电商应用的购物车结算过程中，需要同时更新商品库存、生成订单、扣除用户余额等操作。使用 Redis 事务可以确保这些操作在一个原子操作中完成，避免出现部分操作成功，部分操作失败的情况，从而保证数据的一致性

相关命令:

- MULTI：用于开启一个事务，它将后续的命令放入一个队列中，等待执行
- EXEC：用于执行事务中所有已经入队的命令。当执行 EXEC 命令时，Redis 会按照顺序依次执行队列中的命令，并将结果返回给客户端
- DISCARD：用于取消事务，它会清空事务队列中所有已经入队的命令，并且释放事务执行过程中占用的资源
- WATCH：用于监视一个或多个键，在执行事务之前，如果被监视的键被其他客户端修改，那么事务将被中断，不会执行。可以通过 UNWATCH 命令来取消对所有键的监视

## Redis 为什么设计成单线程的

多线程处理会涉及到锁，并且多线程处理会涉及到线程切换而消耗 CPU。采用单线程，避免了不必要的上下文切换和竞争条件。其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。

## 有哪些 Redis 集群模式

- 主从复制模式: 主节点负责处理写操作和读取操作，从节点则主要用于复制主节点的数据，并响应读操作。主节点将数据变更通过复制命令异步地发送给从节点，从节点接收并应用这些命令，以保持与主节点数据的一致性
  - 优点：实现了数据的冗余备份，提高了系统的可靠性，通过多个从节点可以分担读请求，提高系统的读性能
  - 缺点：主节点的写性能受限于单机性能，无法进行水平扩展。而且在主从切换过程中，可能会存在短暂的数据不一致问题
- 哨兵模式: 在主从复制模式的基础上，引入了哨兵节点。哨兵节点会定期监控主节点和从节点的运行状态，当发现主节点出现故障时，哨兵会自动进行主从切换，选举出一个从节点作为新的主节点，并通知其他节点进行相应的配置更新
  - 优点：实现了主从切换的自动化，大大提高了系统的可用性。无需人工干预，能够快速地将服务恢复，减少系统故障时间
  - 缺点：虽然提高了可用性，但并没有解决 Redis 写性能的瓶颈问题，仍然无法实现大规模的水平扩展。并且哨兵节点本身也需要保证高可用性，否则可能会影响整个集群的监控和故障转移功能
- Cluster 集群模式: 采用数据分片的方式，将数据分布在多个节点上，每个节点负责一部分数据的存储和读写
  - 优点：能够实现数据的自动分片和节点间的负载均衡，可根据业务需求动态添加或删除节点，实现水平扩展，提高系统的存储和读写性能。同时，具备一定的容错能力，当部分节点出现故障时，只要剩余的节点能够覆盖所有的哈希槽，集群仍然可以正常工作
  - 缺点：数据分布和请求路由相对复杂, 而且在集群规模较大时，集群的管理和维护难度也会相应增加

## Redis Cluster 集群的原理是什么

- 数据分片: Redis Cluster 采用哈希槽（Hash Slot）来实现数据的分片存储，主要内容如下：
  - 哈希槽划分：Redis Cluster 将整个键空间划分为 16384 个哈希槽（编号从 0 到 16383）。集群中的每个节点负责一部分哈希槽，例如一个包含 3 个节点的集群，可能节点 A 负责 0 - 5460 号哈希槽，节点 B 负责 5461 - 10922 号哈希槽，节点 C 负责 10923 - 16383 号哈希槽
  - 键的映射：当客户端向集群中写入或读取一个键时，Redis 会使用 CRC16 算法对键进行哈希计算，得到一个哈希值，然后将这个哈希值对 16384 取模，得到的结果就是该键对应的哈希槽编号。通过这种方式，每个键都能被映射到一个特定的哈希槽上，进而确定该键应该存储在哪个节点上
- 节点通信: 集群中的各个节点之间需要相互通信，以维护集群的状态和信息，主要通信机制如下：
  - Gossip 协议：Redis Cluster 使用 Gossip 协议来实现节点间的信息交换。每个节点会定期向其他节点发送消息，消息内容包括自身的状态信息、其他节点的状态信息以及哈希槽的分配信息等。通过这种方式，每个节点都能逐渐了解整个集群的拓扑结构和状态
  - 节点握手：当一个新节点加入集群时，它会与集群中的其他节点进行握手操作。在握手过程中，节点会交换各自的信息，包括节点 ID、IP 地址、端口号等，并同步哈希槽的分配信息。新节点会根据这些信息来确定自己在集群中的位置和负责的哈希槽范围
- 请求路由: 客户端与 Redis Cluster 交互时，需要进行正确的请求路由，主要有以下两种情况：
  - 直接路由：客户端可以直接连接到集群中的任意一个节点，并向该节点发送请求。如果该节点负责请求键对应的哈希槽，则直接处理该请求；如果不负责，则会返回一个 MOVED 错误，告知客户端该键对应的哈希槽所在的正确节点，客户端需要重新向正确的节点发送请求
  - Smart 客户端：为了减少客户端的重定向次数，提高性能，一些 Redis 客户端实现了 Smart 客户端功能。Smart 客户端会缓存哈希槽与节点的映射关系，当客户端发送请求时，会先根据本地缓存的信息直接将请求发送到负责该哈希槽的节点上，避免不必要的重定向
- 故障转移: Redis Cluster 具备一定的容错能力，当节点出现故障时，能够自动进行故障转移，主要过程如下：
  - 故障检测：每个节点会定期向其他节点发送 PING 消息，以检测其他节点的状态。如果一个节点在一定时间内没有收到某个节点的响应，则会将该节点标记为疑似下线（PFAIL）。当有足够多的节点都将某个节点标记为 PFAIL 时，该节点会被正式标记为下线（FAIL）
  - 主从切换：如果下线的节点是主节点，且该主节点有从节点，则集群会自动从该主节点的从节点中选举出一个新的主节点。选举过程基于 Raft 算法，通过投票机制来确定新的主节点。新的主节点会接管原主节点负责的哈希槽，继续提供服务

## 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来

直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。而且 Redis 是单线程，keys 指令会导致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。这在生产环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条件的 key 值，会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。

scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行的过程不会阻塞线程。scan 查找的数据可能存在重复，需要客户端操作去重。因为 scan 是通过游标方式查询的，所以不会导致 Redis 出现假死的问题。Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。scan 在检索的过程中，被删除的元素是不会被查询出来的，但是如果在迭代过程中有元素被修改，scan 不能保证查询出对应元素。相对来说，scan 指令查找花费的时间会比 keys 指令长。

## redis 的过期策略以及内存淘汰机制

redis 采用的是定期删除+惰性删除策略。

定期删除: redis 默认每个 100ms 检查，是否有过期的 key,有过期 key 则删除。需要说明的是，redis 不是每个 100ms 将所有的 key 检查一次，而是随机抽取进行检查。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。

惰性删除: 在获取某个 key 的时候，redis 会检查一下，这个 key 如果过期了此时就会删除。

如果定期删除没删除 key。然后也没即时去请求 key，也就是说惰性删除也没生效。这样，redis 的内存会越来越高。那么就应该采用内存淘汰机制。

1. noeviction: 当内存限制达到后, Redis 不会淘汰任何 key, 对于写操作会返回错误, 这是默认的策略
2. allkeys-lru: 当内存不足时, 根据最近最少使用原则, 从所有 key 中淘汰最久未被使用的 key
3. allkeys-random: 从所有 key 中随机选择并淘汰一些 key
4. volatile-lru: 与 allkeys-lru 类似, 但是只会淘汰那些设置了过期时间的 key
5. volatile-random: 与 allkeys-random 类似, 但是只会淘汰那些设置了过期时间的 key
6. volatile-ttl: 根据 key 的剩余生存时间(TTL)来淘汰, 优先淘汰那些剩余生存时间最短的 key
7. allkeys-lfu: 根据 key 的使用频率来淘汰, 优先淘汰那些使用频率最低的 key。这个策略在 Redis 4.0 及以上版本中可用
8. volatile-lfu: 与 allkeys-lfu 类似, 但是只会淘汰那些设置了过期时间的 key。这个策略在 Redis 4.0 及以上版本中可用
