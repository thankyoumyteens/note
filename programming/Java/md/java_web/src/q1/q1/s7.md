# MySQL

## SQL 优化手段有哪些

1. 查询语句中不要使用 `select *`
2. 尽量减少子查询，使用关联查询（left join,right join,inner join）替代
3. 减少使用 IN 或者 NOT IN ,使用 exists，not exists 或者关联查询语句替代
4. or 的查询尽量用 union 或者 union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all 会更好)
5. 应尽量避免在 where 子句中使用 `!=` 或 `<>` 操作符，否则将引擎放弃使用索引而进行全表扫描
6. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：`select id from t where num is null` 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：`select id from t where num=0`

## 什么是视图

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

## 并发事务会带来哪些问题

- 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
- 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改
- 不可重复读（Unrepeatableread）: 在一个事务内，多次读取同一行数据时，由于其他事务对该行数据进行了更新或删除操作，导致该事务在后续读取时得到不同的结果。简单来说，就是在同一个事务中，两次读取同一行记录的内容不一致
- 幻读（Phantom read）: 在一个事务内，多次执行相同的查询语句（通常是范围查询）时，由于其他事务插入或删除了符合查询条件的记录，导致该事务在后续查询中看到了之前不存在或者之前存在但现在消失的记录，就好像出现了 “幻觉” 一样

## 事务的隔离级别

- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 已提交读(Read Committed)：只能读取到已提交事务的数据。Oracle 默认是该级别。解决脏读, 但存在不可重复读
- 可重复读(Repeated Read)：一个事务在执行期间会对读取的数据加锁，防止其他事务对这些数据进行更新或删除操作，从而保证在同一个事务中多次读取同一行数据的结果是一致的，Mysql 的默认级别。解决不可重复读, 但存在幻读
- 可串行化(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

## 大表如何优化

1. 限定数据的范围: 禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内
2. 读/写分离: 经典的数据库拆分方案，主库负责写，从库负责读
3. 垂直分区: 把一张列比较多的表拆分为多张表。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。垂直分区可以简化表的结构，易于维护, 但主键会出现冗余，需要管理冗余列，并会引起 Join 操作
4. 水平分区: 保持数据表结构不变，把一张的表的数据拆成多张表来存放。通过某种策略把数据分片，这样每一片数据分散到不同的表或者库中。水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决 ，跨节点 Join 性能较差，逻辑复杂

## 分库分表之后主键如何处理

生成全局 id 有下面这几种方式：

- UUID：不适合作为主键，因为太长了，并且无序，如果作为数据库主键会严重影响性能。比较适合用于生成唯一的名字的标示比如文件的名字
- 利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本
- Twitter 的 snowflake 算法
- 美团的 Leaf 分布式 ID 生成系统

## varchar 与 char 的区别？varchar(30) 中的 30 代表的涵义

- 存储方式
  - CHAR：是定长字符类型。当你定义一个 CHAR 类型的字段时，数据库会为其分配固定长度的存储空间。例如，定义一个 CHAR(10) 的字段，无论实际存储的字符串长度是多少，都会占用 10 个字符的存储空间。如果存储的字符串长度小于定义的长度，数据库会在字符串后面用空格进行填充
  - VARCHAR：是变长字符类型。VARCHAR 类型的字段根据实际存储的字符串长度来分配存储空间，只占用实际字符长度加上额外的用于记录长度的字节数（通常是 1 或 2 个字节，取决于字符串的最大长度）。例如，定义一个 VARCHAR(10) 的字段，存储长度为 3 的字符串时，实际只占用 3 个字符加上记录长度的字节数的存储空间
- 空间使用
  - CHAR：由于是定长存储，当存储的字符串长度小于定义的长度时，会浪费一些存储空间
  - VARCHAR：根据实际存储的字符串长度分配空间，相对更节省空间
- 性能
  - CHAR：由于是定长存储，在进行数据读取和写入时，数据库可以直接定位到相应的存储位置，处理速度相对较快。尤其在处理长度固定的字符串时，CHAR 类型的性能优势明显
  - VARCHAR：由于是变长存储，在进行数据读取和写入时，需要额外处理记录长度的信息，处理速度相对较慢。但在存储长度变化较大的字符串时，VARCHAR 可以节省大量的存储空间
- 总结: 对效率要求高用 char，要节省空间用 varchar

varchar(30) 中的 30 表示该字段所能存储的最大字符数量。

## int(11) 中的 11 代表什么涵义

int(11) 中的 11，不影响字段存储的范围，只影响展示效果。

## 为什么 SELECT COUNT(\*) FROM table 在 InnoDB 比 MyISAM 慢

InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。

## 什么时候不要使用索引

1. 经常增删改的列不要建立索引
2. 有大量重复的列不建立索引
3. 表记录太少不要建立索引

## MVCC是什么

MVCC(Multi-Version Concurrency Control, 多版本并发控制)允许多个事务同时对同一数据进行读取和写入操作, 而不会相互干扰。MVCC 不能解决幻读问题。

InnoDB 通过 undo log 保存每条数据的多个版本, 并且能够找回数据的历史版本,

MVCC 只在已提交读和可重复读两个隔离级别下工作, 其他两个隔离级别和 MVCC 是不兼容的。因为未提交读总是读取最新的数据, 而不是读取符合当前事务版本的数据行。而串行化不允许事务并发执行。在可重复读中, 每个事务读到的数据版本可能是不一样的, 在同一个事务中, 用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。

对于 InnoDB 存储引擎, 每一行记录都有两个隐藏列 trx_id 和 roll_pointer, 如果数据表中存在主键或者非 NULL 的 UNIQUE 键时不会创建 row_id, 否则 InnoDB 会自动生成单调递增的隐藏主键 row_id。

- trx_id: 记录操作该行数据事务的事务 ID。事务每次开启时, 都会从数据库获得一个自增长的事务 ID, 可以从事务 ID 判断事务的执行先后顺序
- roll_pointer: 回滚指针, 指向当前记录行的 undo log 信息

undo log 分为两类:

1. insert undo log: insert 时产生的 undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即删除
2. update undo log: delete 和 update 时产生的 undo log, 不仅在事务回滚时需要, 快照读也需要, 只有当数据库所使用的快照中不涉及该日志记录, 对应的回滚日志才会被删除

多个事务并行操作某一行数据时, 不同事务对该行数据的修改会产生多个版本, 然后通过回滚指针(roll_pointer), 连成一个链表, 这个链表就称为版本链。

快照读: 读取的是记录数据的可见版本(有旧的版本)。不加锁,普通的 select 语句都是快照读

```sql
select * from my_table where id = 1;
```

当前读: 读取的是记录数据的最新版本, 显式加锁的都是当前读

```sql
select * from my_table where id = 1 for update;
select * from my_table where id = 1 lock in share mode;
```

ReadView 是当前事务开启的快照记录。ReadView 的几个重要属性:

- trx_ids: 当前未提交的事务 ID 集合(不包括当前事务自己和已提交的事务)
- low_limit_id: 目前出现过的最大的事务 ID+1(不管提没提交), 即下一个将被分配的事务 ID。如果最大的事务 id 是 10, 那么 low_limit_id 就是 11
- up_limit_id: trx_ids 中最小的事务 ID, 如果 trx_ids 为空, 则 up_limit_id 为 low_limit_id
- creator_trx_id: 表示生成该 ReadView 的事务的 id

ReadView 的创建时机:

1. read committed 隔离级别下, 每个 select 都会创建最新的 ReadView
2. repeatable read 隔离级别下, 则是当事务中的第一个 select 请求才创建 ReadView

访问某条记录的时候, 确定要访问的版本:

- 如果这条记录的 trx_id == creator_trx_id, 那么表示当前事务访问的是自己修改过的记录, 那么该版本对当前事务可见；
- 如果这条记录的 trx_id < up_limit_id, 那么表示生成该版本的事务在当前事务生成 ReadView 前已经提交, 所以该版本可以被当前事务访问
- 如果这条记录的 trx_id > low_limit_id 值, 那么表示生成该版本的事务在当前事务生成 ReadView 后才开启, 所以该版本不可以被当前事务访问
- 如果这条记录的 trx_id 在 up_limit_id 和 m_low_limit_id 之间, 那就需要判断一下这个 trx_id 是不是在 trx_ids 列表中
  - 如果在, 说明创建 ReadView 时生成该版本的事务还是活跃的, 该版本不可以被访问
  - 如果不在, 说明创建 ReadView 时生成该版本的事务已经被提交, 该版本可以被访问
- 如果最新的数据不符合 ReadView 的可见性规则, 那么就需要去 undo log 中查找历史快照, 直到返回符合规则的数据

## MySQL 如何做到高可用方案

1. MySQL 高可用：分库分表，通过 MyCat 连接多个 MySQL
2. MyCat 也得高可用：Haproxy，连接多个 MyCat
3. Haproxy 也得高可用：通过 keepalived 辅助 Haproxy

## MySQL 如何给事务加锁

- 自动加锁: 在 MySQL 的事务中，当执行某些操作时，会自动加锁。例如，在使用 InnoDB 存储引擎时，以下操作会自动加锁：
  - `SELECT ... FOR UPDATE` 用于在查询数据时对选中的行加上排他锁（X 锁），防止其他事务对这些行进行修改或删除操作，直到当前事务结束
  - `SELECT ... LOCK IN SHARE MODE` 用于在查询数据时对选中的行加上共享锁（S 锁），其他事务可以读取这些行，但不能修改或删除，直到当前事务结束
- 手动加锁: 除了自动加锁，还可以手动对表进行加锁，但这种方式会锁定整个表，影响并发性能

  ```sql
  -- 对 users 表加写锁
  LOCK TABLES users WRITE;
  -- 进行写操作
  -- 解锁表
  UNLOCK TABLES;

  -- 对 users 表加读锁
  LOCK TABLES users READ;
  -- 进行读操作
  -- 解锁表
  UNLOCK TABLES;
  ```

## redo log 和 undo log 的区别

- redo log（重做日志）主要用于保证数据库的持久性。当发生系统崩溃或数据库异常重启时，redo log 可以将未持久化到磁盘的数据页进行恢复，确保已提交的事务不会丢失数据。它记录的是物理层面的修改，即数据页上的实际修改操作。示例：当执行一个 INSERT 语句向表中插入数据时，数据首先会被写入内存中的数据页，同时会将该操作对应的物理修改记录到 redo log 中。即使在数据还未从内存刷新到磁盘时数据库崩溃，重启后也可以根据 redo log 中的记录将数据页恢复到崩溃前的状态
- undo log（回滚日志）主要用于实现事务的原子性和多版本并发控制（MVCC）。在事务执行过程中，如果需要回滚事务，可以根据 undo log 中的记录将数据恢复到事务开始前的状态。同时，undo log 还为 MVCC 提供了旧版本的数据，使得不同事务可以并发读取不同版本的数据。示例：当执行一个 UPDATE 语句修改某条记录时，undo log 会记录该记录修改前的值。如果事务需要回滚，就可以根据 undo log 中的记录将数据恢复到修改前的状态
