# Spring

## Autowired 和 Resource 的区别

@Resource 和@Autowired 都是做 bean 的注入时使用，其实@Resource 并不是 Spring 的注解，它的包是 javax.annotation.Resource，需要导入，但是 Spring 支持该注解的注入。

- 共同点: 两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法。
- 不同点
  - Autowired 为 Spring 提供的注解，需要导入包 org.springframework.beans.factory.annotation.Autowired
  - Autowired 注解是按照类型（byType）注入依赖对象，默认情况下它要求依赖的对象必须存在，如果想允许 null 值，可以设置它的 required 属性为 false。如果想使用按照名称（byName）来装配，可以结合@Qualifier 注解一起使用
  - Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包 javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略

## 依赖注入的方式有几种

- 构造器注入: 将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入
- setter 方法注入: 通过调用成员变量提供的 setter 函数将被依赖对象注入给依赖类
- 接口注入: 依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象

## Spring MVC 工作原理

1. 用户发送请求至前端控制器 DispatcherServlet
2. DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器
3. 处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet
4. DispatcherServlet 调用 HandlerAdapter 处理器适配器
5. HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)
6. Controller 执行完成返回 ModelAndView
7. HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet
8. DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器
9. ViewReslover 解析后返回具体 View
10. DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）
11. DispatcherServlet 响应用户

## bean 的生命周期

1. 实例化 Bean: 对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean
2. 设置对象属性(依赖注入): 实例化后的对象被封装在 BeanWrapper 对象中，紧接着，Spring 根据 BeanDefinition 中的信息 以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入
3. 处理 Aware 接口: 接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean
4. BeanPostProcessor: 如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现 BeanPostProcessor 接口，此时会调用 postProcessBeforeInitialization(Object obj, String s)方法
5. InitializingBean 与 init-method: 如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法
6. 如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在 Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术
7. 此时 Bean 已经被正确创建了
8. DisposableBean: 当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy()方法
9. destroy-method: 最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法

## bean 的作用域

- singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护
- prototype：为每一个 bean 请求提供一个实例
- request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收
- session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效

## Spring 框架中都用到了哪些设计模式

- 简单工厂模式：Spring 中的 BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得 Bean 对象
- 工厂方法模式：Spring 中的 FactoryBean 就是典型的工厂方法模式，实现了 FactoryBean 接口的 bean 是一类叫做 factory 的 bean。其特点是，spring 在使用 getBean() 调用获得该 factory 时，会自动调用该 factory 的 getObject() 方法，所以返回的不是 factory 这个 bean，而是它的 getOjbect() 方法的返回值
- 单例模式：在 spring 中用到的单例模式有：scope="singleton" ，注册式单例模式，bean 存放于 Map 中。bean name 当做 key，bean 当做 value
- 原型模式：在 spring 中用到的原型模式有：scope="prototype" ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响
- 代理模式：Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理

## ApplicationContext 和 BeanFactory 的区别

- BeanFactory 是不支持国际化功能的，因为 BeanFactory 没有扩展 Spring 中 MessageResource 接口。相反，由于 ApplicationContext 扩展了 MessageResource 接口，因而具有消息处理的能力（i18N）
- ApplicationContext 提供了强大的事件机制, 基本上牵涉到事件（Event）方面的设计，就离不开观察者模式，ApplicationContext 的事件机制主要通过 ApplicationEvent 和 ApplicationListener 这两个接口来提供的。当 ApplicationContext 中发布一个事件时，所有扩展了 ApplicationListener 的 Bean 都将接到这个事件，并进行相应的处理

ApplicationContext 继承了 BeanFactory，BeanFactory 是 Spring 中比较原始的 Factory，它不支持 AOP、Web 等 Spring 插件。而 ApplicationContext 不仅包含了 BeanFactory 的所有功能，还支持 Spring 的各种插件。

BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；而 ApplicationContext 面向使用 Spring 的开发者，相比 BeanFactory 提供了更多面向实际应用的功能，几乎所有场合都可以直接使用 ApplicationContext，而不是底层的 BeanFactory。

## 单例 Bean 是线程安全的么

不是, Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。

但实际上，大部分的 Spring Bean 并没有可变的状态(方法外的变量)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将 Bean 的作用域（Scope）由 Singleton 变更为 Prototype。

## Spring 是怎么解决循环依赖的

1. 首先 A 完成初始化第一步并通过 ObjectFactory 将自己提前添加到缓存中，在初始化的时候，发现自己依赖对象 B，此时就会去尝试注入 B，这个时候发现 B 还没有被创建出来
2. 然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来
3. 这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试注入 A。这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中
4. 回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了

bean 缓存:

1. singletonObjects: 一级缓存, 用来缓存已经初始化完成的 bean
2. earlySingletonObjects: 二级缓存, 用来缓存半成品 bean(只创建了对象, 还没完成依赖注入等过程的 bean)
3. singletonFactories: 三级缓存, 用来缓存 ObjectFactory

## 事务的隔离级别

- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 已提交读(Read Committed)：只能读取到已提交事务的数据。Oracle 默认是该级别。解决脏读, 但存在不可重复读: 一个事务先后读取同一条记录, 但两次读取的数据不同
- 可重复读(Repeated Read)：在同一个事务内的查询结果都是事务开始时刻的数据快照，Mysql 的默认级别。解决不可重复读, 但存在幻读: 一个事务按照条件查询数据时, 查不到对应的数据(因为查的是快照), 但是在插入数据时, 又发现这行数据已经存在(在其它事务中插入了)
- 可串行化(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

## 事务的传播级别
