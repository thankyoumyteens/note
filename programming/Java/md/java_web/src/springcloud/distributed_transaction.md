# 分布式事务

分布式事务的解决方案:

- Seata
- mq

## Seata

Seata 是一个开源的分布式事务解决方案。

Seata 的架构主要包括以下几个组件: 

- TC (Transaction Coordinator): 事务协调器, 负责管理全局事务的提交或回滚, 以及监控全局事务的状态
- TM (Transaction Manager): 事务管理器, 用于发起全局事务和结束全局事务
- RM (Resource Manager): 资源管理器, 负责锁定和解锁资源, 以及执行本地事务的提交或回滚。一个微服务就是一个 RM

Seata 支持多种事务模式, 

- XA 模式: 传统的两阶段提交协议(Two-Phase Commit, 2PC)的实现
- AT 模式是一种轻量级的分布式事务解决方案, 它通过在业务逻辑中嵌入额外的操作来实现分布式事务的一致性, 而无需显式地使用两阶段提交(2PC)。AT 模式是 Seata 默认推荐的模式, 因为它在保证事务一致性的同时, 也弥补了 XA 模式中资源锁定时间过长的问题
- TCC(Try-Confirm-Cancel)模式是一种基于业务补偿机制的分布式事务解决方案。TCC 模式要求开发者将业务操作拆分为 Try、Confirm 和 Cancel 三个阶段, 以确保分布式事务的原子性和一致性。这种方式需要开发者明确地定义每个阶段的行为, 代码耦合度高。TCC 模式适用于那些业务逻辑较为复杂, 且能够接受一定程度的开发复杂度提高的情况

### XA 模式的执行过程

#### 第一阶段: 准备阶段(Prepare Phase)

1. **事务开始**:

   - 应用程序调用 `begin` 方法开始一个全局事务。
   - Seata 的事务管理器(TM)通知事务协调器(TC)开始一个新的全局事务。

2. **资源注册**:

   - 每个参与事务的资源管理器(RM)都需要注册到事务协调器(TC)。
   - RM 在本地事务开始前, 向 TC 注册资源, 并获得一个 XID(全局唯一事务标识符)。

3. **本地事务开始**:

   - RM 开始本地事务, 并执行相关的业务逻辑。
   - 如果一切正常, RM 将资源状态标记为“准备就绪”。

4. **准备阶段完成**:
   - RM 向 TC 发送一个“准备就绪”的消息, 表示已准备好进行提交或回滚。

#### 第二阶段: 提交或回滚阶段(Commit or Rollback Phase)

1. **决定提交**:

   - 如果所有 RM 都向 TC 发送了“准备就绪”消息, TM 将会决定提交全局事务。
   - TM 通知 TC 执行提交操作。

2. **提交本地事务**:

   - TC 向 RM 发送提交命令。
   - RM 执行本地事务的提交操作, 并释放资源锁。

3. **提交完成**:

   - RM 向 TC 发送提交成功的确认消息。
   - TC 更新全局事务的状态为已提交。

4. **决定回滚**:

   - 如果任何一个 RM 的准备阶段失败, 或者 TM 决定回滚全局事务, TM 会通知 TC 执行回滚操作。
   - TC 向 RM 发送回滚命令。

5. **回滚本地事务**:

   - RM 执行本地事务的回滚操作, 并释放资源锁。

6. **回滚完成**:
   - RM 向 TC 发送回滚成功的确认消息。
   - TC 更新全局事务的状态为已回滚。

### AT 模式的执行过程

#### 准备阶段

1. **事务开始**:

   - 应用程序启动一个全局事务, 调用 `begin` 方法。
   - Seata 的事务管理器(TM)通知事务协调器(TC)开始一个新的全局事务, 并生成一个全局唯一的事务 ID(XID)。

2. **本地事务开始**:

   - 业务代码开始执行本地事务操作。
   - 在本地事务中, Seata 通过 AOP(面向切面编程)或其他方式拦截 SQL 语句, 自动插入 undo_log 记录。
   - undo_log 记录了原始数据的快照, 以及更新后的数据, 用于后续的回滚操作。

3. **本地事务提交**:
   - 业务逻辑完成后, 本地事务提交。
   - RM 将本地事务的结果上报给 TC。
   - RM 清除本地事务上下文。

#### 提交阶段

1. **提交全局事务**:

   - 如果所有本地事务都成功提交, TM 将会决定提交全局事务。
   - TM 通知 TC 执行提交操作。

2. **清理 undo_log**:

   - TC 向 RM 发送提交命令。
   - RM 清理 undo_log 表中的相关记录, 表明事务已完成。

3. **提交完成**:
   - RM 向 TC 发送提交成功的确认消息。
   - TC 更新全局事务的状态为已提交。

#### 回滚阶段

1. **回滚全局事务**:

   - 如果任何一个本地事务失败, 或者 TM 决定回滚全局事务, TM 会通知 TC 执行回滚操作。
   - TM 通知 TC 回滚全局事务。

2. **执行回滚**:

   - TC 向 RM 发送回滚命令。
   - RM 根据 undo_log 表中的记录执行回滚操作, 还原数据到事务开始之前的状态。

3. **回滚完成**:
   - RM 向 TC 发送回滚成功的确认消息。
   - TC 更新全局事务的状态为已回滚。

### TCC 模式的执行过程

#### 准备阶段

1. **全局事务开始**:

   - 应用程序启动一个全局事务, 调用 `begin` 方法。
   - Seata 的事务管理器(TM)通知事务协调器(TC)开始一个新的全局事务, 并生成一个全局唯一的事务 ID(XID)。

2. **本地 Try 操作**:
   - 对每个参与节点, 业务代码执行 Try 操作。
   - Try 操作尝试预留业务资源, 并且验证业务条件是否满足。
   - Try 操作通常会返回一个结果, 表示是否预留成功。

#### 确认阶段

1. **Try 操作成功后**:

   - 如果所有 Try 操作都成功, TM 将会决定提交全局事务。
   - TM 通知 TC 执行提交操作。

2. **Confirm 操作**:

   - TC 向各个资源管理器(RM)发送 Confirm 命令。
   - RM 执行 Confirm 操作, 真正消耗或释放预留的资源。
   - RM 向 TC 发送确认消息, 表示 Confirm 操作成功。

3. **提交完成**:
   - TC 收到所有 RM 的确认消息后, 更新全局事务状态为已提交。

#### 取消阶段

1. **Try 操作失败或部分 Try 操作失败**:

   - 如果任何一个 Try 操作失败, 或者 TM 决定取消全局事务, TM 会通知 TC 执行取消操作。
   - TM 通知 TC 取消全局事务。

2. **Cancel 操作**:

   - TC 向各个 RM 发送 Cancel 命令。
   - RM 执行 Cancel 操作, 释放之前预留的资源, 并进行必要的补偿操作。
   - RM 向 TC 发送取消成功的确认消息。

3. **取消完成**:
   - TC 收到所有 RM 的取消确认消息后, 更新全局事务状态为已取消。

## mq

使用消息队列 (Message Queue, MQ) 实现分布式事务可以采用多种不同的策略。一种常见的方法是利用消息队列的特性来实现所谓的“最终一致性”, 而不是传统的强一致性事务模型。

使用消息队列实现分布式事务的方法: 

- 最终一致性 (Saga)
- 异步补偿 (Outbox Pattern)

### 1. 最终一致性 (Saga)

Saga 是一种模式, 它通过一系列局部事务来实现全局事务的一致性。在 Saga 中, 每个局部事务都是一个独立的单元, 这些事务通过消息传递彼此协调。如果某个局部事务失败, Saga 会触发回滚操作来撤销之前的局部事务。

#### Saga 实现步骤: 

1. **初始化全局事务**:

   - 开始一个全局事务, 并记录事务 ID。

2. **局部事务**:

   - 执行第一个局部事务, 并将成功与否的状态记录下来。
   - 如果成功, 向消息队列发送一条消息, 通知下一个参与者执行其局部事务。
   - 如果失败, 则执行相应的补偿操作, 并记录事务状态。

3. **补偿操作**:

   - 如果任何一个局部事务失败, Saga 将会触发补偿操作来撤销之前的所有成功事务。
   - 补偿操作通常也是通过消息队列来通知各个参与者执行。

4. **完成全局事务**:
   - 当所有的局部事务都成功执行完毕时, 整个 Saga 完成。

### 2. 异步补偿 (Outbox Pattern)

Outbox 模式是一种利用数据库中的额外表来存储消息发送状态的技术。这种模式保证了消息发送和业务操作的原子性, 即使消息发送失败, 也可以重新尝试发送, 直到成功为止。

#### Outbox 模式实现步骤: 

1. **数据变更与消息记录**:

   - 在业务操作的同时, 将需要发送的消息记录到数据库的 Outbox 表中。
   - 这个操作确保了业务操作和消息发送请求的原子性。

2. **消息发布**:

   - 从 Outbox 表中读取待发送的消息。
   - 将消息发送到消息队列。

3. **消息状态更新**:

   - 如果消息发送成功, 更新 Outbox 表中的状态为已发送。
   - 如果消息发送失败, 可以设置一个重试机制, 或者标记为失败以便后续人工干预。

4. **消息消费**:

   - 消费者从消息队列接收消息并执行相应的业务逻辑。

5. **异常处理**:
   - 如果消费者处理消息失败, 可以记录错误, 并根据具体情况选择重试或者补偿操作。
