# sendfile 实现零拷贝

通过 sendfile 系统调用，数据可以直接在内核空间内部进行 I/O 传输，从而省去了数据在用户空间和内核空间之间的来回拷贝。与 mmap 内存映射方式不同的是， sendfile 调用中 I/O 数据对用户空间是完全不可见的。

基于 sendfile 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，3 次拷贝，流程如下：

1. 用户进程通过 `sendfile()` 函数向内核发起系统调用，上下文从用户态切换为内核态
2. CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核的读缓冲区
3. CPU 将读缓冲区中的数据拷贝到 socket 缓冲区
4. CPU 利用 DMA 控制器将数据从 socket 缓冲区拷贝到网卡
5. 上下文从内核态切换回用户态，sendfile 系统调用返回

相比较于 mmap 内存映射的方式，sendfile 少了 2 次上下文切换，但是仍然有 1 次 CPU 拷贝操作。使用 sendfile, 用户程序不能对数据进行修改，只适用于单纯的数据传输。

## sendfile + DMA gather

Linux 2.4 版本的内核对 sendfile 系统调用进行修改，为 DMA 拷贝引入了 gather 操作。在硬件的支持下，sendfile 拷贝方式不再从内核缓冲区的数据拷贝到 socket 缓冲区，取而代之的仅仅是拷贝缓冲区文件描述符和数据长度，这样 DMA 直接利用 gather 操作将页缓存中的数据打包发送到网卡中即可，本质就是和虚拟内存映射的思路类似。

基于 sendfile + DMA gather copy 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换、2 次拷贝，流程如下：

1. 用户进程通过 `sendfile()` 函数向内核发起系统调用，上下文从用户态切换为内核态
2. CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间的读缓冲区
3. CPU 把读缓冲区的文件描述符（file descriptor）和数据长度拷贝到 socket 缓冲区
4. 基于已拷贝的文件描述符和数据长度，CPU 利用 DMA 控制器的 gather/scatter 操作直接批量地将数据从内核的读缓冲区拷贝到网卡
5. 上下文从内核态切换回用户态，sendfile 系统调用返回
