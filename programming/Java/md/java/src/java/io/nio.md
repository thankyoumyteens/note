# 同步非阻塞 IO(Non-Blocking I/O)

在同步非阻塞 IO 模型中, 应用程序一旦开始 IO 系统调用, 会出现以下两种情况:

1. 在内核缓冲区中没有数据的情况下, 系统调用会立即返回, 返回一个调用失败的信息
2. 在内核缓冲区中有数据的情况下, 是阻塞的, 直到数据从内核缓冲复制到进程缓冲区。复制完成后, 系统调用返回成功, 应用程序开始处理进程缓冲区中的数据

以 socket 的 recvfrom 系统调用为例, 流程如下:

1. 在内核数据没有准备好的阶段, 用户线程发起 IO 请求时, 立即返回。所以, 为了读取到最终的数据, 用户线程需要不断地发起 IO 系统调用(循环)
2. 内核数据到达后, 用户线程发起系统调用, 用户线程阻塞。内核开始复制数据到用户进程缓冲区, 然后内核返回结果
3. 用户线程读到数据后, 才会解除阻塞状态, 继续执行

![](../../img/2.jpg)

非阻塞 IO 模型的问题在于，尽管应用程序可以在当前 IO 操作不能完成的时候迫使系统调用立刻返回而不至于阻塞，但是却无法知道什么时候再次请求 IO 操作可以顺利完成，只能周期性地做很多无谓的轮询，每隔一段时间就要重新请求一次系统调用，这种轮询策略极大浪费了 CPU 时间。

同步非阻塞 IO 虽然简称为 NIO, 但它和 Java 中的 NIO 不是一个东西。
