# 四种 IO 模型

常见的 IO 模型有四种:

1. 同步阻塞 IO(Blocking IO)
2. 同步非阻塞 IO(Non-blocking IO)
3. IO 多路复用模型(IO Multiplexing)
4. 异步 IO(Asynchronous IO)

## 同步阻塞 IO(Blocking I/O)

在阻塞式 IO 模型中, Java 应用程序从系统调用开始, 直到系统调用返回的这段时间内, Java 进程一直是阻塞的。返回成功后, 应用进程开始处理用户空间的缓存区数据。

以 socket 的 recvfrom 系统调用为例, 流程如下:

1. 应用程序发起系统调用开始, 用户线程就进入阻塞状态
2. 当内核收到系统调用, 就开始准备数据。一开始数据可能还没有到达内核缓冲区, 这个时候内核就要等待
3. 内核一直等到完整的数据到达, 才会将数据从内核缓冲区复制到进程缓冲区, 然后内核返回结果
4. 直到内核返回后, 用户线程才会解除阻塞的状态, 继续执行

![](../../img/1.jpg)

在高并发的应用场景下, 阻塞 IO 需要大量的线程来维护大量的网络连接, 内存、线程切换开销会非常巨大。

## 同步非阻塞 IO(Non-Blocking I/O)

在同步非阻塞 IO 模型中, 应用程序一旦开始 IO 系统调用, 会出现以下两种情况:

1. 在内核缓冲区中没有数据的情况下, 系统调用会立即返回, 返回一个调用失败的信息
2. 在内核缓冲区中有数据的情况下, 是阻塞的, 直到数据从内核缓冲复制到进程缓冲区。复制完成后, 系统调用返回成功, 应用程序开始处理进程缓冲区中的数据

以 socket 的 recvfrom 系统调用为例, 流程如下:

1. 在内核数据没有准备好的阶段, 用户线程发起 IO 请求时, 立即返回。所以, 为了读取到最终的数据, 用户线程需要不断地发起 IO 系统调用(循环)
2. 内核数据到达后, 用户线程发起系统调用, 用户线程阻塞。内核开始复制数据到用户进程缓冲区, 然后内核返回结果
3. 用户线程读到数据后, 才会解除阻塞状态, 继续执行

![](../../img/2.jpg)

非阻塞 IO 模型的问题在于，尽管应用程序可以在当前 IO 操作不能完成的时候迫使系统调用立刻返回而不至于阻塞，但是却无法知道什么时候再次请求 IO 操作可以顺利完成，只能周期性地做很多无谓的轮询，每隔一段时间就要重新请求一次系统调用，这种轮询策略极大浪费了 CPU 时间。

同步非阻塞 IO 虽然简称为 NIO, 但它和 Java 中的 NIO 不是一个东西。

## IO 多路复用(I/O Multiplexing)

上面的 IO 模型都是直接发起 IO 操作，而 IO 多路复用首先向内核发起一个查询的系统调用，传入文件描述符和感兴趣的事件(读/写就绪等)让内核监测，当其中一个或多个文件描述符的数据就绪，内核就会返回结果。程序再发起真正的 IO 操作。

在 linux 中，有 3 种系统调用可以让内核监测文件描述符，分别是: select, poll, epoll。

select, poll, epoll 使得进程可以在有数据时再发起真正的 I/O 操作, 但是 select, poll, epoll 在等待 IO 事件发生时仍然处于阻塞状态，如果希望进程在没有 IO 事件可以处理其它工作，可以考虑分派任务给其他线程。

以 socket 的 recvfrom 系统调用为例, 流程如下:

![](../../img/3.jpg)

Java 的 NIO 技术, 使用的就是 IO 多路复用模型。在 Linux 系统上使用的是 epoll 系统调用。

IO 多路复用并不是真正异步的 IO, 不管是 select, poll 还是 epoll, 都会导致进程阻塞。而发起真正的 IO 操作时(比如 recvfrom)，进程也会阻塞。IO 多路复用模型与一个线程维护一个连接的阻塞 IO 模式相比, 最大优势在于, 一个 select/poll/epoll 查询线程可以同时处理成千上万个连接。系统不必创建大量的线程, 也不必维护这些线程, 从而大大减小了系统的开销。

## 异步 IO(Asynchronous I/O)

在异步 IO 模型中, 在整个内核的数据处理过程中, 包括内核将数据从物理设备读取到内核缓冲区、将内核缓冲区的数据复制到用户线程缓冲区, 用户程序都不需要阻塞。

以 socket 的 recvfrom 系统调用为例, 流程如下:

1. 当用户线程发起了系统调用, 立刻就可以开始去做其他的事, 用户线程不阻塞
2. 内核开始准备数据, 等到数据准备好了, 内核就会将数据从内核缓冲区复制到用户进程缓冲区
3. 内核会给用户线程发送一个信号, 或者回调用户线程注册的回调接口, 告诉用户线程 IO 操作完成了
4. 用户线程读取用户进程缓冲区的数据, 完成后续的业务操作

![](../../img/5.jpg)

异步 IO 模型在内核等待数据和复制数据的两个阶段, 用户线程都不是阻塞的。用户线程需要接收内核的 IO 操作完成的事件, 或者注册一个 IO 操作完成的回调函数。

异步 IO 模型需要底层内核提供支持, Linux 对 AIO 的支持并不完善。
