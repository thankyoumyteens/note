# 基本消息模型

![](img/2.png)

- P：生产者，也就是要发送消息的程序
- C：消费者：消息的接受者，会一直等待消息到来。
- queue：消息队列，图中红色部分。可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 

# work消息模型

工作队列或者竞争消费者模式

![](img/3.png)

两个消费端共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。

work模型通过手动确认机制实现能者多劳

- P：生产者：任务的发布者
- C1：消费者1：领取任务并且完成任务
- C2：消费者2：领取任务并且完成任务

# 发布-订阅模型

## Fanout

也称为广播

![](img/4.png)

- P：生产者，向Exchange发送消息
- X：Exchange，接收生产者的消息，然后把消息发送给绑定的所有队列
- C1：消费者
- C2：消费者

在广播模式下，消息发送流程是这样的：

- 可以有多个消费者
- 每个消费者有自己的queue
- 每个队列都要绑定到Exchange
- 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。
- 交换机把消息发送给绑定过的所有队列
- 队列的消费者都能拿到消息。实现一条消息被多个消费者消费

## Direct

在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）

消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。

![](img/5.png)

- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。
- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列
- C1：消费者，其所在队列指定了需要routing key 为 error 的消息
- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息

## Topic

Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符

Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert

通配符规则：

- `#`：匹配一个或多个词, 如: `audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs`
- `*`：匹配不多不少恰好1个词, 如: `audit.*`：只能匹配`audit.irs`

![](img/6.png)

# RPC模型

![](img/7.png)

- 当客户端启动的时候，它创建一个匿名独享的回调队列。
- 在 RPC 请求中，客户端发送的消息带有两个属性：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。
- 将请求发送到一个 rpc_queue 队列中。
- 服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。
- 客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用
