# 基本消息模型

![](img/2.png)

- P: 生产者, 也就是要发送消息的程序
- C: 消费者: 消息的接受者, 会一直等待消息到来。
- queue: 消息队列, 图中红色部分。可以缓存消息；生产者向其中投递消息, 消费者从其中取出消息。 

# work消息模型

工作队列或者竞争消费者模式

![](img/3.png)

两个消费端共同消费同一个队列中的消息, 但是一个消息只能被一个消费者获取。

work模型通过手动确认机制实现能者多劳

- P: 生产者: 任务的发布者
- C1: 消费者1: 领取任务并且完成任务
- C2: 消费者2: 领取任务并且完成任务

# 发布-订阅模型

## Fanout

也称为广播

![](img/4.png)

- P: 生产者, 向Exchange发送消息
- X: Exchange, 接收生产者的消息, 然后把消息发送给绑定的所有队列
- C1: 消费者
- C2: 消费者

在广播模式下, 消息发送流程是这样的: 

- 可以有多个消费者
- 每个消费者有自己的queue
- 每个队列都要绑定到Exchange
- 生产者发送的消息, 只能发送到交换机, 交换机来决定要发给哪个队列, 生产者无法决定。
- 交换机把消息发送给绑定过的所有队列
- 队列的消费者都能拿到消息。实现一条消息被多个消费者消费

## Direct

在Direct模型下, 队列与交换机的绑定, 不能是任意绑定了, 而是要指定一个RoutingKey(路由key)

消息的发送方在向Exchange发送消息时, 也必须指定消息的routing key。

![](img/5.png)

- P: 生产者, 向Exchange发送消息, 发送消息时, 会指定一个routing key。
- X: Exchange(交换机), 接收生产者的消息, 然后把消息递交给 与routing key完全匹配的队列
- C1: 消费者, 其所在队列指定了需要routing key 为 error 的消息
- C2: 消费者, 其所在队列指定了需要routing key 为 info、error、warning 的消息

## Topic

Topic类型的Exchange与Direct相比, 都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符

Routingkey 一般都是有一个或多个单词组成, 多个单词之间以"."分割, 例如:  item.insert

通配符规则: 

- `#`: 匹配一个或多个词, 如: `audit.#`: 能够匹配`audit.irs.corporate` 或者 `audit.irs`
- `*`: 匹配不多不少恰好1个词, 如: `audit.*`: 只能匹配`audit.irs`

![](img/6.png)

# RPC模型

![](img/7.png)

- 当客户端启动的时候, 它创建一个匿名独享的回调队列。
- 在 RPC 请求中, 客户端发送的消息带有两个属性: 一个是设置回调队列的 reply_to 属性, 另一个是设置唯一值的 correlation_id 属性。
- 将请求发送到一个 rpc_queue 队列中。
- 服务器等待请求发送到这个队列中来。当请求出现的时候, 它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。
- 客户端等待回调队列里的数据。当有消息出现的时候, 它会检查 correlation_id 属性。如果此属性的值与请求匹配, 将它返回给应用
