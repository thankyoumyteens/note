# 消息落库方案

![](img/10.png)

1. 业务数据和消息数据入库（此时消息状态为未成功0）。
2. 向消息服务器发送消息。
3. 消息服务器收到消息后, 发送确认消息（确认应答) Ack。
4. 生产者接收到服务器发送的确认消息 Ack, 修改数据库中消息的状态为成功（1）。
5. 定时任务, 查询数据库中消息状态为未成功（0）的数据。
6. 重新发送未成功的消息。
7. 定时任务查询, 当重新发送的次数, 大于一定的值时, 修改该条消息状态为发送失败（2）。

# 延迟投递方案

![](img/11.png)

1. 上游服务器（消息生产者）维护业务数据入库。
2. 上游服务器向消息服务器发送消息。
3. 上游服务器在发送消息后的n秒(时间根据业务自定义), 发送延迟投递消息。
4. 下游服务器（消息消费者）监听消息服务器上的消息, 并对消息进行消费。
5. 下游服务器向消息服务器发送确认消息。这里响应不是正常的ACK, 而是重新生成一条消息, 投递到MQ中。
6. Callback 服务监听下游服务发送的确认消息, 如果收到消息则对消息状态做记录。
7. Callback 服务监听上游服务器发送的延迟消息, 收到延迟消息后去检查DB中是否存在消息, 如果存在, 则不需要做任何处理。如果不存在或者消费失败了, 那么Callback service就需要主动发起RPC通信给上游服务, 告诉它延迟投递的这条消息没有找到, 需要重新发送, 生产端收到信息后就会重新查询业务消息然后将消息发送出去。

这种方案不一定能保障百分百投递成功, 但是基本上可以保障大概99.9%的消息是OK的, 有些特别极端的情况只能是人工去做补偿了, 或者使用定时任务去做

主要目的是为了减少数据库操作, 提高并发量, 在高并发场景下, 最关心的不是消息100%投递成功, 而是一定要保证性能, 保证能抗得住这么大的并发量, 所以能减少数据库的操作就尽量减少, 可以异步的进行补偿
