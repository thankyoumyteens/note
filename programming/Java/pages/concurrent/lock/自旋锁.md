# 自旋锁

自旋锁认为: 如果持有锁的线程能在很短的时间内释放锁资源, 那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态, 只需等一等（也叫作自旋）, 在等待持有锁的线程释放锁后即可立即获取锁, 这样就避免了用户线程在内核状态的切换上导致的锁时间消耗。

线程在自旋时会占用CPU, 在线程长时间自旋获取不到锁时, 将会产CPU的浪费, 甚至有时线程永远无法获取锁而导致CPU资源被永久占用, 所以需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后, 线程会退出自旋模式并释放其持有的锁。

- 优点: 自旋锁可以减少CPU 上下文的切换, 对于占用锁的时间非常短或锁竞争不激烈的代码块来说性能大幅度提升, 因为自旋的CPU耗时明显少于线程阻塞、挂起、再唤醒时两次CPU上下文切换所用的时间。
- 缺点: 在持有锁的线程占用锁时间过长或锁的竞争过于激烈时, 线程在自旋过程中会长时间获取不到锁资源, 将引起CPU的浪费。所以在系统中有复杂锁依赖的情况下不适合采用自旋锁。

# 自适应的自旋锁

JDK 6引入了自适应的自旋锁。

JDK 1.6引入了适应性自旋锁。适应性自旋锁的自旋时间不再是固定值, 而是由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的, 可基本认为一个线程上下文切换的时间是就一个最佳时间。
