# 可重入锁
又名递归锁, 是指在同一个线程在外层方法获取锁的时候, 再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class）, 不会因为之前已经获取过还没释放而阻塞。可重入锁的一个优点是可一定程度避免死锁。

## 示例
```java
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```
在上面的代码中, 类中的两个方法都是被内置锁synchronized修饰的, doSomething()方法中调用doOthers()方法。因为内置锁是可重入的, 所以同一个线程在调用doOthers()时可以直接获得当前对象的锁, 进入doOthers()进行操作。

如果是一个不可重入锁, 那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉, 实际上该对象锁已被当前线程所持有, 且无法释放。所以此时会出现死锁。

# 实现方式

当线程尝试获取锁时, 可重入锁先尝试获取并更新status值, 如果status == 0表示没有其他线程在执行同步代码, 则把status置为1, 当前线程开始执行。如果status != 0, 则判断当前线程是否是获取到这个锁的线程, 如果是的话执行status+1, 且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值, 如果status != 0的话会导致其获取锁失败, 当前线程阻塞。

释放锁时, 可重入锁同样先获取当前status的值, 在当前线程是持有锁的线程的前提下。如果status-1 == 0, 则表示当前线程所有重复获取锁的操作都已经执行完毕, 然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后, 直接将status置为0, 将锁释放。
