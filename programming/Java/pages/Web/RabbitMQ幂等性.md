# 唯一ID + 指纹码

指纹码是为了应对用户在一瞬间的频繁操作, 这个指纹码可能是时间戳加别的服务给到的唯一信息码, 基本都是由业务规则拼接而来, 但是一定要保证唯一性, 然后就利用查询语句进行判断唯一ID + 指纹码是否存在数据库中, 如果存在, 就表示操作重复。

好处就是实现简单, 就一个拼接, 然后查询判断是否重复。

坏处就是在高并发时, 如果是单个数据库就会有写入性能瓶颈。

解决方案: 根据 ID 进行分库分表, 对 id 进行算法路由, 落到一个具体的数据库, 然后当这个 id 第二次来又会落到这个数据库, 这时候就像单库时的查重一样了。利用算法路由把单库的幂等变成多库的幂等, 分摊数据流量压力, 提高性能。

# 利用 redis 的原子性去实现

使用 redis 的原子性去实现需要考虑两个点

一、进行数据落库。问题是数据库和缓存如何做到原子性？数据库与缓存进行同步肯定要进行写操作, 到底先写 redis 还是先写数据库, 这个问题, 涉及到缓存更新与淘汰的问题

二、不落库, 那么都存储到缓存中, 如何设置定时同步的策略？不入库的话, 可以使用双重缓存等策略, 保障一个消息副本, 具体同步可以使用类似 databus 这种同步工具。
