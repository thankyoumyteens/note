# 1位全加器

逻辑表达式
```
结果 S = A ^ B ^ C
进位 C1 = A&B | B&C0 | C0&A
```

- A和B代表两个输入数字
- C0为上一位进位
- C1为输出进位
- S为这一位求和结果

# 串行进位加法器

把多个全加器顺序连接构成了串行进位加法器

![](imG/串行进位加法器.PnG)

## 这种加法器的问题
下一位的计算必须要等待上一位的进位结果计算完毕, 判断是否有进位才能计算

# 4位并行加法器(先行进位加法器)

要让每一位并行计算, 最重要的问题就是要解决进位的问题, 因为进位使相邻的位之间产生了依赖关系

## 简化每一位进位
```
C1 = A1×B1 + A1×C0 + B1×C0
```
逻辑表达式解释: 二进制每一位进位最多进1, 不可能进2, 那么这个进位的第一种情况就是, 两个加数都为1必然产生进位, 第二种情况就是至少一位加数为1, 上一位进位也为1。上面的式子就表达了这个意思。
```
C2 = A2×B2 + A2×C1 + B2×C1
```
可以看出C2对C1的依赖关系, 这时把C1代进C2
```
C2 = A2×B2 + A2×(A1×B1 + A1×C0 + B1×C0) + B2×(A1×B1 + A1×C0 + B1×C0)
```
发现C2可以直接由第一位加数和第二位加数以及最初的进位C0求出, 而不再依赖于C1。

对C1的表达式进行化简得到
```
C1 = A1×B1 + A1×C0 + B1×C0
   = (A1×B1) + (A1+B1) × C0
```

令`G1 = A1×B1`, `P1 = A1+B1`, 表达式变成了
```
C1 = G1 + P1 × C0
```

- 如果A1和B1都为1那么一定会产生进位, 即G1=1
- 于是称G为进位生成因子
- 如果A1和B1有一个为1, 即P1 = 1, 并且C0为1, 那么也会进位, 即P1 × C0 = 1
- 如果A1和B1有一个为1, 即P1 = 1, 并且C0为0, 那么不会进位, 即P1 × C0 = 0
- 于是称P为进位传递因子

把C2改成仅用G, P和C0表示
```
C2 = A2×B2 + A2×C1 + B2×C1
   = G2 + A2×(G1 + (P1×C0)) + B2×(G1 + (P1×C0))
   = G2 + A2×G1 + A2×(P1×C0) + B2×G1 + B2×(P1×C0)
   = G2 + (A2+B2)×G1 + (A2+B2)×(P1C0)
   = G2 + (P2×G1) + (P2×P1×C0)
```

把所有进位使用G和P表示
```
C1 = G1 + (P1×C0)
C2 = G2 + (P2×G1) + (P2×P1×C0)
C3 = G3 + (P3×G2) +(P3×P2×G1) + (P3×P2×P1×C0)
C4 = G4 + (P4×G3) + (P4×P3×G2) + (P4×P3×P2×C0) + (P4×P3×P2×P1×C0)
```
为什么只写到C4而不是一直写到C15, 因为单个门电路输入太多会导致效率更低

现在, 可以实现4位二进制数的并行加法了
