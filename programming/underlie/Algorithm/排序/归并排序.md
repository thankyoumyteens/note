# 归并排序

将数组不断二分, 直到每个数组长度为1,
再将分开的数组不断合并, 在合并过程中排序, 是对树的深度优先遍历
```
        [8 6 2 3 1 5 7 4]
            /        \
      [8 6 2 3]   [1 5 7 4]
      /    \         /    \
  [8 6]   [2 3]   [1 5]   [7 4]
  /  /   /  |      |  \    |  \
8   6   2   3      1   5   7   4
  \  \   \  |      |  /    |  /
  [6 8]   [2 3]   [1 5]   [4 7]
     \     /        \     /
     [2 3 6 8]   [1 4 5 7]
          \         /
       [1 2 3 4 5 6 7 8]
```

# 合并过程
- 数组被二分成两部分: 左数组2 3 6 8和右数组1 4 5 7
- 创建数组的副本
- 建立索引i指向**副本**数组的元素2(2是左数组的起始位置)
- 建立索引j指向**副本**数组的元素1(1是右数组的起始位置)
- 建立索引k指向**原始**数组的元素2
```
k
2 3 6 8 1 4 5 7

2 3 6 8  1 4 5 7
i        j
```
- 比较i和j所指元素的大小, 由于j指向的元素小, 将j指向的元素1设置给k指向的元素, 并将j向后移动指向下一个元素4, k向后移动指向下一个元素3
```
  k
1 3 6 8 1 4 5 7

2 3 6 8  1 4 5 7
i          j
```
- 继续比较i和j所指元素的大小, 这次i指向的元素小, 将i指向的元素2设置给k指向的元素, 并将i向后移动指向下一个元素3, k向后移动指向下一个元素6
```
    k
1 2 6 8 1 4 5 7

2 3 6 8  1 4 5 7
  i        j
```
- 以此类推
```
                k
1 2 3 4 5 6 7 8

2 3 6 8  1 4 5 7
      i        j
```
