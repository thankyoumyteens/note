# 切片

切片(slice)是动态数组, 可以通过 append 向 slice 中追加元素，长度不够时会动态扩展。

```go
type SliceHeader struct {
    // 指向底层数组的指针
    array unsafe.Pointer
    // 切片中当前元素的个数
    len   int
    // 切片的容量, array的长度
    cap   int
}
```

## 创建

```go
package main

import "fmt"

func main() {
    // 创建一个空的slice
    empty_slice := []int{}
	// 创建一个length和capacity都等于5的slice
	slice0 := make([]int, 5)
	// 创建一个length=3,capacity=5的slice
	slice1 := make([]int, 3, 5)
	// 创建长度和容量都为3的slice，并初始化
	slice2 := []int{1, 2, 3}
	// 创建长度和容量为100的slice，并为第100个元素赋值为3
	slice3 := []int{99: 3}
}
```

## 使用

```go
package main

import "fmt"

func main() {
	// 创建长度为5、容量为5的slice
	my_slice := []int{1, 2, 3, 4, 5}
	// 访问slice的第2个元素
	fmt.Println(my_slice[1])
	// 修改slice的第3个元素的值
	my_slice[2] = 0
	fmt.Println(my_slice)
}
// 输出
/*
2
[1 2 0 4 5]
*/
```

## 对 slice 进行切片

从源 slice 中切出一段来, 成为新的 slice。使用切片创建的 slice 共享同一个底层数组，因此修改其中一个 slice，会影响到其它 slice。

```go
package main

import "fmt"

func main() {
	// 创建长度为5、容量为5的slice
	my_slice := []int{1, 2, 3, 4, 5}
	fmt.Println(my_slice)
	// 复制my_slice
	fmt.Println(my_slice[:])
	// 从索引2开始到my_slice末尾
	fmt.Println(my_slice[2:])
	// 从索引0开始到索引2(不包括索引2)
	fmt.Println(my_slice[:2])
	// 从索引1开始到索引2(不包括索引2)
	new_slice := my_slice[1:2]
	fmt.Println(new_slice)
	// 修改1个slice, 影响所有slice
	new_slice[0] = 100
	fmt.Println(my_slice)
}
// 输出:
/*
[1 2 3 4 5]
[1 2 3 4 5]
[3 4 5]
[1 2]
[2]
[1 100 3 4 5]
*/
```

## copy

```go
func copy(dst, src []Type) int
```

将 src slice 拷贝到 dst slice，src 比 dst 长，就截断，src 比 dst 短，则只拷贝 src 那部分。

copy 的返回值是拷贝成功的元素数量，所以也就是 src slice 或 dst slice 中最小的那个长度。

```go
package main

import "fmt"

func main() {
	my_slice := []int{1, 2, 3, 4, 5}
	fmt.Println(my_slice)
	new_slice := make([]int, 3)
	copied_count = copy(new_slice, my_slice)
	fmt.Println(new_slice)
	// 修改1个slice, 不会影响其它slice
	new_slice[0] = 100
	fmt.Println(my_slice)
	fmt.Println(new_slice)
}
// 输出:
/*
[1 2 3 4 5]
[1 2 3]
[1 2 3 4 5]
[100 2 3]
*/
```

## append

使用 append()函数向 slice 追加一个元素。append()返回一个新的 slice，原始的 slice 会保留不变。

当 slice 的 length 已经等于 capacity 的时候，再使用 append()给 slice 追加元素，会自动扩展底层数组的长度。底层数组扩展时，会生成一个新的底层数组。所以旧底层数组仍然会被旧 slice 引用，新 slice 和旧 slice 不再共享同一个底层数组。

```go
package main

import "fmt"

func main() {
	// 创建长度为5、容量为5的slice
	my_slice := []int{1, 2, 3, 4, 5}
	fmt.Println(my_slice)
	new_slice := append(my_slice, 6)
	fmt.Println(new_slice)
	// 修改1个slice, 不会影响其它slice
	new_slice[0] = 100
	fmt.Println(my_slice)
	fmt.Println(new_slice)
}
```
