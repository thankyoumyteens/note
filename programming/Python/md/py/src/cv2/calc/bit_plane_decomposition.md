# 位平面分解

将灰度图像中所有像素点的二进制值中处于同一比特位上的值提取出来，得到一幅二值图像，该图像被称为灰度图像的一个位平面，这个过程被称为位平面分解。

例如，将一幅灰度图像内所有像素点上处于二进制位内最低位上的值进行组合，可以构成"最低有效位"位平面。在 8 位灰度图中，每一个像素使用 8 位二进制值来表示，可以组成 8 个二进制值图像，即可以将原图分解为 8 个位平面。

8 位灰度图中, 二进制数的每一位（从最高位 bit7 到最低位 bit0）对像素 "亮度 / 颜色" 的贡献不同 ——高位决定像素的整体明暗趋势，低位决定像素的细节 / 噪声。

不同位平面的权重关系如下：

| 位平面    | 信息类型      | 对图像的作用                   |
| --------- | ------------- | ------------------------------ |
| bit7~bit6 | 结构信息      | 决定图像整体轮廓和明暗分区     |
| bit5~bit4 | 过渡信息      | 补充局部细节，连接结构与噪声   |
| bit3~bit0 | 噪声/冗余信息 | 无有效结构，仅含细微纹理或噪声 |

位平面分解的本质是 “将图像的二进制信息分层”，其核心价值在于：

- 揭示了图像信息的层级结构: 高位决定轮廓，低位决定细节
- 为后续处理（压缩、增强、加密等）提供精准操作对象，避免对整体图像的盲目处理，提升效率和效果

假设一个 4×4 像素的灰度图像如下（每个数字是一个像素的灰度值，范围 0~255）：

```
[  0,  13,  64, 128]
[ 32,  25, 192, 255]
[  8,  15,  96, 224]
[  1,   7,  48, 160]
```

将所有像素转化为 8 位二进制后:

```
[ 0 0 0 0 0 0 0 0,  0 0 0 0 1 1 0 1,  0 1 0 0 0 0 0 0,  1 0 0 0 0 0 0 0 ]
[ 0 0 1 0 0 0 0 0,  0 0 0 0 1 1 0 1,  1 1 0 0 0 0 0 0,  1 1 1 1 1 1 1 1 ]
[ 0 0 0 0 1 0 0 0,  0 0 0 0 1 1 1 1,  0 1 1 0 0 0 0 0,  1 1 1 0 0 0 0 0 ]
[ 0 0 0 0 0 0 0 1,  0 0 0 0 0 1 1 1,  0 0 1 1 0 0 0 0,  1 0 1 0 0 0 0 0 ]
```

提取每个位平面(bit7~bit0):

```py
# bit7位平面
[0, 0, 0, 1]  # 像素0(0)、13(0)、64(0)、128(1)
[0, 0, 1, 1]  # 像素32(0)、25(0)、192(1)、255(1)
[0, 0, 0, 1]  # 像素8(0)、15(0)、96(0)、224(1)
[0, 0, 0, 1]  # 像素1(0)、7(0)、48(0)、160(1)

# bit6位平面
[0, 0, 1, 0]  # 像素0(0)、13(0)、64(1)、128(0)
[0, 0, 1, 1]  # 像素32(0)、25(0)、192(1)、255(1)
[0, 0, 1, 1]  # 像素8(0)、15(0)、96(1)、224(1)
[0, 0, 0, 0]  # 像素1(0)、7(0)、48(0)、160(0)

# bit5位平面
[0, 0, 0, 0]  # 像素0(0)、13(0)、64(0)、128(0)
[1, 0, 0, 1]  # 像素32(1)、25(0)、192(0)、255(1)
[0, 0, 1, 1]  # 像素8(0)、15(0)、96(1)、224(1)
[0, 0, 1, 1]  # 像素1(0)、7(0)、48(1)、160(1)

# bit4位平面
[0, 0, 0, 0]  # 像素0(0)、13(0)、64(0)、128(0)
[0, 0, 0, 1]  # 像素32(0)、25(0)、192(0)、255(1)
[0, 0, 0, 1]  # 像素8(0)、15(0)、96(0)、224(1)
[0, 0, 1, 1]  # 像素1(0)、7(0)、48(1)、160(1)

# bit3位平面
[0, 1, 0, 0]  # 像素0(0)、13(1)、64(0)、128(0)
[0, 1, 0, 1]  # 像素32(0)、25(1)、192(0)、255(1)
[1, 1, 0, 1]  # 像素8(1)、15(1)、96(0)、224(1)
[0, 0, 0, 1]  # 像素1(0)、7(0)、48(0)、160(1)

# bit2位平面
[0, 1, 0, 0]  # 像素0(0)、13(1)、64(0)、128(0)
[0, 1, 0, 1]  # 像素32(0)、25(1)、192(0)、255(1)
[0, 1, 0, 1]  # 像素8(0)、15(1)、96(0)、224(1)
[0, 1, 1, 0]  # 像素1(0)、7(1)、48(1)、160(0)

# bit1位平面
[0, 0, 0, 0]  # 像素0(0)、13(0)、64(0)、128(0)
[0, 0, 0, 1]  # 像素32(0)、25(0)、192(0)、255(1)
[0, 1, 0, 1]  # 像素8(0)、15(1)、96(0)、224(1)
[0, 1, 1, 0]  # 像素1(0)、7(1)、48(1)、160(0)

# bit0位平面
[0, 1, 0, 0]  # 像素0(0)、13(1)、64(0)、128(0)
[0, 1, 0, 1]  # 像素32(0)、25(1)、192(0)、255(1)
[0, 1, 0, 1]  # 像素8(0)、15(1)、96(0)、224(1)
[1, 1, 0, 0]  # 像素1(1)、7(1)、48(0)、160(0)
```

## 用代码实现位平面分解

```py
import cv2
import numpy as np


def bit_plane_decomposition(gray_img):
    height, width = gray_img.shape

    # 创建一个列表存储8个位平面
    bit_planes = []

    # 提取每个位平面 (bit0到bit7)
    for bit in range(8):
        # 创建掩码图像，对应位为1，其他位为0
        mask = np.ones((height, width), dtype=np.uint8) * (1 << bit)

        # 使用按位与操作提取当前位
        bit_plane = cv2.bitwise_and(gray_img, mask)

        # 将非零值转换为1，便于观察
        bit_plane[bit_plane != 0] = 1

        bit_planes.append(bit_plane)

    return gray_img, bit_planes


if __name__ == '__main__':
    img = np.array([
        [0, 13, 64, 128],
        [32, 25, 192, 255],
        [8, 15, 96, 224],
        [1, 7, 48, 160],
    ], dtype=np.uint8)
    gray_img, bit_planes = bit_plane_decomposition(img)
    # 显示原始图像和8个位平面
    print('Original Image')
    print(gray_img)
    print()
    for i, bit_plane in enumerate(bit_planes):
        print(f'Bit Plane {i}')
        print(bit_plane)
        print()
```
