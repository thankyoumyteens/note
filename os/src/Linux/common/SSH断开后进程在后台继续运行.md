# SSH断开, 如何让进程在后台继续运行

我们经常会碰到这样的问题, 用 telnet/ssh 登录了远程的 Linux 服务器, 运行了一些耗时较长的任务,  结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？

我们知道, 当用户注销(logout)或者网络断开时, 终端会收到 HUP(hangup)信号从而关闭其所有子进程。因此, 我们的解决办法就有两种途径: 要么让进程忽略 HUP 信号, 要么让进程运行在新的会话里从而成为不属于此终端的子进程。

## nohup

顾名思义, nohup 的用途就是让提交的命令忽略 hangup 信号。nohup 的使用是十分方便的, 只需在要处理的命令前加上 nohup 即可, 标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&"来将命令同时放入后台运行, 也可用">filename 2>&1"来更改缺省的重定向文件名。

nohup 示例
```
nohup ping www.ibm.com &
```

## setsid

nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断, 但如果我们换个角度思考, 如果我们的进程不属于接受 HUP 信号的终端的子进程, 那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。setsid 的使用也是非常方便的, 也只需在要处理的命令前加上 setsid 即可。

setsid 示例
```
setsid ping www.ibm.com
```

## &

这里还有一个关于 subshell 的小技巧。我们知道, 将一个或多个命名包含在"()"中就能让这些命令在子 shell 中运行中, 从而扩展出很多有趣的功能, 我们现在要讨论的就是其中之一。

当我们将"&"也放入"()"内之后, 我们就会发现所提交的作业并不在作业列表中, 也就是说, 是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。

subshell 示例
```
(ping www.ibm.com &)
```
新提交的进程的父 ID(PPID)为1(init 进程的 PID), 并不是当前终端的进程 ID。因此并不属于当前终端的子进程, 从而也就不会受到当前终端的 HUP 信号的影响了。
