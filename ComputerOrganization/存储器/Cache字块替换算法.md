# Cache字块替换算法

当Cache未命中且Cache中没有空的位置时, 便淘汰Cache中的某些数据以腾出位置存放新调入的数据, 这称为替换。确定替换的规则叫替换算法。

直接映射, 由于主存的每个块都对应cache中的固定位置, 所以不需要替换算法, 直接替换即可。

# FIFO算法

遵循先入先出原则, 若当前Cache被填满, 则替换最早进入Cache的那个。

这种方式实现简单。但是由于总是以最早调入的Cache块为替换目标, 没有按照程序的局部性进行。所以并不能提高Cache的命中率。因为最早调入的信息, 以后可能还会用到。

# Random算法

顾名思义, 随机替换。

实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定

# LFU算法

最不经常使用算法, 将一段时间内访问次数最少的存储块换出。

每块设立一个计数器, 每访问一次, 计数器的数值加1, 替换的时候, 将计数器数值最小的Cache块替换出去。

若有多个计数器最小的行，可按行号递增、或FIFO策略进行选择

—曾经被经常访问的主存块在未来不一定会用到（如：微信视频聊天相关的块），
并没有很好地遵循局部性原理，因此实际运行效果不如 LRU

# LRU算法

近期最少使用算法, 这种做法替换的是近期用的最少的字块。

- 每块设立一个计数器, 命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变
- 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1
- 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。

若Cache块的总数=2n，则计数器只需n位。且Cache装满后所有计数器的值一定不重复

基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因
此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。
若被频繁访问的主存块数量 > Cache行的数量，则有可能发生“抖动”，如：{1,2,3,4,5,1,2,3,4,5,1,2…}
