# 原码乘法

## 符号位

同号得正异号得负，使用异或门实现

## 数值位
```
   0.1101
×  0.1011
------------
     1101
    1101
   0000
  1101
  ----------
0.10001111
```
可见乘法结果只由被乘数1101和0错位相加得到

## 分步计算

- A=0.1101
- B=0.1011
```
A * 0.1011
= A * (0.1 + 0.00 + 0.001 + 0.0001)
= 0.1A + 0.00A + 0.001A + 0.0001A
= 0.1A + 0.00A + 0.001(A + 0.1A)
= 0.1A + 0.01[0A + 0.1(A + 0.1A)]
= 0.1{A + 0.1[0A + 0.1(A + 0.1A)]}
= 0.1{A + 0.1[0 + 0.1(A + 0.1(0 + A))]}
```

二进制0.1(1/2)可由右移1位表示, 则上面的结果可以表示为

| 乘数 | 结果                                  | 操作            |
|------|---------------------------------------|-----------------|
| -    | 0                                     | -               |
| 1    | 0.1(0 + A)                            | 加被乘数后乘0.1 |
| 1    | 0.1(A + 0.1(0 + A))                   | 加被乘数后乘0.1 |
| 0    | 0.1[0 + 0.1(A + 0.1(0 + A))]          | 加0后乘0.1      |
| 1    | 0.1{A + 0.1[0 + 0.1(A + 0.1(0 + A))]} | 加被乘数后乘0.1 |

## 按照机器方式实现乘法

| 部分积(累加器ACC) | 乘数(乘商寄存器MQ) | 操作 |
| -------------------- | ---- | ----------------------------------------------------- |
| 0.0000               | 1011 | 部分积初始值为0                                |
| 0.0000+0.1101=0.1101 | 1011 | 检查乘数最低位, 最低位为1, 加被乘数0.1101 |
| 0.0110               | 1101 | 部分积和乘数整体右移1位                    |
| 0.0110+0.1101=1.0011 | 1101 | 检查乘数最低位, 最低位为1, 加被乘数0.1101 |
| 0.1001               | 1110 | 部分积和乘数整体右移1位                    |
| 0.1001               | 1110 | 检查乘数最低位, 最低位为0, 加0            |
| 0.0100               | 1111 | 部分积和乘数整体右移1位                    |
| 0.0100+0.1101=1.0001 | 1111 | 检查乘数最低位, 最低位为1, 加被乘数0.1101 |
| 0.1000               | 1111 | 部分积和乘数整体右移1位                    |
| 0.1000               | 1111 | 乘数为4位, 已全部处理完, 此时部分积和乘数一起组成结果 |

# 补码乘法(Booth算法)

设 `A补=1.0101`, `B补=1.0011`, 求`[A×B]补`

1. 使用双符号位:` A补=11.0101`
2. 求出`-A补=00.1011`

| ACC                  | MQ     | 操作                                                                             |
| -------------------- | ------ | ---------------------------------------------------------------------------------- |
| 000000               | 100110 | ACC初始化为0, MQ中初始化为乘数并在右边补一个0, 使它与ACC的位数相同 |
| 000000+001011=001011 | 100110 | 如果MQ中次低位减去最低位等于1, 就加上-A补;如果等于-1, 就加上A补;如果等于0, 就加上0 |
| 000101               | 110011 | 整体右移1位, ACC做算术移位, MQ做逻辑移位                            |
| 000101+000000=000101 | 110011 | 如果MQ中次低位减去最低位等于0, 就加上0                             |
| 000010               | 111001 | 整体右移1位, ACC做算术移位, MQ做逻辑移位                            |
| 000010+110101=110111 | 111001 | 如果MQ中次低位减去最低位等于-1, 就加上A补                         |
| 111011               | 111100 | 整体右移1位, ACC做算术移位, MQ做逻辑移位                            |
| 111011               | 111100 | 如果MQ中次低位减去最低位等于0, 就加上0                             |
| 111101               | 111110 | 整体右移1位, ACC做算术移位, MQ做逻辑移位                            |
| 111101+001011=001000 | 111110 | 如果MQ中次低位减去最低位等于1, 就加上-A补                         |
| 001000               | 111110 | 已经做了5次加法(补码的符号位+数值位的位数)                      |
| 001000               | 1111   | 由于做了4次移位, 所以MQ的前4位是有效的, 丢掉MQ的最后2位      |
| 001000               | 1111   | ACC和MQ一起组成结果                                                         |
