# 斐波那契数列

在数学上，斐波那契数列以如下被以递推的方法定义: F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n ≥ 2，n ∈ N*）

# 递归表示

根据定义直译过来就是:
```c++
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

# 画出递归树

例如f(20)
```
           f(20)
       /          \
     f(19)       f(18)
    /    \      /     \
 f(18) f(17)  f(17) f(16)
  / \   / \    / \   / \
       ......
 /   \       /   \
f(2) f(1)  f(2) f(1)
```

观察递归树，很明显发现了算法低效的原因: 存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质: 重叠子问题。

# 解决重叠子问题

解决方法: 用一个备忘录记录已经算过的结果, 每次遇到一个子问题先去备忘录查一查，如果发现之前已经解决过这个问题了，直接把结果拿出来用，不要再耗时去计算了。

一般使用一个数组记录这个结果，也可以使用哈希表

```c++
int fib(int N) {
    if (N < 1) return 0;
    // 记录算过的结果的备忘录
    // 初始值全为 0
    vector<int> memo(N + 1, 0);
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
    // base case
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];
    // 没有计算过
    int result = helper(memo, n - 1) + helper(memo, n - 2);
    // 记住计算结果
    memo[n] = result;
    // 返回
    return result;
}
```

此时f(20)的递归树
```
             f(20)
         /          \
       f(19)       f(18)直接返回
      /    \
   f(18) f(17)直接返回
    /  \
  f(17)
  ......
 /   \
f(2) f(1)
```

# 动态规划

递归是先求解子问题，再将它们的解组合起来，求出原问题的解。

而动态规划与之相反，动态规划应用于子问题重叠的情况。在这种情况下，分治方法会做许多不必要的工作，他会反复求解那些已经计算过的子问题。
而动态规划对于每一个子子问题只求解一次，将其解保存在一个表格里面，从而无需每次求解一个子问题时都重新计算，避免了不必要的计算工作。

递归「自顶向下」: 从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

动态规划「自底向上」: 反过来，直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

```c++
int fib(int N) {
    if (N < 1) return 0;
    if (N == 1 || N == 2) return 1;
    // 备忘录, 初始值全为 0
    vector<int> dp(N + 1, 0);
    // base case
    dp[1] = dp[2] = 1;
    // 自底向上
    for (int i = 3; i <= N; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[N];
}
```
