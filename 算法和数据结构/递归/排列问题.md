# 问题

给定一个整型数组, 其中的每个元素都不相同, 返回这些元素所有的排列可能
- 例如[1, 2, 3]
- 返回[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

# 转化成树形问题
- 先从123中拿出1, 数组中剩下2和3
- 再从剩下23中拿出2
- 再拿出剩下的3
- 此时得到了一个组合123
- 返回上一步, 从23中拿出3
- 再拿出剩下的2
- 此时得到了一个组合132
- 返回上一步, 此时23中已经没有元素
- 再向上返回到123
- 再从123中拿出2, 数组中剩下1和3
- ...
- 整个过程是树的深度优先遍历的过程
```
                     [1,2,3]
          _____________________________
         /              |              \
        1               2               3
       /                |                \
     [2,3]            [1,3]            [1,2]
      / \              / \              / \
     2   3            2   3            2   3
    /     \          /     \          /     \ 
  [3]     [2]      [3]     [2]      [3]     [2]   
[1,2,3] [1,3,2]  [1,2,3] [1,3,2]  [1,2,3] [1,3,2]     
```

# 代码

```java
public class Solution {
	// 结果集
	private ArrayList<List<Integer>> res;
	// 记录已经拿出的元素
	private boolean[] used;

	// 入口
	public List<List<Integer>> permute(int[] nums) {
		res = new ArrayList<List<Integer>>();
		if(nums == null || nums.length == 0)
			return res;

		used = new boolean[nums.length];
		// 记录每一个结果[1,2,3]或[1,3,2]或...
		LinkedList<Integer> p = new LinkedList<Integer>();
		// 从数组第一个元素开始
		generatePermutation(nums, 0, p);

		return res;
	}

	// index表示结果p中的元素个数
	private void generatePermutation(int[] nums, int index, LinkedList<Integer> p){
		// 如果p中已经有了nums的所有元素
		if(index == nums.length){
			// 把当前结果p添加到结果集中
			res.add((LinkedList<Integer>)p.clone());
			return;
		}
		for(int i = 0 ; i < nums.length ; i ++) {
			// 一次拿出nums中的一个元素
			// 和nums中剩下的元素组合
			if(!used[i]) {
				used[i] = true;
				p.addLast(nums[i]);
				generatePermutation(nums, index + 1, p );
				// 这个元素用完后要从结果p中去掉
				p.removeLast();
				used[i] = false;
			}
		}
	}
}
```
