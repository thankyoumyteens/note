# 三路快速排序(快速排序优化)

选中第一个元素v, 调整数组使得左边的元素小于v, 中间的元素等于v, 右边的元素大于v, 使v所在的中间部分将原数组在逻辑上分割为左右两个子数组, 不断重复这个操作, 直到分割后的所有子数组长度都等于1, 此时排序已经完成

![](img/qS3.PNG)

## 示例数据

`4 6 2 3 4 5 7 8`

## 排序过程

1. 选中第一个元素4, 并用j指向元素4, k指向最后一个元素8, 开始遍历剩余的元素`6 2 3 4 5 7 8`
2. 首先遍历到6, 由于6大于4, 所以把6和k-1指向的元素交换, 此时k-1指向的元素是7, 所以把6和7交换, 保持循环的i不变, 并把k指向k-1所在的元素, 这里是6: `4 7 2 3 4 5 6 8`
3. 接下来仍然遍历到第二个元素, 此时是7, 由于7大于4, 所以把7和k-1指向的元素交换, 此时k-1指向的元素是5, 所以把7和5交换, 保持循环的i不变, 并把k指向k-1所在的元素, 这里是7: `4 5 2 3 4 7 6 8`
4. 接下来仍然遍历到第二个元素, 此时是5, 由于5大于4, 所以把5和k-1指向的元素交换, 此时k-1指向的元素是4, 所以把5和4交换, 保持循环的i不变, 并把k指向k-1所在的元素, 这里是5: `4 4 2 3 5 7 6 8`
5. 接下来仍然遍历到第二个元素, 此时是4, 由于4等于4, 所以不做任何操作: `4 4 2 3 5 7 6 8`
6. 接下来遍历到第三个元素2, 由于2小于4, 所以把2和j+1指向的元素交换, 此时j+1指向的元素是4, 所以把2和4交换, 并把j指向j+1所在的元素, 这里是2: `4 2 4 3 5 7 6 8`
7. 接下来遍历到第四个元素3, 由于3小于4, 所以把3和j+1指向的元素交换, 此时j+1指向的元素是4, 所以把3和4交换, 并把j指向j+1所在的元素, 这里是3: `4 2 3 4 5 7 6 8`
8. 接下来仍然遍历到第五个元素4, 由于4等于4, 所以不做任何操作: `4 2 3 4 5 7 6 8`
9. 接下来仍然遍历到第六个元素5, 由于此时循环计数i和k已经相等, 都指向了5, 遍历结束
10. 将第一个元素4和j指向的元素3交换: `3 2 4 4 5 7 6 8`
11. 此时原始数组已经被4分成了两个子数组: `3 2`和`6 5 7 8`
12. 继续对两个子数组`3 2`和`6 5 7 8`分别进行上面的操作, 直到不能再拆分

## 代码表示

```java
/**
 * 快速排序
 */
public void sort(Comparable[] array) {
    quickSsort(array, 0, array.length - 1);
}
/**
 * 递归使用快速排序, 对arr[l...r]的范围进行排序
 */
private static void quickSsort(Comparable[] arr, int l, int r) {
    // 对于小规模数组, 使用插入排序进行优化
    if (r - l <= 15) {
        InsertionSort.sort(arr, l, r);
        return;
    }
    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    ArrayUtil.swap(arr, l, (int) (Math.random() * (r - l + 1)) + l);
    Comparable v = arr[l];
    // arr[l+1...lt] < v
    int lt = l;
    // arr[gt...r] > v
    int gt = r + 1;
    // arr[lt+1...i) == v
    int i = l + 1;

    while (i < gt) {
        if (arr[i].compareTo(v) < 0) {
            ArrayUtil.swap(arr, i, lt + 1);
            i++;
            lt++;
        } else if (arr[i].compareTo(v) > 0) {
            ArrayUtil.swap(arr, i, gt - 1);
            gt--;
        } else { // arr[i] == v
            i++;
        }
    }
    // 将v移动到中间
    ArrayUtil.swap(arr, l, lt);
    // 重复分割过程
    quickSsort(arr, l, lt - 1);
    quickSsort(arr, gt, r);
}
```
