# 快速排序

选中第一个元素v, 调整数组使得v左边的元素小于v, 右边的元素大于v, 使v在逻辑上分割原数组为左右两个子数组, 不断重复这个操作, 直到分割后的所有子数组长度都等于1, 此时排序已经完成

![](img/qS.PNG)

## 示例数据
```
4 6 2 3 1 5 7 8
```
## 排序过程

1. 选中第一个元素4, 并用j指向元素4, 开始遍历剩余的元素6 2 3 1 5 7 8
2. 首先遍历到6, 由于6大于4, 所以不做任何操作4 6 2 3 1 5 7 8
3. 接下来遍历到2, 由于2小于4, 所以把2和j+1指向的元素交换, 此时j+1指向的元素是6, 所以把2和6交换, 并把j指向j+1所在的元素, 这里是2: 4 2 6 3 1 5 7 8
4. 接下来遍历到3, 由于3小于4, 所以把3和j+1指向的元素交换, 此时j+1指向的元素是6, 所以把3和6交换, 并把j指向j+1所在的元素, 这里是3: 4 2 3 6 1 5 7 8
5. 接下来遍历到1, 由于1小于4, 同上, j指向1: 4 2 3 1 6 5 7 8
6. 接下来遍历到5, 由于1大于4, 所以不做任何操作: 4 2 3 1 6 5 7 8
7. 接下来遍历到7, 由于7大于4, 所以不做任何操作: 4 2 3 1 6 5 7 8
8. 接下来遍历到8, 由于8大于4, 所以不做任何操作: 4 2 3 1 6 5 7 8
9. 此时已经遍历完数组了, 最后将4和j指向的元素交换: 1 2 3 4 6 5 7 8
10. 此时原始数组已经被4分成了两个子数组: 1 2 3和6 5 7 8
11. 继续对两个子数组1 2 3和6 5 7 8分别进行上面的操作, 直到不能再拆分

## 关于v的选择

选择数组的第一个元素太大或者太小都会导致排序的效率降低, 所以应该从数组中随机选择一个元素, 把它与数组的第一个元素交换, 作为v

## 代码表示

```java
/**
 * 快速排序
 */
public void sort(Comparable[] array) {
    quickSort(array, 0, array.length - 1);
}
/**
 * 递归使用快速排序,对arr[l...r]的范围进行排序
 */
private static void quickSort(Comparable[] arr, int l, int r) {
    // 数组长度<=1
    if (l >= r) return;
    int p = partition(arr, l, r);
    quickSort(arr, l, p - 1);
    quickSort(arr, p + 1, r);
}
/**
 * 对arr[l...r]部分进行分割(partition)操作
 * 返回p, 使得arr[l...p-1] < arr[p] ; arr[p+1...r] > arr[p]
 */
private static int partition(Comparable[] arr, int l, int r) {
    Comparable v = arr[l];
    int j = l;
    // 调整数组, 使得: arr[l+1...j] < v, arr[j+1...i-1] > v
    for (int i = l + 1; i <= r; i++)
        if (arr[i].compareTo(v) < 0) {
            j++;
            ArrayUtil.swap(arr, j, i);
        }
    ArrayUtil.swap(arr, l, j);
    return j;
}
```
